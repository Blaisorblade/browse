<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/tools/nsc/symtab/classfile/PickleBuffer.scala</title>
        <script type="text/javascript" src="../../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style">
    </head>
    <body>
        <pre>
/* NSC -- new Scala compiler
 * Copyright 2005-2009 LAMP/EPFL
 * @author  Martin Odersky
 */
// $Id: PickleBuffer.scala 18387 2009-07-24 15:28:37Z odersky $

<span class="keyword">package</span> scala.tools.nsc
<span class="keyword">package</span> symtab
<span class="keyword">package</span> classfile

/** Variable length byte arrays, with methods for basic pickling and unpickling.
 *
 *  @param data The initial buffer
 *  @param from The first index where defined data are found
 *  @param to   The first index where new data can be written
 */
<span class="keyword">class</span> <a title="class PickleBuffer extends java.lang.Object with ScalaObject" id="20469">PickleBuffer</a><a title="ScalaObject" id="959">(</a><a title="Array[Byte]" id="148260">data</a>: <span title="Array[Byte]">Array</span>[Byte], <a title="Int" id="148261">from</a>: <span title="Int">Int</span>, <a title="Int" id="148262">to</a>: <span title="Int">Int</span>) {

  <span class="keyword">var</span> <a title="Array[Byte]" id="83276">bytes</a> = <a href="#148260" title="Array[Byte]">data</a>
  <span class="keyword">var</span> <a title="Int" id="83279">readIndex</a> = <a href="#148261" title="Int">from</a>
  <span class="keyword">var</span> <a title="Int" id="83282">writeIndex</a> = <a href="#148262" title="Int">to</a>

  /** Double bytes array */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Unit" id="83284">dble</a>() {
    <span class="keyword">val</span> <a title="Array[Byte]" id="734822">bytes1</a> = <span title="Array[Byte]" class="keyword">new</span> <span title="Array[Byte]">Array</span>[Byte](<a href="#83276" title="=&gt; Array[Byte]">bytes</a>.<a title="(x$1: Int)Int" id="2968">length</a> * <span title="Int(2)" class="int">2</span>)
    <span title="object Array">Array</span>.<span title="(src: AnyRef,srcPos: Int,dest: AnyRef,destPos: Int,length: Int)Unit">copy</span>(<a href="#83276" title="=&gt; Array[Byte]">bytes</a>, <span title="Int(0)" class="int">0</span>, <a href="#734822" title="Array[Byte]">bytes1</a>, <span title="Int(0)" class="int">0</span>, <a href="#83282" title="=&gt; Int">writeIndex</a>)
    <a href="#83276" title="(x$1: Array[Byte])Unit">bytes</a> = <a href="#734822" title="Array[Byte]">bytes1</a>
  }

  <span class="keyword">def</span> <a title="(capacity: Int)Unit" id="83285">ensureCapacity</a>(<a title="Int" id="150067">capacity</a>: <span title="Int">Int</span>) =
    <span title="Unit" class="keyword">while</span> (<a href="#83276" title="=&gt; Array[Byte]">bytes</a>.<span title="(x$1: Int)Boolean">length</span> &lt; <a href="#83282" title="(x$1: Int)Int">writeIndex</a> + <a href="#150067" title="Int">capacity</a>) <a href="#83284" title="()Unit">dble</a><a href="#150070" title="()Unit">(</a>)

  // -- Basic output routines --------------------------------------------

  /** Write a byte of data */
  <span class="keyword">def</span> <a title="(b: Int)Unit" id="83286">writeByte</a>(<a title="Int" id="151446">b</a>: <span title="Int">Int</span>) {
    <span title="Unit" class="keyword">if</span> (<a href="#83282" title="(x$1: Int)Boolean">writeIndex</a> == <a href="#83276" title="=&gt; Array[Byte]">bytes</a>.<span title="=&gt; Int">length</span>) <a href="#83284" title="()Unit">dble</a>()
    <a href="#83276" title="(i: Int,x: Byte)Unit">bytes</a>(<a href="#83282" title="=&gt; Int">writeIndex</a>) = <a href="#151446" title="Int">b</a>.<span title="[T0]T0">asInstanceOf</span><span title="Byte">[</span><span title="Byte">Byte</span>]
    <a href="#83282" title="(x$1: Int)Unit">writeIndex</a> += <span title="Int(1)" class="int">1</span>
  }

  /** Write a natural number in big endian format, base 128.
   *  All but the last digits have bit 0x80 set.
   */
  <span class="keyword">def</span> <a title="(x: Int)Unit" id="83287">writeNat</a>(<a title="Int" id="149264">x</a>: <span title="Int">Int</span>) =
    <a href="#83288" title="(x: Long)Unit">writeLongNat</a>(<a href="#149264" title="Int">x</a>.<span title="[T0]T0">asInstanceOf</span><a title="(x$1: Long)Long" id="3212">[</a><span title="Long">Long</span>] &amp; <span title="Long(4294967295L)" class="long">0x00000000FFFFFFFFL</span>)

  /**
   * Like writeNat, but for longs. This is not the same as
   * writeLong, which writes in base 256. Note that the
   * binary representation of LongNat is identical to Nat
   * if the long value is in the range Int.MIN_VALUE to
   * Int.MAX_VALUE.
   */
  <span class="keyword">def</span> <a title="(x: Long)Unit" id="83288">writeLongNat</a>(<a title="Long" id="149267">x</a>: <span title="Long">Long</span>) {
    <span class="keyword">def</span> <a title="(x: Long)Unit" id="734912">writeNatPrefix</a>(<a title="Long" id="734914">x</a>: <span title="Long">Long</span>) {
      <span class="keyword">val</span> <a title="Long" id="734915">y</a> = <a href="#734914" title="(x$1: Int)Long">x</a> &gt;&gt;&gt; <span title="Int(7)" class="int">7</span>
      <span title="Unit" class="keyword">if</span> (<a href="#734915" title="(x$1: Int)Boolean">y</a> != <span title="Int(0)" class="int">0</span>) <a href="#734912" title="(x: Long)Unit">writeNatPrefix</a>(<a href="#734915" title="Long">y</a>)
      <a href="#83286" title="(b: Int)Unit">writeByte</a>((<a title="(x$1: Int)Long" id="3182">(</a><a href="#734914" title="(x$1: Int)Long">x</a> &amp; <span title="Int(127)" class="int">0x7f</span>) | <span title="Int(128)" class="int">0x80</span>).<span title="[T0]T0">asInstanceOf</span><span title="Int">[</span><span title="Int">Int</span>])
    }
    <span class="keyword">val</span> <a title="Long" id="734913">y</a> = <a href="#149267" title="(x$1: Int)Long">x</a> &gt;&gt;&gt; <span title="Int(7)" class="int">7</span>
    <span title="Unit" class="keyword">if</span> (<a href="#734913" title="(x$1: Int)Boolean">y</a> != <span title="Int(0)" class="int">0</span>) <a href="#734912" title="(x: Long)Unit">writeNatPrefix</a>(<a href="#734913" title="Long">y</a>)
    <a href="#83286" title="(b: Int)Unit">writeByte</a>((<a href="#149267" title="(x$1: Int)Long">x</a> &amp; <span title="Int(127)" class="int">0x7f</span>).<span title="[T0]T0">asInstanceOf</span><span title="Int">[</span><span title="Int">Int</span>])
  }

  /** Write a natural number &lt;code&gt;x&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.
   *  If number is more than one byte, shift rest of array to make space.
   *
   *  @param pos ...
   *  @param x   ...
   */
  <span class="keyword">def</span> <a title="(pos: Int,x: Int)Unit" id="83289">patchNat</a>(<a title="Int" id="151452">pos</a>: <span title="Int">Int</span>, <a title="Int" id="151453">x</a>: <span title="Int">Int</span>) {
    <span class="keyword">def</span> <a title="(x: Int)Unit" id="734966">patchNatPrefix</a>(<a title="Int" id="734968">x</a>: <span title="Int">Int</span>) {
      <a href="#83286" title="(b: Int)Unit">writeByte</a>(<span title="Int(0)" class="int">0</span>)
      <span title="object Array">Array</span>.<span title="(src: AnyRef,srcPos: Int,dest: AnyRef,destPos: Int,length: Int)Unit">copy</span>(<a href="#83276" title="=&gt; Array[Byte]">bytes</a>, <a href="#151452" title="Int">pos</a>, <a href="#83276" title="=&gt; Array[Byte]">bytes</a>, <a href="#151452" title="(x$1: Int)Int">pos</a>+<span title="Int(1)" class="int">1</span>, <a href="#83282" title="(x$1: Int)Int">writeIndex</a> - (<a href="#151452" title="(x$1: Int)Int">pos</a>+<span title="Int(1)" class="int">1</span>))
      <a href="#83276" title="(i: Int,x: Byte)Unit">bytes</a>(<a href="#151452" title="Int">pos</a>) = (<a title="(x$1: Int)Int" id="2974">(</a><a href="#734968" title="(x$1: Int)Int">x</a> &amp; <span title="Int(127)" class="int">0x7f</span>) | <span title="Int(128)" class="int">0x80</span>).<span title="[T0]T0">asInstanceOf</span><span title="Byte">[</span><span title="Byte">Byte</span>]
      <span class="keyword">val</span> <a title="Int" id="734969">y</a> = <a href="#734968" title="(x$1: Int)Int">x</a> &gt;&gt;&gt; <span title="Int(7)" class="int">7</span>
      <span title="Unit" class="keyword">if</span> (<a href="#734969" title="(x$1: Int)Boolean">y</a> != <span title="Int(0)" class="int">0</span>) <a href="#734966" title="(x: Int)Unit">patchNatPrefix</a>(<a href="#734969" title="Int">y</a>)
    }
    <a href="#83276" title="(i: Int,x: Byte)Unit">bytes</a>(<a href="#151452" title="Int">pos</a>) = (<a href="#151453" title="(x$1: Int)Int">x</a> &amp; <span title="Int(127)" class="int">0x7f</span>).<span title="[T0]T0">asInstanceOf</span><span title="Byte">[</span><span title="Byte">Byte</span>]
    <span class="keyword">val</span> <a title="Int" id="734967">y</a> = <a href="#151453" title="(x$1: Int)Int">x</a> &gt;&gt;&gt; <span title="Int(7)" class="int">7</span>
    <span title="Unit" class="keyword">if</span> (<a href="#734967" title="(x$1: Int)Boolean">y</a> != <span title="Int(0)" class="int">0</span>) <a href="#734966" title="(x: Int)Unit">patchNatPrefix</a>(<a href="#734967" title="Int">y</a>)
  }

  /** Write a long number &lt;code&gt;x&lt;/code&gt; in signed big endian format, base 256.
   *
   *  @param x The long number to be written.
   */
  <span class="keyword">def</span> <a title="(x: Long)Unit" id="83290">writeLong</a>(<a title="Long" id="150393">x</a>: <span title="Long">Long</span>) {
    <span class="keyword">val</span> <a title="Long" id="735092">y</a> = <a href="#150393" title="(x$1: Int)Long">x</a> &gt;&gt; <span title="Int(8)" class="int">8</span>
    <span class="keyword">val</span> <a title="Long" id="735093">z</a> = <a href="#150393" title="(x$1: Int)Long">x</a> &amp; <span title="Int(255)" class="int">0xff</span>
    <span title="Unit" class="keyword">if</span> (<a title="(x$1: Long)Boolean" id="3074">-</a><a href="#735092" title="Long">y</a> != (<a href="#735093" title="(x$1: Int)Long">z</a> &gt;&gt; <span title="Int(7)" class="int">7</span>)) <a href="#83290" title="(x: Long)Unit">writeLong</a>(<a href="#735092" title="Long">y</a>)
    <a href="#83286" title="(b: Int)Unit">writeByte</a>(<a href="#735093" title="Long">z</a>.<span title="[T0]T0">asInstanceOf</span><span title="Int">[</span><span title="Int">Int</span>])
  }

  // -- Basic input routines --------------------------------------------

  /** Peek at the current byte without moving the read index */
  <span class="keyword">def</span> <a title="()Int" id="83291">peekByte</a>(): <span title="Int">Int</span> = <a href="#83276" title="(i: Int)Byte">bytes</a><span title="implicit scala.Predef.byte2int : (x: Byte)Int">(</span><a href="#83279" title="=&gt; Int">readIndex</a>)

  /** Read a byte */
  <span class="keyword">def</span> <a title="()Int" id="83292">readByte</a>(): <span title="Int">Int</span> = {
    <span class="keyword">val</span> <a title="Byte" id="735139">x</a> = <a href="#83276" title="(i: Int)Byte">bytes</a>(<a href="#83279" title="=&gt; Int">readIndex</a>); <a href="#83279" title="(x$1: Int)Unit">readIndex</a> += <span title="Int(1)" class="int">1</span>; <a href="#735139" title="implicit scala.Predef.byte2int : (x: Byte)Int">x</a>
  }

  /** Read a natural number in big endian format, base 128.
   *  All but the last digits have bit 0x80 set.*/
  <span class="keyword">def</span> <a title="()Int" id="83293">readNat</a>(): <span title="Int">Int</span> = <a href="#83294" title="()Long">readLongNat</a>().<span title="[T0]T0">asInstanceOf</span><span title="Int">[</span><span title="Int">Int</span>]

  <span class="keyword">def</span> <a title="()Long" id="83294">readLongNat</a>(): <span title="Long">Long</span> = {
    <span class="keyword">var</span> <a title="Long" id="735194">b</a> = <span title="Long(0L)" class="long">0L</span>
    <span class="keyword">var</span> <a title="Long" id="735195">x</a> = <span title="Long(0L)" class="long">0L</span>
    <a href="#735196" title="Unit" class="keyword">do</a> {
      <a href="#735194" title="Long">b</a> = <a href="#83292" title="()Int">readByte</a><a title="implicit scala.Predef.int2long : (x: Int)Long" id="8137">(</a>)
      <a href="#735195" title="Long">x</a> = <a title="(x$1: Long)Long" id="3200">(</a><a href="#735195" title="(x$1: Int)Long">x</a> &lt;&lt; <span title="Int(7)" class="int">7</span>) + (<a href="#735194" title="(x$1: Int)Long">b</a> &amp; <span title="Int(127)" class="int">0x7f</span>)
    } <span class="keyword">while</span> (<span title="(x$1: Int)Boolean">(</span><a href="#735194" title="(x$1: Int)Long">b</a> &amp; <span title="Int(128)" class="int">0x80</span>) != <span title="Int(0)" class="int">0</span>);
    <a href="#735195" title="Long">x</a>
  }

  /** Read a long number in signed big endian format, base 256. */
  <span class="keyword">def</span> <a title="(len: Int)Long" id="83295">readLong</a>(<a title="Int" id="344626">len</a>: <span title="Int">Int</span>): <span title="Long">Long</span> = {
    <span class="keyword">var</span> <a title="Long" id="735250">x</a> = <span title="Long(0L)" class="long">0L</span>
    <span class="keyword">var</span> <a title="Int" id="735251">i</a> = <span title="Int(0)" class="int">0</span>
    <span title="Unit" class="keyword">while</span> (<a href="#735251" title="(x$1: Int)Boolean">i</a> &lt; <a href="#344626" title="Int">len</a>) <a href="#735253" title="()Unit">{</a>
      <a href="#735250" title="Long">x</a> = <a title="(x$1: Int)Long" id="3172">(</a><a href="#735250" title="(x$1: Int)Long">x</a> &lt;&lt; <span title="Int(8)" class="int">8</span>) + (<a href="#83292" title="()Int">readByte</a><span title="(x$1: Int)Int">(</span>) &amp; <span title="Int(255)" class="int">0xff</span>)
      <a href="#735251" title="Int">i</a> += <span title="Int(1)" class="int">1</span>
    }
    <span class="keyword">val</span> <a title="Int" id="735252">leading</a> = <span title="(x$1: Int)Int" class="int">64</span> - (<a href="#344626" title="(x$1: Int)Int" id="2853">len</a> &lt;&lt; <span title="Int(3)" class="int">3</span>)
    <a href="#735250" title="(x$1: Int)Long">x</a> <span title="(x$1: Int)Long">&lt;&lt;</span> <a href="#735252" title="Int">leading</a> &gt;&gt; <a href="#735252" title="Int">leading</a>
  }

  /** Perform operation &lt;code&gt;op&lt;/code&gt; until the condition
   *  &lt;code&gt;readIndex == end&lt;/code&gt; is satisfied.
   *  Concatenate results into a list.
   *
   *  @param end ...
   *  @param op  ...
   *  @return    ...
   */
  <span class="keyword">def</span> <a title="[T](end: Int,op: () =&gt; T)List[T]" id="83296">until</a>[<a title="&gt;: Nothing &lt;: Any" id="83298">T</a>](<a title="Int" id="344245">end</a>: <span title="Int">Int</span>, <a title="() =&gt; T" id="344246">op</a>: () =&gt; T): <span title="List[T]">List</span>[T] =
    <span title="List[T]" class="keyword">if</span> (<a href="#83279" title="(x$1: Int)Boolean">readIndex</a> == <a href="#344245" title="Int">end</a>) List<span title="object Nil">(</span>) <span class="keyword">else</span> <a href="#344246" title="()T">op</a>() <a href="#735368" title="T">::</a> <a href="#83296" title="(end: Int,op: () =&gt; T)List[T]">until</a><span title="(x: T)List[T]">(</span><a href="#344245" title="Int">end</a>, <a href="#344246" title="() =&gt; T">op</a>);

  /** Perform operation &lt;code&gt;op&lt;/code&gt; the number of
   *  times specified.  Concatenate the results into a list.
   */
  <span class="keyword">def</span> <a title="[T](n: Int,op: () =&gt; T)List[T]" id="83299">times</a>[<a title="&gt;: Nothing &lt;: Any" id="83301">T</a>](<a title="Int" id="503752">n</a>: <span title="Int">Int</span>, <a title="() =&gt; T" id="503753">op</a>: ()=&gt;T): <span title="List[T]">List</span>[T] =
    <span title="List[T]" class="keyword">if</span> (<a href="#503752" title="(x$1: Int)Boolean">n</a> == <span title="Int(0)" class="int">0</span>) List<span title="object Nil">(</span>) <span class="keyword">else</span> <a href="#503753" title="()T">op</a>() <a href="#735400" title="T">::</a> <a href="#83299" title="(n: Int,op: () =&gt; T)List[T]">times</a><span title="(x: T)List[T]">(</span><a href="#503752" title="(x$1: Int)Int">n</a>-<span title="Int(1)" class="int">1</span>, <a href="#503753" title="() =&gt; T">op</a>)

  /** Pickle = majorVersion_Nat minorVersion_Nat nbEntries_Nat {Entry}
   *  Entry  = type_Nat length_Nat [actual entries]
   * 
   *  Assumes that the ..Version_Nat are already consumed.
   *
   *  @return an array mapping entry numbers to locations in
   *  the byte array where the entries start.
   */
  <span class="keyword">def</span> <a title="=&gt; Array[Int]" id="83302">createIndex</a>: <span title="Array[Int]">Array</span>[Int] = {
    <span class="keyword">val</span> <a title="Array[Int]" id="735435">index</a> = <span title="Array[Int]" class="keyword">new</span> <span title="Array[Int]">Array</span>[Int](<a href="#83293" title="()Int">readNat</a>()) // nbEntries_Nat
    <span class="keyword">for</span> (<a title="Int" id="735476">i</a> &lt;- <a title="(end: Int)Range" id="8089" class="int">0</a> <a title="(f: (Int) =&gt; Unit)Unit" id="56267">until</a> <a href="#735435" title="Array[Int]">index</a>.<span title="=&gt; Int">length</span>) {
      <a href="#735435" title="(i: Int,x: Int)Unit">index</a>(<a href="#735476" title="Int">i</a>) = <a href="#83279" title="=&gt; Int">readIndex</a>
      <a href="#83292" title="()Int">readByte</a>() // skip type_Nat
      <a href="#83279" title="(x$1: Int)Unit">readIndex</a> = <a href="#83293" title="()Int">readNat</a><span title="(x$1: Int)Int">(</span>) + <a href="#83279" title="=&gt; Int">readIndex</a> // read length_Nat, jump to next entry
    }
    <a href="#735435" title="Array[Int]">index</a>
  }
}

        </pre>
    </body>
</html>