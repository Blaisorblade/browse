<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/combinatorold/ImplicitConversions.scala</title>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |                                         **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="keyword">package</span> scala.util.parsing.combinatorold

<span class="comment">/** This object contains implicit conversions that come in handy when using the `^^' combinator 
 * {@see Parsers} to construct an AST from the concrete syntax.
 *&lt;p&gt;
 * The reason for this is that the sequential composition combinator (`~') combines its constituents
 * into a ~. When several `~'s are combined, this results in nested `~'s (to the left).
 * The `flatten*' coercions makes it easy to apply an `n'-argument function to a nested ~ of
 * depth (`n-1')&lt;/p&gt;
 *&lt;p&gt;
 * The `headOptionTailToFunList' converts a function that takes a List[A] to a function that 
 * accepts a ~[A, Option[List[A]]] (this happens when, e.g., parsing something of the following
 * shape: p ~ opt(&quot;.&quot; ~ repsep(p, &quot;.&quot;)) -- where `p' is a parser that yields an A)&lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait ImplicitConversions extends java.lang.Object with ScalaObject</span><a id="11781">ImplicitConversions</a></span> { self: Parsers =&gt; 
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[A, B, C]((A, B) =&gt; C)(scala.util.parsing.combinatorold.~[A,B]) =&gt; C</span><a id="105726">flatten2</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105730">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105731">B</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105732">C</a></span>]         (<span class="typed"><span class="type">(A, B) =&gt; C</span><a id="105774">f</a></span>: (A, B) =&gt; C) = 
    (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,B]</span><a id="105777">p</a></span>: <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,B]</span><a href="$tilde.scala.html#11682">~</a></span>[A, B]) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,B]</span><a href="#105777">p</a></span> <span class="typed"><span class="type">C</span><span class="keyword">match</span></span> {<span class="typed"><span class="type">C</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="105778">a</a></span> <a id="1">~</a> <span class="typed"><span class="type">B</span><a id="105779">b</a></span> =&gt; <span class="typed"><span class="type">(A,B)C</span><a href="../../../Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">A</span><a href="#105778">a</a></span>, <span class="typed"><span class="type">B</span><a href="#105779">b</a></span>)}
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[A, B, C, D]((A, B, C) =&gt; D)(scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C]) =&gt; D</span><a id="105733">flatten3</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105738">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105739">B</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105740">C</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105741">D</a></span>]      (<span class="typed"><span class="type">(A, B, C) =&gt; D</span><a id="105780">f</a></span>: (A, B, C) =&gt; D) = 
    (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C]</span><a id="105783">p</a></span>: <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C]</span><a href="$tilde.scala.html#11682">~</a></span>[~[A, B], C]) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C]</span><a href="#105783">p</a></span> <span class="typed"><span class="type">D</span><span class="keyword">match</span></span> {<span class="typed"><span class="type">D</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="105784">a</a></span> <a id="1">~</a> <span class="typed"><span class="type">B</span><a id="105785">b</a></span> <a id="1">~</a> <span class="typed"><span class="type">C</span><a id="105786">c</a></span> =&gt; <span class="typed"><span class="type">(A,B,C)D</span><a href="../../../Function3.scala.html#23948">f</a></span>(<span class="typed"><span class="type">A</span><a href="#105784">a</a></span>, <span class="typed"><span class="type">B</span><a href="#105785">b</a></span>, <span class="typed"><span class="type">C</span><a href="#105786">c</a></span>)}
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[A, B, C, D, E]((A, B, C, D) =&gt; E)(scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D]) =&gt; E</span><a id="105742">flatten4</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105748">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105749">B</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105750">C</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105751">D</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105752">E</a></span>]   (<span class="typed"><span class="type">(A, B, C, D) =&gt; E</span><a id="105787">f</a></span>: (A, B, C, D) =&gt; E) = 
    (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D]</span><a id="105790">p</a></span>: <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D]</span><a href="$tilde.scala.html#11682">~</a></span>[~[~[A, B], C], D]) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D]</span><a href="#105790">p</a></span> <span class="typed"><span class="type">E</span><span class="keyword">match</span></span> {<span class="typed"><span class="type">E</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="105791">a</a></span> <a id="1">~</a> <span class="typed"><span class="type">B</span><a id="105792">b</a></span> <a id="1">~</a> <span class="typed"><span class="type">C</span><a id="105793">c</a></span> <a id="1">~</a> <span class="typed"><span class="type">D</span><a id="105794">d</a></span> =&gt; <span class="typed"><span class="type">(A,B,C,D)E</span><a href="../../../Function4.scala.html#21007">f</a></span>(<span class="typed"><span class="type">A</span><a href="#105791">a</a></span>, <span class="typed"><span class="type">B</span><a href="#105792">b</a></span>, <span class="typed"><span class="type">C</span><a href="#105793">c</a></span>, <span class="typed"><span class="type">D</span><a href="#105794">d</a></span>)}
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[A, B, C, D, E, F]((A, B, C, D, E) =&gt; F)(scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D],E]) =&gt; F</span><a id="105753">flatten5</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105760">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105761">B</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105762">C</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105763">D</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105764">E</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105765">F</a></span>](<span class="typed"><span class="type">(A, B, C, D, E) =&gt; F</span><a id="105795">f</a></span>: (A, B, C, D, E) =&gt; F) = 
    (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D],E]</span><a id="105798">p</a></span>: <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D],E]</span><a href="$tilde.scala.html#11682">~</a></span>[~[~[~[A, B], C], D], E]) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[scala.util.parsing.combinatorold.~[A,B],C],D],E]</span><a href="#105798">p</a></span> <span class="typed"><span class="type">F</span><span class="keyword">match</span></span> {<span class="typed"><span class="type">F</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="105799">a</a></span> <a id="1">~</a> <span class="typed"><span class="type">B</span><a id="105800">b</a></span> <a id="1">~</a> <span class="typed"><span class="type">C</span><a id="105801">c</a></span> <a id="1">~</a> <span class="typed"><span class="type">D</span><a id="105802">d</a></span> <a id="1">~</a> <span class="typed"><span class="type">E</span><a id="105803">e</a></span>=&gt; <span class="typed"><span class="type">(A,B,C,D,E)F</span><a href="../../../Function5.scala.html#68065">f</a></span>(<span class="typed"><span class="type">A</span><a href="#105799">a</a></span>, <span class="typed"><span class="type">B</span><a href="#105800">b</a></span>, <span class="typed"><span class="type">C</span><a href="#105801">c</a></span>, <span class="typed"><span class="type">D</span><a href="#105802">d</a></span>, <span class="typed"><span class="type">E</span><a href="#105803">e</a></span>)}
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[A, T]((List[A]) =&gt; T)(scala.util.parsing.combinatorold.~[A,Option[List[A]]]) =&gt; T</span><a id="105766">headOptionTailToFunList</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105769">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="105770">T</a></span>] (<span class="typed"><span class="type">(List[A]) =&gt; T</span><a id="105804">f</a></span>: List[A] =&gt; T)= 
    (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,Option[List[A]]]</span><a id="105807">p</a></span>: <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,Option[List[A]]]</span><a href="$tilde.scala.html#11682">~</a></span>[A, Option[List[A]]]) =&gt; <span class="typed"><span class="type">(List[A])T</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,Option[List[A]]]</span><a href="#105807">p</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="$tilde.scala.html#40203">_1</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="../../../List.scala.html#20872">::</a></span> (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[A,Option[List[A]]]</span><a href="#105807">p</a></span>.<span class="typed"><span class="type">=&gt; Option[List[A]]</span><a href="$tilde.scala.html#40205">_2</a></span> <span class="typed"><span class="type">List[A]</span><span class="keyword">match</span></span> { <span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <a id="1">Some</a>(<span class="typed"><span class="type">List[A]</span><a id="105809">xs</a></span>) =&gt; <span class="typed"><span class="type">List[A]</span><a href="#105809">xs</a></span> <span class="typed"><span class="type">Nil.type</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object None</span><a href="../../../Option.scala.html#534">None</a></span> =&gt; <span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">Nil</a></span>}))
}

        </pre>
    </body>
</html>