<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/combinatorold/lexical/StdLexical.scala</title>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: StdLexical.scala 16893 2009-01-13 13:09:22Z cunei $</span>


<span class="keyword">package</span> scala.util.parsing.combinatorold.lexical

<span class="keyword">import</span> scala.util.parsing.syntax._
<span class="keyword">import</span> scala.util.parsing.input.CharArrayReader.EofCh
<span class="keyword">import</span> collection.mutable.HashSet

<span class="comment">/** &lt;p&gt;
 *    This component provides a standard lexical parser for a simple, Scala-like language. 
 *    It parses keywords and identifiers, numeric literals (integers), strings, and delimiters. 
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    To distinguish between identifiers and keywords, it uses a set of reserved identifiers: 
 *    every string contained in `reserved' is returned as a keyword token.
 *    (Note that &quot;=&gt;&quot; is hard-coded as a keyword.) 
 *    Additionally, the kinds of delimiters can be specified by the `delimiters' set.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Usually this component is used to break character-based input into bigger tokens,
 *    which are then passed to a token-parser {@see TokenParsers}.
 *  &lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */</span>
<span class="keyword">class</span> <span class="typed"><span class="type">class StdLexical extends scala.util.parsing.combinatorold.lexical.Lexical with scala.util.parsing.syntax.StdTokens with ScalaObject</span><a id="12102">StdLexical</a></span> <span class="keyword">extends</span> <span class="typed"><span class="type">scala.util.parsing.combinatorold.lexical.Lexical</span><a href="Lexical.scala.html#12129">Lexical</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">scala.util.parsing.syntax.StdTokens</span><a href="../../syntax/StdTokens.scala.html#14182">StdTokens</a></span> {
  
  <span class="comment">// override this parser to change the characters allowed at the beginning of an identifier</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Char]</span><a id="92212">identBegin</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Char] = (<span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'_'</a></span> <span class="typed"><span class="type">(Char)StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#49135">^^</a></span> <span class="typed"><span class="type">Char('_')</span><span class="char">'_'</span></span>) <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Char])StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49101">letter</a></span>

  <span class="comment">// override this parser to change the characters allowed in an identifier (i.e., after the first character)</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Char]</span><a id="92213">identCont</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Char] = (<span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'_'</a></span> <span class="typed"><span class="type">(Char)StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#49135">^^</a></span> <span class="typed"><span class="type">Char('_')</span><span class="char">'_'</span></span>) <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Char])StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49101">letter</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Char])StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49102">digit</a></span>
       
  <span class="comment">// see `token' in `Scanners'</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a id="92214">token</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Token] = 
    ( <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Char]</span><a href="#92212">identBegin</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[Char]])StdLexical.this.Parser[scala.util.parsing.combinatorold.~[Char,List[Char]]]</span><a href="../Parsers.scala.html#29588">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Char])StdLexical.this.Parser[List[Char]]</span><a href="../Parsers.scala.html#29510">rep</a></span>( <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Char]</span><a href="#92213">identCont</a></span> )                     <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[Char,List[Char]]) =&gt; Product with StdLexical.this.Token)StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29606">^^</a></span> <span class="typed"><span class="type">((String) =&gt; Product with StdLexical.this.Token)(scala.util.parsing.combinatorold.~[Char,List[Char]])Product with StdLexical.this.Token</span><a href="#92229">lift2</a></span>(<span class="typed"><span class="type">(String)Product with StdLexical.this.Token</span><a href="#92221">processIdent</a></span>)
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49102">digit</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[scala.util.parsing.combinatorold.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]]</span><a href="../Parsers.scala.html#29588">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#29510">rep</a></span>( <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49102">digit</a></span> )                              <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]) =&gt; StdLexical.this.NumericLit)StdLexical.this.Parser[StdLexical.this.NumericLit]</span><a href="../Parsers.scala.html#29606">^^</a></span> <span class="typed"><span class="type">((String) =&gt; StdLexical.this.NumericLit)(scala.util.parsing.combinatorold.~[Char,List[Char]])StdLexical.this.NumericLit</span><a href="#92229">lift2</a></span>(<span class="typed"><span class="type">object StdLexical.this.NumericLit</span><a href="../../syntax/StdTokens.scala.html#18162">NumericLit</a></span>)
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'\''</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#29510">rep</a></span>( <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49103">chrExcept</a></span>(<span class="typed"><span class="type">Char(''')</span><span class="char">'\''</span></span>, <span class="typed"><span class="type">Char('\012')</span><span class="char">'\n'</span></span>, <span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>) ) <span class="typed"><span class="type">(=&gt; Char)(implicit (Char) =&gt; StdLexical.this.UnitParser)StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#29591">~</a></span> <span class="typed"><span class="type">Char(''')</span><span class="char">'\''</span></span> <span class="typed"><span class="type">((List[StdLexical.this.Elem]) =&gt; StdLexical.this.StringLit)StdLexical.this.Parser[StdLexical.this.StringLit]</span><a href="../Parsers.scala.html#29606">^^</a></span> <span class="typed"><span class="type">((String) =&gt; StdLexical.this.StringLit)(List[Char])StdLexical.this.StringLit</span><a href="#92226">lift</a></span>(<span class="typed"><span class="type">object StdLexical.this.StringLit</span><a href="../../syntax/StdTokens.scala.html#18165">StringLit</a></span>)
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'\&quot;'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#29510">rep</a></span>( <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49103">chrExcept</a></span>(<span class="typed"><span class="type">Char('&quot;')</span><span class="char">'\&quot;'</span></span>, <span class="typed"><span class="type">Char('\012')</span><span class="char">'\n'</span></span>, <span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>) ) <span class="typed"><span class="type">(=&gt; Char)(implicit (Char) =&gt; StdLexical.this.UnitParser)StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#29591">~</a></span> <span class="typed"><span class="type">Char('&quot;')</span><span class="char">'\&quot;'</span></span> <span class="typed"><span class="type">((List[StdLexical.this.Elem]) =&gt; StdLexical.this.StringLit)StdLexical.this.Parser[StdLexical.this.StringLit]</span><a href="../Parsers.scala.html#29606">^^</a></span> <span class="typed"><span class="type">((String) =&gt; StdLexical.this.StringLit)(List[Char])StdLexical.this.StringLit</span><a href="#92226">lift</a></span>(<span class="typed"><span class="type">object StdLexical.this.StringLit</span><a href="../../syntax/StdTokens.scala.html#18165">StringLit</a></span>)
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488">EofCh</a></span>                                             <span class="typed"><span class="type">(object StdLexical.this.EOF)StdLexical.this.Parser[object StdLexical.this.EOF]</span><a href="../Parsers.scala.html#49135">^^</a></span> <span class="typed"><span class="type">object StdLexical.this.EOF</span><a href="../../syntax/Tokens.scala.html#18154">EOF</a></span>
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'\''</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Nothing])StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]{def apply(StdLexical.this.Input): StdLexical.this.Failure}</span><a href="../Parsers.scala.html#29495">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;unclosed string literal&quot;)</span><span class="string">&quot;unclosed string literal&quot;</span></span>)
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'\&quot;'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Nothing])StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]{def apply(StdLexical.this.Input): StdLexical.this.Failure}</span><a href="../Parsers.scala.html#29495">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;unclosed string literal&quot;)</span><span class="string">&quot;unclosed string literal&quot;</span></span>)
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#92225">delim</a></span>                                             
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]{def apply(StdLexical.this.Input): StdLexical.this.Failure}</span><a href="../Parsers.scala.html#29495">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;illegal character&quot;)</span><span class="string">&quot;illegal character&quot;</span></span>)
    )

  <span class="comment">// see `whitespace in `Scanners'</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a id="92215">whitespace</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Any] = <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[List[Any]]</span><a href="../Parsers.scala.html#29510">rep</a></span>(
      <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49104">whitespaceChar</a></span>
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; Char)(implicit (Char) =&gt; StdLexical.this.UnitParser)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#49120">~</a></span> <span class="typed"><span class="type">Char('*')</span><span class="char">'*'</span></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a href="#92216">comment</a></span>
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; Char)(implicit (Char) =&gt; StdLexical.this.UnitParser)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#49120">~</a></span> <span class="typed"><span class="type">Char('/')</span><span class="char">'/'</span></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#29510">rep</a></span>( <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49103">chrExcept</a></span>(<span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>, <span class="typed"><span class="type">Char('\012')</span><span class="char">'\n'</span></span>) )
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; Char)(implicit (Char) =&gt; StdLexical.this.UnitParser)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#49120">~</a></span> <span class="typed"><span class="type">Char('*')</span><span class="char">'*'</span></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Nothing])StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#49117">~</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]{def apply(StdLexical.this.Input): StdLexical.this.Failure}</span><a href="../Parsers.scala.html#29495">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;unclosed comment&quot;)</span><span class="string">&quot;unclosed comment&quot;</span></span>)
    )

  <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a id="92216">comment</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Any] = (
      <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29488" class="char">'*'</a></span> <span class="typed"><span class="type">(=&gt; Char)(implicit (Char) =&gt; StdLexical.this.UnitParser)StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#49120">~</a></span> <span class="typed"><span class="type">Char('/')</span><span class="char">'/'</span></span>  <span class="typed"><span class="type">(Char)StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#49135">^^</a></span> <span class="typed"><span class="type">Char(' ')</span><span class="char">' '</span></span> 
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#49103">chrExcept</a></span>(<span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>) <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[scala.util.parsing.combinatorold.~[StdLexical.this.Elem,Any]]</span><a href="../Parsers.scala.html#29588">~</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a href="#92216">comment</a></span>
    )

  <span class="comment">/** The set of reserved identifiers: these will be returned as `Keyword's */</span>
  <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span id="92218"><a id="92217">reserved</a></span></span> = <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><a href="../../../../collection/mutable/HashSet.scala.html#11140">HashSet</a></span>[String]

  <span class="comment">/** The set of delimiters (ordering does not matter) */</span>
  <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span id="92220"><a id="92219">delimiters</a></span></span> = <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><a href="../../../../collection/mutable/HashSet.scala.html#11140">HashSet</a></span>[String]

  <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">(String)Product with StdLexical.this.Token</span><a id="92221">processIdent</a></span>(<span class="typed"><span class="type">String</span><a id="92305">name</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>) = 
    <span class="typed"><span class="type">&lt;refinement&gt; extends Product with StdLexical.this.Token</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; scala.collection.mutable.HashSet[String]</span><a href="#92217">reserved</a></span> <span class="typed"><span class="type">(String)Boolean</span><a href="../../../../collection/mutable/HashSet.scala.html#38147">contains</a></span> <span class="typed"><span class="type">String</span><a href="#92305">name</a></span>) <span class="typed"><span class="type">(String)StdLexical.this.Keyword</span><a href="../../syntax/StdTokens.scala.html#66413">Keyword</a></span>(<span class="typed"><span class="type">String</span><a href="#92305">name</a></span>) <span class="keyword">else</span> <span class="typed"><span class="type">(String)StdLexical.this.Identifier</span><a href="../../syntax/StdTokens.scala.html#66422">Identifier</a></span>(<span class="typed"><span class="type">String</span><a href="#92305">name</a></span>)

  <span class="keyword">private</span> <span class="keyword">var</span> <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><span id="92224"><span id="92222"><span id="92223"><a id="92233">_delim</a></span></span></span></span>: <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Token] = <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>
  <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a id="92225">delim</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Token] = {
    <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#92222">_delim</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5792">eq</a></span> <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>) { <span class="comment">// construct parser for delimiters by |'ing together the parsers for the individual delimiters, </span>
    <span class="comment">// starting with the longest one (hence the sort + reverse) -- otherwise a delimiter D will never be matched if </span>
    <span class="comment">// there is another delimiter that is a prefix of D   </span>
      <span class="keyword">def</span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[StdLexical.this.Token]</span><a id="92814">parseDelim</a></span>(<span class="typed"><span class="type">String</span><a id="92816">s</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Token] = <span class="typed"><span class="type">(List[Char])(implicit (List[Char]) =&gt; List[StdLexical.this.Elem])StdLexical.this.UnitParser</span><a href="../Parsers.scala.html#29489">accept</a></span>(<span class="typed"><span class="type">implicit scala.Predef.stringWrapper : (String)scala.runtime.RichString</span><a href="../../../../Predef.scala.html#13518">s</a></span>.<span class="typed"><span class="type">=&gt; List[Char]</span><a href="../../../../Iterable.scala.html#17360">toList</a></span>) <span class="typed"><span class="type">(StdLexical.this.Keyword)StdLexical.this.Parser[StdLexical.this.Keyword]</span><a href="../Parsers.scala.html#49135">^^</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Keyword</span><a href="../../syntax/StdTokens.scala.html#66413">Keyword</a></span>(<span class="typed"><span class="type">String</span><a href="#92816">s</a></span>)
      
      <span class="keyword">val</span> <span class="typed"><span class="type">Array[String]</span><a id="92815">d</a></span> = <span class="typed"><span class="type">Array[String]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Array[String]</span><a href="../../../../Array.scala.html#1070">Array</a></span>[String](<span class="typed"><span class="type">=&gt; scala.collection.mutable.HashSet[String]</span><a href="#92219">delimiters</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="../../../../collection/mutable/FlatHashTable.scala.html#38167">size</a></span>)
      <span class="typed"><span class="type">=&gt; scala.collection.mutable.HashSet[String]</span><a href="#92219">delimiters</a></span>.<span class="typed"><span class="type">(Array[String],Int)Unit</span><a href="../../../../Iterable.scala.html#17369">copyToArray</a></span>(<span class="typed"><span class="type">Array[String]</span><a href="#92815">d</a></span>,<span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)
      scala.util.<span class="typed"><span class="type">object scala.util.Sorting</span><a href="../../../Sorting.scala.html#6703">Sorting</a></span>.<span class="typed"><span class="type">(Array[String])(implicit (String) =&gt; Ordered[String])Unit</span><a href="../../../Sorting.scala.html#66795">quickSort</a></span>(<span class="typed"><span class="type">Array[String]</span><a href="#92815">d</a></span>) 
      <span class="typed"><span class="type">(StdLexical.this.Parser[StdLexical.this.Token])Unit</span><a href="#92223">_delim</a></span> = <span class="typed"><span class="type">Array[String]</span><a href="#92815">d</a></span>.<span class="typed"><span class="type">=&gt; List[String]</span><a href="../../../../Iterable.scala.html#17360">toList</a></span>.<span class="typed"><span class="type">=&gt; List[String]</span><a href="../../../../List.scala.html#20934">reverse</a></span>.<span class="typed"><span class="type">((String) =&gt; StdLexical.this.Parser[StdLexical.this.Token])List[StdLexical.this.Parser[StdLexical.this.Token]]</span><a href="../../../../List.scala.html#20904">map</a></span>(<span class="typed"><span class="type">(String)StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#92814">parseDelim</a></span>).<span class="typed"><span class="type">((StdLexical.this.Parser[StdLexical.this.Token], StdLexical.this.Parser[StdLexical.this.Token]) =&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../../../../List.scala.html#20928">reduceRight</a></span>[<span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29467">Parser</a></span>[Token]](<span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#92853">_</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#29600">|</a></span> <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#92854">_</a></span>) <span class="comment">// no offence :-)      </span>
    }
    
    <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#92222">_delim</a></span>
  }

  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T]((String) =&gt; T)(List[Char])T</span><a id="92226">lift</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="92228">T</a></span>](<span class="typed"><span class="type">(String) =&gt; T</span><a id="92417">f</a></span>: String =&gt; T)(<span class="typed"><span class="type">List[Char]</span><a id="92418">xs</a></span>: <span class="typed"><span class="type">List[Char]</span><a href="../../../../List.scala.html#524">List</a></span>[Char]): <span class="typed"><span class="type">T</span><a href="#92228">T</a></span> = <span class="typed"><span class="type">(String)T</span><a href="../../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">List[Char]</span><a href="#92418">xs</a></span>.<span class="typed"><span class="type">(String,String,String)String</span><a href="../../../../Iterable.scala.html#17363">mkString</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>, <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>, <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>))

  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T]((String) =&gt; T)(scala.util.parsing.combinatorold.~[Char,List[Char]])T</span><a id="92229">lift2</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="92231">T</a></span>](<span class="typed"><span class="type">(String) =&gt; T</span><a id="92302">f</a></span>: String =&gt; T)(<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[Char,List[Char]]</span><a id="92303">p</a></span>: <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[Char,List[Char]]</span><a href="../$tilde.scala.html#11682">~</a></span>[Char, List[Char]]): <span class="typed"><span class="type">T</span><a href="#92231">T</a></span> = <span class="typed"><span class="type">((String) =&gt; T)(List[Char])T</span><a href="#92226">lift</a></span>(<span class="typed"><span class="type">(String) =&gt; T</span><a href="#92302">f</a></span>)(<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[Char,List[Char]]</span><a href="#92303">p</a></span>.<span class="typed"><span class="type">=&gt; Char</span><a href="../$tilde.scala.html#40203">_1</a></span> <span class="typed"><span class="type">(Char)List[Char]</span><a href="../../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[Char,List[Char]]</span><a href="#92303">p</a></span>.<span class="typed"><span class="type">=&gt; List[Char]</span><a href="../$tilde.scala.html#40205">_2</a></span>)
}

        </pre>
    </body>
</html>