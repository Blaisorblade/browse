<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/combinatorold/Parsers.scala</title>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: Parsers.scala 16893 2009-01-13 13:09:22Z cunei $</span>

<span class="keyword">package</span> scala.util.parsing.combinatorold

<span class="keyword">import</span> scala.util.parsing.input._
<span class="keyword">import</span> scala.collection.mutable.{Map=&gt;MutableMap}

<span class="comment">// TODO: better error handling (labelling like parsec's &lt;?&gt;)</span>
<span class="comment">// TODO: memoisation (like packrat parsers?) </span>

<span class="comment">/** &lt;p&gt;
 *    &lt;code&gt;Parsers&lt;/code&gt; is a component that &lt;i&gt;provides&lt;/i&gt; generic
 *    parser combinators.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    It &lt;i&gt;requires&lt;/i&gt; the type of the elements these parsers should parse 
 *    (each parser is polymorphic in the type of result it produces).
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    There are two aspects to the result of a parser: (1) success or failure,
 *    and (2) the result. A &lt;code&gt;Parser[T]&lt;/code&gt; provides both kinds of
 *    information, but a &lt;code&gt;UnitParser&lt;/code&gt; only signals success/failure.
 *    When composing a `UnitParser' with a normal &lt;code&gt;Parser&lt;/code&gt;, the
 *    &lt;code&gt;UnitParser&lt;/code&gt; only contributes to whether the combined parser
 *    is successful (i.e., its result is discarded).
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    The term ``parser combinator'' refers to the fact that these parsers
 *    are constructed from primitive parsers and composition operators, such
 *    as sequencing, alternation, optionality, repetition, lifting, and so on.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    A ``primitive parser'' is a parser that accepts or rejects a single
 *    piece of input, based on a certain criterion, such as whether the
 *    input...
 *  &lt;/p&gt;&lt;ul&gt;
 *    &lt;li&gt; is equal to some given object, &lt;/li&gt;
 *    &lt;li&gt; satisfies a certain predicate, &lt;/li&gt;
 *    &lt;li&gt; is in the domain of a given partial function,.... &lt;/li&gt;
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *    Even more primitive parsers always produce the same result, irrespective
 *    of the input.
 *  &lt;/p&gt;
 *
 * @requires Elem the type of elements the provided parsers consume 
 *              (When consuming invidual characters, a parser is typically called a ``scanner'', 
 *               which produces ``tokens'' that are consumed by what is normally called a ``parser''.
 *               Nonetheless, the same principles apply, regardless of the input type.)&lt;/p&gt;
 *&lt;p&gt;
 * @provides Input = Reader[Elem] 
 *              The type of input the parsers in this component expect.&lt;/p&gt;
 *&lt;p&gt;
 * @provides Parser[+T] extends (Input =&gt; ParseResult[T]) 
 *              Essentially, a `Parser[T]' is a function from `Input' to `ParseResult[T]'.&lt;/p&gt;
 *&lt;p&gt;
 * @provides ParseResult[+T] is like an `Option[T]', in the sense that it is either
 *              `Success[T]', which consists of some result (:T) (and the rest of the input) or
 *              `Failure[T]', which provides an error message (and the rest of the input).&lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait Parsers extends java.lang.Object with ScalaObject</span><a id="11859">Parsers</a></span> {
  <span class="comment">/** the type of input elements */</span>
  <span class="keyword">type</span> <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29452">Elem</a></span>

  <span class="comment">/** The parser input is an abstract reader of input elements */</span>
  <span class="keyword">type</span> <span class="typed"><span class="type">scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a id="29453">Input</a></span> = <span class="typed"><span class="type">scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#10014">Reader</a></span>[Elem]

  <span class="comment">/** A base class for parser results. 
   *  A result is either successful or not (failure may be fatal, i.e.,
   *  an Error, or not, i.e., a Failure)
   *  On success, provides a result of type &lt;code&gt;T&lt;/code&gt;. 
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class ParseResult[+T] extends java.lang.Object with ScalaObject</span><a id="29454">ParseResult</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29455">T</a></span>] {
    <span class="comment">/** Functional composition of ParseResults
     * 
     * @param `f' the function to be lifted over this result
     * @return `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.ParseResult[U]</span><a id="29661">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29663">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="49148">f</a></span>: T =&gt; U): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#29454">ParseResult</a></span>[U]
    
    <span class="comment">/** Partial functional composition of ParseResults
     * 
     * @param `f' the partial function to be lifted over this result
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable (it is called when this is the case)
     * @return &lt;i&gt;if `f' f is defined at the result in this `ParseResult',&lt;/i&gt;
     *         `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'.
     *         If `f' is not defined, `Failure'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a id="29664">mapPartial</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29666">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="71533">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U], <span class="typed"><span class="type">(T) =&gt; String</span><a id="71534">error</a></span>: T =&gt; String): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#29454">ParseResult</a></span>[U]   
    
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="29667">isEmpty</a></span> = <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">=&gt; Boolean</span><a href="#29673">successful</a></span>
    
    <span class="comment">/** Returns the embedded result */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; T</span><a id="29668">get</a></span>: <span class="typed"><span class="type">T</span><a href="#29455">T</a></span>
    
    <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: T](=&gt; B)B</span><a id="29669">getOrElse</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="29671">B</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; B</span><a id="71538">default</a></span>: =&gt; B): <span class="typed"><span class="type">B</span><a href="#29671">B</a></span> = 
        <span class="typed"><span class="type">B</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="#29667">isEmpty</a></span>) <span class="typed"><span class="type">=&gt; B</span><a href="#71538">default</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">ParseResult.this.type</span><a href="#29454" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; T</span><a href="#29668">get</a></span>
    
    <span class="keyword">val</span> <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a id="29672">next</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>
    
    <span class="keyword">val</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="29673">successful</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span>
  }

  <span class="comment">/** The success case of ParseResult: contains the result and the remaining input.
   *
   *  @param result The parser's output 
   *  @param next   The parser's remaining input
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Success[+T] extends Parsers.this.ParseResult[T] with ScalaObject with Product</span><span id="71555"><span id="29456"><span id="2748"><span id="2749"><span id="71558"><span id="29691"><span id="29657"><span id="5792"><span id="71557"><span id="71551"><span id="71552"><span id="3494"><span id="19891"><span id="3507"><span id="71554"><span id="71559"><span id="29694"><span id="71553"><span id="3499"><span id="29458"><span id="3498"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="71560">Success</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><span id="29457"><span id="29693"><a id="29659">T</a></span></span></span>](<span class="typed"><span class="type">T</span><span id="29677"><span id="29676"><span id="29699"><a id="49171">result</a></span></span></span></span>: <span class="typed"><span class="type">T</span><a href="#29457">T</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="29679"><span id="29678"><span id="29700"><a id="49172">next</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#29454">ParseResult</a></span>[T] {
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.Success[U]</span><a id="29681">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29683">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="71542">f</a></span>: T =&gt; U) = <span class="typed"><span class="type">(U,Parsers.this.Input)Parsers.this.Success[U]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">(T)U</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#29676">result</a></span>), <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#29678">next</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a id="29684">mapPartial</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29686">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="71545">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U], <span class="typed"><span class="type">(T) =&gt; String</span><a id="71546">error</a></span>: T =&gt; String): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#29454">ParseResult</a></span>[U] 
       = <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">PartialFunction[T,U]</span><a href="#71545">f</a></span>.<span class="typed"><span class="type">(T)Boolean</span><a href="../../../PartialFunction.scala.html#17289">isDefinedAt</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#29676">result</a></span>)) <span class="typed"><span class="type">(U,Parsers.this.Input)Parsers.this.Success[U]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">(T)U</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#29676">result</a></span>), <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#29678">next</a></span>) 
         <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">(T)String</span><a href="../../../Function1.scala.html#17300">error</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#29676">result</a></span>), <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#29678">next</a></span>)

    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; T</span><a id="29687">get</a></span>: <span class="typed"><span class="type">T</span><a href="#29457">T</a></span> = <span class="typed"><span class="type">=&gt; T</span><a href="#29676">result</a></span>
    
    <span class="comment">/** The toString method of a Success */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="29688">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#29678">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;] parsed: &quot;)</span><span class="string">&quot;] parsed: &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; T</span><a href="#29676">result</a></span>
    
    <span class="keyword">val</span> <span class="typed"><span class="type">Boolean</span><span id="29690"><a id="29689">successful</a></span></span> = <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
  }

  <span class="comment">/** A common super-class for unsuccessful parse results
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class NoSuccess extends Parsers.this.ParseResult[Nothing] with ScalaObject</span><a id="29460">NoSuccess</a></span>(<span class="keyword">val</span> <span class="typed"><span class="type">String</span><span id="29715"><span id="29714"><a id="71565">msg</a></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="29717"><span id="29716"><a id="71566">next</a></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.ParseResult[Nothing]</span><a href="#29454">ParseResult</a></span>[Nothing] { <span class="comment">// when we don't care about the difference between Failure and Error</span>
    <span class="keyword">val</span> <span class="typed"><span class="type">Boolean</span><span id="29720"><a id="29719">successful</a></span></span> = <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>

    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((Nothing) =&gt; U)Parsers.this.NoSuccess</span><a id="29721">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29723">U</a></span>](<span class="typed"><span class="type">(Nothing) =&gt; U</span><a id="71567">f</a></span>: Nothing =&gt; U) = <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460" class="keyword">this</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[Nothing,U],(Nothing) =&gt; String)Parsers.this.ParseResult[U]</span><a id="29724">mapPartial</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29726">U</a></span>](<span class="typed"><span class="type">PartialFunction[Nothing,U]</span><a id="71569">f</a></span>: <span class="typed"><span class="type">PartialFunction[Nothing,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[Nothing, U], <span class="typed"><span class="type">(Nothing) =&gt; String</span><a id="71570">error</a></span>: Nothing =&gt; String): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#29454">ParseResult</a></span>[U] = <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460" class="keyword">this</a></span>

    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Nothing</span><a id="29727">get</a></span>: <span class="typed"><span class="type">Nothing</span><a id="2165">Nothing</a></span> = <span class="typed"><span class="type">(String)Nothing</span><a href="../../../Predef.scala.html#13358">error</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;No result when parsing failed&quot;)</span><span class="string">&quot;No result when parsing failed&quot;</span></span>)
  }
  
  <span class="comment">/** The failure case of ParseResult: contains an error-message and the remaining input.
   * Parsing will back-track when a failure occurs.
   *
   *  @param msg    An error message string describing the failure.
   *  @param next   The parser's unconsumed input at the point where the failure occurred.
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Failure extends Parsers.this.NoSuccess with ScalaObject with Product</span><span id="71581"><span id="56003"><span id="71580"><span id="2748"><span id="2749"><span id="49175"><span id="49184"><span id="71578"><span id="5792"><span id="29462"><span id="71577"><span id="19891"><span id="71586"><span id="3507"><span id="71584"><span id="71587"><span id="29461"><span id="71579"><span id="3499"><span id="71585"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="3498">Failure</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>(<span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">String</span><span id="49179"><span id="49178"><span id="56008"><a href="#29714" id="49185">msg</a></span></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="49181"><span id="49180"><span id="56009"><a href="#29716" id="49186">next</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span>(<span class="typed"><span class="type">String</span><a href="#56008">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#56009">next</a></span>) {
    <span class="comment">/** The toString method of a Failure yields an error message */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="49183">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#49180">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;] failure: &quot;)</span><span class="string">&quot;] failure: &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; String</span><a href="#49178">msg</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;\012\012&quot;)</span><span class="string">&quot;\n\n&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#49180">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>.<span class="typed"><span class="type">=&gt; java.lang.String</span><a href="../input/Position.scala.html#23453">longString</a></span>
  }
  
  <span class="comment">/** The fatal failure case of ParseResult: contains an error-message and the remaining input.
   * No back-tracking is done when a parser returns an `Error' 
   *
   *  @param msg    An error message string describing the error.
   *  @param next   The parser's unconsumed input at the point where the error occurred.
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Error extends Parsers.this.NoSuccess with ScalaObject with Product</span><span id="71604"><span id="71609"><span id="71619"><span id="29464"><span id="2748"><span id="71615"><span id="2749"><span id="71621"><span id="71606"><span id="5792"><span id="29465"><span id="71622"><span id="19891"><span id="71608"><span id="71616"><span id="3507"><span id="71620"><span id="71605"><span id="3499"><span id="71610"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="3498">Error</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>(<span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">String</span><span id="71592"><span id="71591"><span id="71600"><a href="#29714" id="71716">msg</a></span></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="71594"><span id="71593"><span id="71601"><a href="#29716" id="71717">next</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span>(<span class="typed"><span class="type">String</span><a href="#71600">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71601">next</a></span>) {
    <span class="comment">/** The toString method of an Error yields an error message */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71596">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#71593">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;] error: &quot;)</span><span class="string">&quot;] error: &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; String</span><a href="#71591">msg</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;\012\012&quot;)</span><span class="string">&quot;\n\n&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#71593">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>.<span class="typed"><span class="type">=&gt; java.lang.String</span><a href="../input/Position.scala.html#23453">longString</a></span>
  }
  
  <span class="comment">/** The root class of parsers. 
   *  Parsers are functions from the Input type to ParseResult 
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Parser[+T] extends java.lang.Object with (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T] with ScalaObject</span><a id="29467">Parser</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29468">T</a></span>] <span class="keyword">extends</span> (Input =&gt; ParseResult[T]) {
    <span class="comment">/** An unspecified method that defines the behaviour of this parser.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="29587">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="29652">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#29454">ParseResult</a></span>[T]

                                      
    <span class="comment">// the operator formerly known as +++, ++, &amp;, but now, behold the venerable ~</span>
    <span class="comment">// it's short, light (looks like whitespace), has few overloaded meaning (thanks to the recent change from ~ to unary_~)</span>
    <span class="comment">// and we love it!</span>
                                      
    <span class="comment">/** A parser combinator for sequential composition 
     *
     * &lt;p&gt; `p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a id="29588">~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29590">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="71625">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29467">Parser</a></span>[~[T, U]] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a id="71626" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29467">Parser</a></span>[~[T, U]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.combinatorold.~[T,U]]</span><a id="71628">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71631">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((T, U) =&gt; scala.util.parsing.combinatorold.~[T,U])(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#71625">q</a></span>)((<span class="typed"><span class="type">T</span><a id="71641">x</a></span>, <span class="typed"><span class="type">U</span><a id="71642">y</a></span>) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[T,U]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[T,U]</span><a href="$tilde.scala.html#11682">~</a></span>(<span class="typed"><span class="type">T</span><a href="#71641">x</a></span>,<span class="typed"><span class="type">U</span><a href="#71642">y</a></span>))(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71631">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71629">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span>
    }
   
     <span class="comment">/* not really useful: V cannot be inferred because Parser is covariant in first type parameter (V is always trivially Nothing)
    def ~~ [U, V](q: =&gt; Parser[U])(implicit combine: (T, U) =&gt; V): Parser[V] = new Parser[V] {
      def apply(in: Input) = seq(Parser.this, q)((x, y) =&gt; combine(x,y))(in)
    }  */</span>   
     
    <span class="comment">/** A parser combinator for sequential composition with a unit-parser 
     *
     * &lt;p&gt; `p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     *
     * @param q a parser (convertible to a UnitParser) that will be executed after `p' (this parser)
     *          succeeds
     * @return a `Parser' that -- on success -- returns the result of `p'.
     *         The resulting parser fails if either `p' or `q' fails.
     */</span> 
    <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[T]</span><span id="29591"><a id="71648">~</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29593">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71647">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="71649" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="71651">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71654">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])((T, Unit) =&gt; T)(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(Q)Parsers.this.UnitParser</span><a href="../../../Function1.scala.html#17300">q</a></span>)((<span class="typed"><span class="type">T</span><a id="71662">x</a></span>, <span class="typed"><span class="type">Unit</span><a id="71663">y</a></span>) =&gt; <span class="typed"><span class="type">T</span><a href="#71662">x</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71654">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71652">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span>
    }
    
    <span class="comment">/** A parser combinator for non-back-tracking sequential composition 
     *
     *&lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails, this failure is fatal.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a id="29594">~!</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29596">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="71666">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29467">Parser</a></span>[~[T, U]] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]] with Parsers.this.OnceParser[scala.util.parsing.combinatorold.~[T,U]]</span><a id="71667" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29467">Parser</a></span>[~[T, U]] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29571">OnceParser</a></span>[~[T, U]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.combinatorold.~[T,U]]</span><a id="71669">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71680">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((T, U) =&gt; scala.util.parsing.combinatorold.~[T,U])(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#29477">commit</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#71666">q</a></span>))((<span class="typed"><span class="type">T</span><a id="71755">x</a></span>, <span class="typed"><span class="type">U</span><a id="71756">y</a></span>) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[T,U]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[T,U]</span><a href="$tilde.scala.html#11682">~</a></span>(<span class="typed"><span class="type">T</span><a href="#71755">x</a></span>,<span class="typed"><span class="type">U</span><a href="#71756">y</a></span>))(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71680">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71670">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~!&quot;)</span><span class="string">&quot;~!&quot;</span></span>
    }
    
    <span class="comment">/** A parser combinator for non-back-tracking sequential composition with a unit-parser
     *
     *&lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `p'.
     *         The resulting parser fails if either `p' or `q' fails, this failure is fatal.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[T]</span><span id="29597"><a id="71762">~!</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29599">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71761">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]</span><a id="71763" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[T]</span><a href="#29571">OnceParser</a></span>[T] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="71765">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71769">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])((T, Unit) =&gt; T)(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29480">commit</a></span>(<span class="typed"><span class="type">=&gt; Q</span><a href="#71761">q</a></span>))((<span class="typed"><span class="type">T</span><a id="71784">x</a></span>, <span class="typed"><span class="type">Unit</span><a id="71785">y</a></span>) =&gt; <span class="typed"><span class="type">T</span><a href="#71784">x</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71769">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71766">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~!&quot;)</span><span class="string">&quot;~!&quot;</span></span>
    }

    <span class="comment">/** A parser combinator for alternative composition 
     *
     *&lt;p&gt;`p | q' succeeds if `p' succeeds or `q' succeeds
     *          Note that `q' is only tried if `p's failure is non-fatal (i.e., back-tracking is
     *          allowed).&lt;/p&gt;
     * 
     * @param q a parser that will be executed if `p' (this parser) fails (and allows back-tracking)
     * @return a `Parser' that returns the result of the first parser to succeed (out of `p' and `q')
     *         The resulting parser succeeds if (and only if) &lt;ul&gt;
     *           &lt;li&gt; `p' succeeds, &lt;i&gt;or&lt;/i&gt;  &lt;/li&gt;
     *           &lt;li&gt; if `p' fails allowing back-tracking and `q' succeeds. &lt;/li&gt; &lt;/ul&gt;
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="29600">|</a></span> [<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="29602">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="71788">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71789" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71791">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71794">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71794">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">match</span></span> {
        <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="71800">s1</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#71800">s1</a></span>
        <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="71801">e1</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#71801">e1</a></span>
        <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="71802">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71803">next1</a></span>) =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#29587">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71794">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">match</span></span> {
              <span class="typed"><span class="type">Parsers.this.Success[U]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[U]</span><a id="71808">s2</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[U]</span><a href="#71808">s2</a></span>
              <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="71809">f2</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71810">next2</a></span>) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71810">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71803">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#71802">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#71809">f2</a></span>
              <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="71811">e2</a></span> @ <a id="1">Error</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71812">next2</a></span>) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71812">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71803">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#71802">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Error</span><a href="#71811">e2</a></span>
        }
      }
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71792">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;|&quot;)</span><span class="string">&quot;|&quot;</span></span>
    }
    
    <span class="comment">/** A parser combinator for alternative with longest match composition 
     *
     *&lt;p&gt;`p ||| q' succeeds if `p' succeeds or `q' succeeds
     *          If `p' and `q' both succeed, the parser that consumed the most
     *          characters accepts.&lt;/p&gt;
     * 
     * @param q a parser that accepts if p consumes less characters.
     * @return a `Parser' that returns the result of the parser consuming the most characteres (out of `p' and `q').
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="29603">|||</a></span> [<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="29605">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="71815">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71816" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71818">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71821">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = {
        <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a id="71823">res1</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71821">in</a></span>)
        <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a id="71824">res2</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#29587">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71821">in</a></span>)
        
        <span class="typed"><span class="type">(Parsers.this.ParseResult[T],Parsers.this.ParseResult[U])(Parsers.this.ParseResult[T], Parsers.this.ParseResult[U])</span><a href="../../../Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#71823">res1</a></span>, <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#71824">res2</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">match</span></span> {
          <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="71835">s1</a></span> @ <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71836">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Success[U]</span><a id="71837">s2</a></span> @ <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71838">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71838">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71836">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#71835">s1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Success[U]</span><a href="#71837">s2</a></span>
          <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="71839">s1</a></span> @ <a id="1">Success</a>(_, _), _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#71839">s1</a></span>
          <span class="typed"><span class="type">Parsers.this.Success[U]</span><span class="keyword">case</span></span> <a id="1">(</a>_, <span class="typed"><span class="type">Parsers.this.Success[U]</span><a id="71840">s2</a></span> @ <a id="1">Success</a>(_, _)) =&gt; <span class="typed"><span class="type">Parsers.this.Success[U]</span><a href="#71840">s2</a></span>
          <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Error</span><a id="71841">e1</a></span> @ <a id="1">Error</a>(_, _), _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#71841">e1</a></span>
          <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Failure</span><a id="71842">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71843">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Failure</span><a id="71844">f2</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71845">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71845">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71843">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#71842">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#71844">f2</a></span>
          <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Failure</span><a id="71846">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71847">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Error</span><a id="71848">e2</a></span> @ <a id="1">Error</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71849">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71849">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71847">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#71846">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Error</span><a href="#71848">e2</a></span>
        }
      }
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71819">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;|||&quot;)</span><span class="string">&quot;|||&quot;</span></span>
    }

    <span class="comment">/** A parser combinator for function application 
     *
     *&lt;p&gt;`p ^^ f' succeeds if `p' succeeds; it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a function that will be applied to this parser's result (see `map' in `ParseResult').
     * @return a parser that has the same behaviour as the current parser, but whose result is
     *         transformed by `f'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.Parser[U]</span><a id="29606">^^</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29608">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="71852">f</a></span>: T =&gt; U): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71853" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71855">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71858">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71858">in</a></span>).<span class="typed"><span class="type">((T) =&gt; U)Parsers.this.ParseResult[U]</span><a href="#29661">map</a></span>(<span class="typed"><span class="type">(T) =&gt; U</span><a href="#71852">f</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71856">toString</a></span> = <span class="typed"><span class="type">Parser.this.type</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">()java.lang.String</span><a href="../../../Function1.scala.html#17301">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;^^&quot;)</span><span class="string">&quot;^^&quot;</span></span>
    }    
    
    <span class="comment">/** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? (f, error)' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'. If `f' is not applicable,
     *  error(the result of `p') should explain why.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U],(T) =&gt; String)Parsers.this.Parser[U]</span><a id="29609">^?</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29611">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="71867">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U], <span class="typed"><span class="type">(T) =&gt; String</span><a id="71868">error</a></span>: T =&gt; String): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71869" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71871">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71874">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71874">in</a></span>).<span class="typed"><span class="type">(PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a href="#29664">mapPartial</a></span>(<span class="typed"><span class="type">PartialFunction[T,U]</span><a href="#71867">f</a></span>, <span class="typed"><span class="type">(T) =&gt; String</span><a href="#71868">error</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71872">toString</a></span> = <span class="typed"><span class="type">Parser.this.type</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">()java.lang.String</span><a href="../../../Function1.scala.html#17301">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;^?&quot;)</span><span class="string">&quot;^?&quot;</span></span>
    }    
     
    <span class="comment">/** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? f' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U])Parsers.this.Parser[U]</span><a id="29612">^?</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29614">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="71883">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71884" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71886">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71889">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71889">in</a></span>).<span class="typed"><span class="type">(PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a href="#29664">mapPartial</a></span>(<span class="typed"><span class="type">PartialFunction[T,U]</span><a href="#71883">f</a></span>, <span class="typed"><span class="type">T</span><a id="71897">result</a></span> =&gt; <span class="typed"><span class="type">java.lang.String(&quot;Constructor function not defined at &quot;)</span><span class="string">&quot;Constructor function not defined at &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">T</span><a href="#71897">result</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71887">toString</a></span> = <span class="typed"><span class="type">Parser.this.type</span><a href="#29467">Parser</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">()java.lang.String</span><a href="../../../Function1.scala.html#17301">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;^?&quot;)</span><span class="string">&quot;^?&quot;</span></span>
    }       
    
       
    <span class="comment">/** A parser combinator that parameterises a subsequent parser with the result of this one
     *
     *&lt;p&gt;
     * Use this combinator when a parser depends on the result of a previous parser. `p' should be
     * a function that takes the result from the first parser and returns the second parser.&lt;/p&gt;
     *
     *&lt;p&gt; `p into fq' (with `fq' typically `{x =&gt; q}') first applies `p', and then, if `p' successfully  
     *    returned result `r', applies `fq(r)' to the rest of the input. &lt;/p&gt;
     *
     *&lt;p&gt; From: G. Hutton. Higher-order functions for parsing. J. Funct. Program., 2(3):323--343, 1992. &lt;/p&gt;
     *
     * @param fq a function that, given the result from this parser, returns the second parser to be applied
     * @return a parser that succeeds if this parser succeeds (with result `x') and if then `fq(x)' succeeds
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="29615">into</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29617">U</a></span>](<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a id="71900">fq</a></span>: T =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71901" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
       <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71903">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71905">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71905">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">match</span></span> {
         <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">T</span><a id="71911">result</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71912">next</a></span>) =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#29587">fq</a></span>(<span class="typed"><span class="type">T</span><a href="#71911">result</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71912">next</a></span>)
         <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="71917">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#71917">ns</a></span>
       }
     }
    
    <span class="comment">// shortcuts for combinators:</span>
    
    <span class="comment">/** Returns into(fq) */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="29618">&gt;&gt;</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29620">U</a></span>](<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a id="71918">fq</a></span>: T =&gt; Parser[U])=<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#29615">into</a></span>(<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a href="#71918">fq</a></span>)
    
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses
     *
     * @return rep(this) 
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[List[T]]</span><a id="29621">*</a></span> = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29510">rep</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467" class="keyword">this</a></span>)
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses, interleaved with the `sep' parser.
     *
     * @return repsep(this, sep)
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><span id="29622"><a id="71937">*</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29624">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71936">sep</a></span>: =&gt; Q) = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><a href="#29516">repsep</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467" class="keyword">this</a></span>, <span class="typed"><span class="type">=&gt; Q</span><a href="#71936">sep</a></span>)
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses, interleaved with the `sep' parser.
     * The `sep' parser specifies how the results parsed by this parser should be combined.
     *
     * @return chainl1(this, sep) 
     */</span>    
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]</span><a id="29625">*</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="29627">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[(U, U) =&gt; U]</span><a id="71947">sep</a></span>: =&gt; Parser[(U, U) =&gt; U]) = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U],=&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]</span><a href="#29546">chainl1</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467" class="keyword">this</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(U, U) =&gt; U]</span><a href="#71947">sep</a></span>)
    
    <span class="comment">// TODO: improve precedence? a ~ b*(&quot;,&quot;) = a ~ (b*(&quot;,&quot;))  should be true </span>
    
    <span class="comment">/** Returns a parser that repeatedly (at least once) parses what this parser parses.
     *
     * @return rep1(this) 
     */</span>      
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[List[T]]</span><a id="29628">+</a></span> = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29521">rep1</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467" class="keyword">this</a></span>)
    
    <span class="comment">/** Returns a parser that optionally parses what this parser parses.
     *
     * @return opt(this) 
     */</span>       
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[Option[T]]</span><a id="29629">?</a></span> = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]</span><a href="#29559">opt</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467" class="keyword">this</a></span>)
  }

  <span class="comment">/** The root class of special parsers returning the trivial result &lt;code&gt;Unit&lt;/code&gt;
   *  These compose differently from normal parsers in that the &lt;code&gt;Unit&lt;/code&gt;
   *  result in a sequential or function composition is dropped.
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class UnitParser extends java.lang.Object with (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit] with ScalaObject</span><a id="29469">UnitParser</a></span> <span class="keyword">extends</span> (Input =&gt; ParseResult[Unit]) {
                                      
    <span class="comment">/** An unspecified method that defines the behaviour of this parser.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="49116">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="49143">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#29454">ParseResult</a></span>[Unit]

    <span class="comment">/** A parser combinator for sequential composition 
     *
     *&lt;p&gt;`p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `q'. 
     *         The resulting parser fails if either `p' or `q' fails.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="49117">~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49119">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="71994">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="71995" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="71997">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72000">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#29454">ParseResult</a></span>[U] = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((Unit, U) =&gt; U)(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#71994">q</a></span>)((<span class="typed"><span class="type">Unit</span><a id="72005">x</a></span>, <span class="typed"><span class="type">U</span><a id="72006">y</a></span>) =&gt; <span class="typed"><span class="type">U</span><a href="#72006">y</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72000">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="71998">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span>
    }
     
    <span class="comment">/** A parser combinator for sequential composition with a unit-parser 
     *
     * &lt;p&gt;`p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     *
     * @param q a parser (convertible to a UnitParser) that will be executed after `p' (this parser)
     *          succeeds
     * @return a `UnitParser' that fails if either `p' or `q' fails. 
     */</span> 
    <span class="keyword">def</span> <span class="typed"><span class="type">[A](=&gt; A)(implicit (A) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="49120"><a id="72010">~</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49122">A</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; A</span><a id="72009">q</a></span>: =&gt; A): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72011" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72013">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72016">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#29454">ParseResult</a></span>[Unit] = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])((Unit, Unit) =&gt; Unit)(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(A)Parsers.this.UnitParser</span><a href="../../../Function1.scala.html#17300">q</a></span>)((<span class="typed"><span class="type">Unit</span><a id="72021">x</a></span>, <span class="typed"><span class="type">Unit</span><a id="72022">y</a></span>) =&gt; <span class="typed"><span class="type">Unit</span><a href="#72022">y</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72016">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="72014">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span>
    }
     
    <span class="comment">/** A parser combinator for non-back-tracking sequential composition 
     *
     *  &lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `q`. 
     *         The resulting parser fails if either `p' or `q' fails, this failure is fatal.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="49123">~!</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49125">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="72025">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U] with Parsers.this.OnceParser[U]</span><a id="72026" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[U]</span><a href="#29571">OnceParser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="72028">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72032">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((Unit, U) =&gt; U)(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#29477">commit</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#72025">q</a></span>))((<span class="typed"><span class="type">Unit</span><a id="72048">x</a></span>, <span class="typed"><span class="type">U</span><a id="72049">y</a></span>) =&gt; <span class="typed"><span class="type">U</span><a href="#72049">y</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72032">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="72029">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~!&quot;)</span><span class="string">&quot;~!&quot;</span></span>
    }

    <span class="comment">/** A parser combinator for non-back-tracking sequential composition with a unit-parser
     *
     *  &lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `UnitParser' that fails if either `p' or `q' fails, this failure is fatal.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="49126"><a id="72053">~!</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49128">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72052">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser with Parsers.this.UnitOnceParser</span><a id="72054" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.UnitOnceParser</span><a href="#29573">UnitOnceParser</a></span> {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72056">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72067">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])((Unit, Unit) =&gt; Unit)(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29480">commit</a></span>(<span class="typed"><span class="type">=&gt; Q</span><a href="#72052">q</a></span>))((<span class="typed"><span class="type">Unit</span><a id="72082">x</a></span>, <span class="typed"><span class="type">Unit</span><a id="72083">y</a></span>) =&gt; <span class="typed"><span class="type">Unit</span><a href="#72083">y</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72067">in</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="72057">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;~!&quot;)</span><span class="string">&quot;~!&quot;</span></span>
    }

     <span class="comment">/** A parser combinator for alternative composition 
     *
     *&lt;p&gt;`p | q' succeeds if `p' succeeds or `q' succeeds
     *          Note that `q' is only tried if `p's failure is non-fatal (i.e., back-tracking is
     *          allowed).&lt;/p&gt;
     * 
     * @param q a parser that will be executed if `p' (this parser) fails (and allows back-tracking)
     * @return a `Parser' succeeds if (and only if) &lt;ul&gt;
     *           &lt;li&gt; `p' succeeds, &lt;i&gt;or&lt;/i&gt;  &lt;/li&gt;
     *           &lt;li&gt; if `p' fails allowing back-tracking and `q' succeeds. &lt;/li&gt; &lt;/ul&gt;
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="49129"><a id="72087">|</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49131">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72086">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72088" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72090">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72093">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">UnitParser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72093">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">match</span></span> {
        <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72099">s1</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#72099">s1</a></span>
        <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="72100">e1</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#72100">e1</a></span>
        <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="72101">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72102">next1</a></span>) =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72093">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">match</span></span> {
              <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72117">s2</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#72117">s2</a></span>
              <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="72118">f2</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72119">next2</a></span>) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72119">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72102">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#72101">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#72118">f2</a></span>
              <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="72120">e2</a></span> @ <a id="1">Error</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72121">next2</a></span>) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72121">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72102">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#72101">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Error</span><a href="#72120">e2</a></span>
        }
      }
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="72091">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;|&quot;)</span><span class="string">&quot;|&quot;</span></span>
    }
    
    <span class="comment">/** A parser combinator for alternative with longest match composition 
     *
     *&lt;p&gt;`p ||| q' succeeds if `p' succeeds or `q' succeeds
     *          If `p' and `q' both succeed, the parser that consumed the most
     *          characters accepts.&lt;/p&gt;
     * 
     * @param q a parser that accepts if p consumes less characters.
     * @return a `Parser' that returns the result of the parser consuming the most characteres (out of `p' and `q').
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="49132"><a id="72125">|||</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49134">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72124">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72126" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72128">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72131">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = {
        <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a id="72133">res1</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">UnitParser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72131">in</a></span>)
        <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a id="72134">res2</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72131">in</a></span>)
        
        <span class="typed"><span class="type">(Parsers.this.ParseResult[Unit],Parsers.this.ParseResult[Unit])(Parsers.this.ParseResult[Unit], Parsers.this.ParseResult[Unit])</span><a href="../../../Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#72133">res1</a></span>, <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#72134">res2</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">match</span></span> {
          <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72155">s1</a></span> @ <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72156">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72157">s2</a></span> @ <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72158">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72158">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72156">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#72155">s1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#72157">s2</a></span>
          <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72159">s1</a></span> @ <a id="1">Success</a>(_, _), _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#72159">s1</a></span>
          <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <a id="1">(</a>_, <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72160">s2</a></span> @ <a id="1">Success</a>(_, _)) =&gt; <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#72160">s2</a></span>
          <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Error</span><a id="72161">e1</a></span> @ <a id="1">Error</a>(_, _), _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#72161">e1</a></span>
          <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Failure</span><a id="72162">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72163">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Failure</span><a id="72164">f2</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72165">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72165">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72163">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#72162">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#72164">f2</a></span>
          <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Failure</span><a id="72166">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72167">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Error</span><a id="72168">e2</a></span> @ <a id="1">Error</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72169">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72169">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72167">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#72166">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Error</span><a href="#72168">e2</a></span>
        }
      }
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="72129">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;|||&quot;)</span><span class="string">&quot;|||&quot;</span></span>
    }
     
     
    <span class="comment">/** A parser combinator for function application 
     *
     *  &lt;p&gt;`p ^^ v' succeeds if `p' succeeds; it returns `v'.&lt;/p&gt;
     *
     * @param v a value that's used as the result of the returned Parser (if it was successful).
     * @return a parser that has the same behaviour as the current parser, but whose result is
     *         consists of `v'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](U)Parsers.this.Parser[U]</span><a id="49135">^^</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="49137">U</a></span>](<span class="typed"><span class="type">U</span><a id="72172">v</a></span>: <span class="typed"><span class="type">U</span><a href="#49137">U</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="72173" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="72175">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72178">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">UnitParser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72178">in</a></span>).<span class="typed"><span class="type">((Unit) =&gt; U)Parsers.this.ParseResult[U]</span><a href="#29661">map</a></span>(<span class="typed"><span class="type">Unit</span><a id="72186">x</a></span> =&gt; <span class="typed"><span class="type">U</span><a href="#72172">v</a></span>)
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="72176">toString</a></span> = <span class="typed"><span class="type">UnitParser.this.type</span><a href="#29469">UnitParser</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">()java.lang.String</span><a href="../../../Function1.scala.html#17301">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;^^&quot;)</span><span class="string">&quot;^^&quot;</span></span>
    }
  }

  <span class="comment">// TODO: can this implemented in ParseResult, like map?</span>
  <span class="comment">/** A helper method for sequential composition of (unit-)parsers
  */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T, U, V](=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((T, U) =&gt; V)(Parsers.this.Input)Parsers.this.ParseResult[V]</span><a id="29470">seq</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29474">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29475">U</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29476">V</a></span>](<span class="typed"><span class="type">=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]</span><a id="71633">p</a></span>: =&gt; Input =&gt; ParseResult[T], <span class="typed"><span class="type">=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]</span><a id="71634">q</a></span>: =&gt; Input =&gt; ParseResult[U])
                          (<span class="typed"><span class="type">(T, U) =&gt; V</span><a id="71635">compose</a></span>: (T, U) =&gt; V)
                          (<span class="typed"><span class="type">Parsers.this.Input</span><a id="71636">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><a href="#29454">ParseResult</a></span>[V] 
    = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="../../../Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71636">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">T</span><a id="72189">x</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72190">next1</a></span>) =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="../../../Function1.scala.html#17300">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72190">next1</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><span class="keyword">match</span></span> {
          <span class="typed"><span class="type">Parsers.this.Success[V]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">U</span><a id="72191">y</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72192">next2</a></span>) =&gt; <span class="typed"><span class="type">(V,Parsers.this.Input)Parsers.this.Success[V]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">(T,U)V</span><a href="../../../Function2.scala.html#20399">compose</a></span>(<span class="typed"><span class="type">T</span><a href="#72189">x</a></span>, <span class="typed"><span class="type">U</span><a href="#72191">y</a></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72192">next2</a></span>)
          <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="72194">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#72194">ns</a></span>
        }
      <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="72195">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#72195">ns</a></span>
    }
  
  <span class="comment">/** Wrap a parser so that its failures become errors (the | combinator will give up as soon as 
   *  it encounters an error, on failure it simply tries the next alternative) 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a id="29477">commit</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29479">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71724">p</a></span>: =&gt; Parser[T]) = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="71726" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="71728">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71730">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71730">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">match</span></span>{
      <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="71736">s</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#71736">s</a></span>
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="71737">e</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#71737">e</a></span>
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="71738">f</a></span> @ <a id="1">Failure</a>(<span class="typed"><span class="type">String</span><a id="71739">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71740">next</a></span>) =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Error</span><a href="#71608">Error</a></span>(<span class="typed"><span class="type">String</span><a href="#71739">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71740">next</a></span>)
    }
  }
  
  <span class="comment">/** Wrap a parser so that its failures become errors (the | combinator will give up as soon as 
   *  it encounters an error, on failure it simply tries the next alternative) 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="29480"><a id="71687">commit</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29482">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71686">p</a></span>: =&gt; Q) = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="71689" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="71691">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="71693">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#71693">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">match</span></span>{
      <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="71711">s</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a href="#71711">s</a></span>
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="71712">e</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#71712">e</a></span>
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="71713">f</a></span> @ <a id="1">Failure</a>(<span class="typed"><span class="type">String</span><a id="71714">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="71715">next</a></span>) =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Error</span><a href="#71608">Error</a></span>(<span class="typed"><span class="type">String</span><a href="#71714">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#71715">next</a></span>)
    }
  }
  
  <span class="comment">/** Wrap a parser so that its failures&amp;errors become success and vice versa -- it never consumes any input 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="29483"><a id="72197">not</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29485">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72196">p</a></span>: =&gt; Q) = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72199" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72201">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72203">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72203">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">match</span></span>{
      <span class="typed"><span class="type">Parsers.this.Failure</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><a id="72219">s</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Expected failure&quot;)</span><span class="string">&quot;Expected failure&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72203">in</a></span>)
      <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="72220">e</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72203">in</a></span>)
      <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="72222">f</a></span> @ <a id="1">Failure</a>(<span class="typed"><span class="type">String</span><a id="72223">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72224">next</a></span>) =&gt; <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72203">in</a></span>)
    }
  }  
  
	<span class="comment">/*trait ElemFun
  case class EFCons(hd: Elem =&gt; ElemFun, tl: ElemFun) extends ElemFun
  case class EFNil(res: Boolean) extends ElemFun*/</span>

   
  <span class="comment">/** A parser matching input elements that satisfy a given predicate
   *
   * &lt;p&gt;elem(kind, p) succeeds if the input starts with an element `e' for which p(e) is true.&lt;/p&gt;
   *
   * @param  kind   The element kind, used for error messages
   * @param  p      A predicate that determines which elements match.
   * @return 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(String,(Parsers.this.Elem) =&gt; Boolean)Parsers.this.Parser[Parsers.this.Elem]</span><a id="29486">elem</a></span>(<span class="typed"><span class="type">String</span><a id="49162">kind</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">(Parsers.this.Elem) =&gt; Boolean</span><a id="49163">p</a></span>: Elem =&gt; Boolean) = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[Parsers.this.Elem]</span><a id="49165" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.Elem]</span><a href="#29467">Parser</a></span>[Elem] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Parsers.this.Elem]</span><a id="49167">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="49169">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) =
      <span class="typed"><span class="type">Parsers.this.ParseResult[Parsers.this.Elem]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(Parsers.this.Elem)Boolean</span><a href="../../../Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#49169">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>)) <span class="typed"><span class="type">(Parsers.this.Elem,Parsers.this.Input)Parsers.this.Success[Parsers.this.Elem]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#49169">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#49169">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>)
      <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">String</span><a href="#49162">kind</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; expected&quot;)</span><span class="string">&quot; expected&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#49169">in</a></span>)
  }  
   
  <span class="comment">/** A parser that matches only the given element `e'
   *
   * &lt;p&gt;elem(e) succeeds if the input starts with an element `e'&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `Parser' that succeeds if `e' is the next available input (and returns it).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]</span><a id="29487">elem</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a id="49109">e</a></span>: <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#29452">Elem</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.Elem]</span><a href="#29467">Parser</a></span>[Elem] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[Parsers.this.Elem]</span><a id="72231" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.Elem]</span><a href="#29467">Parser</a></span>[Elem] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Parsers.this.Elem]</span><a id="72233">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72235">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) =
      <span class="typed"><span class="type">Parsers.this.ParseResult[Parsers.this.Elem]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72235">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#49109">e</a></span>) <span class="typed"><span class="type">(Parsers.this.Elem,Parsers.this.Input)Parsers.this.Success[Parsers.this.Elem]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a href="#49109">e</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72235">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>)
      <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;`&quot;)</span><span class="string">&quot;`&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.Elem</span><a href="#49109">e</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;' expected but &quot;)</span><span class="string">&quot;' expected but &quot;</span></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72235">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">java.lang.String(&quot; found&quot;)</span><span class="string">&quot; found&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72235">in</a></span>)
  }
  
  
  <span class="comment">/** A parser that matches only the given element `e' 
   *&lt;p&gt;
   * The method is implicit so that elements can automatically be lifted to their unit-parsers. 
   * For example, when parsing `Token's, Identifier(&quot;new&quot;) (which is a `Token') can be used directly,
   * instead of first creating a `UnitParser' using accept(Identifier(&quot;new&quot;)).&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `UnitParser' that succeeds if `e' is the next available input.
   */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">implicit scala.util.parsing.combinatorold.Parsers.accept : (Parsers.this.Elem)Parsers.this.UnitParser</span><a id="29488">accept</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a id="49157">e</a></span>: <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#29452">Elem</a></span>): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72238" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72240">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72242">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) =
      <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72242">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#49157">e</a></span>) <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72242">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>)
      <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;`&quot;)</span><span class="string">&quot;`&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.Elem</span><a href="#49157">e</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;' expected but &quot;)</span><span class="string">&quot;' expected but &quot;</span></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72242">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">java.lang.String(&quot; found&quot;)</span><span class="string">&quot; found&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72242">in</a></span>)
  }
   
  <span class="comment">/** A parser that matches only the given list of element `es'
   *
   * &lt;p&gt;accept(es) succeeds if the input subsequently provides the elements in the list `es'.&lt;/p&gt;
   *
   * @param  es the list of expected elements
   * @return a UnitParser that recognizes a specified list of elements
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[ES](ES)(implicit (ES) =&gt; List[Parsers.this.Elem])Parsers.this.UnitParser</span><span id="29489"><a id="72246">accept</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29491">ES</a></span> &lt;% List[Elem]](<span class="typed"><span class="type">ES</span><a id="72245">es</a></span>: <span class="typed"><span class="type">ES</span><a href="#29491">ES</a></span>): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72247" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72249">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72251">in0</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = {
      <span class="keyword">var</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Parsers.this.Elem]</span><a id="72253">res</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Parsers.this.Elem]</span><span class="keyword">new</span></span> scala.collection.mutable.<span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Parsers.this.Elem]</span><a href="../../../collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[Elem]
      <span class="keyword">var</span> <span class="typed"><span class="type">List[Parsers.this.Elem]</span><a id="72254">these</a></span>: <span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="../../../List.scala.html#524">List</a></span>[Elem] = <span class="typed"><span class="type">(ES)List[Parsers.this.Elem]</span><a href="../../../Function1.scala.html#17300">es</a></span>
      <span class="keyword">var</span> <span class="typed"><span class="type">Parsers.this.Input</span><a id="72255">in</a></span> = <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72251">in0</a></span>
      
      <span class="typed"><span class="type">Unit</span><a href="#72256" class="keyword">while</a></span>(<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="#72254">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../../Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72255">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="#72254">these</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../../../List.scala.html#20869">head</a></span>) {
        <span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="#72254">these</a></span> = <span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="#72254">these</a></span>.<span class="typed"><span class="type">=&gt; List[Parsers.this.Elem]</span><a href="../../../List.scala.html#20871">tail</a></span>
        <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72255">in</a></span> = <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72255">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>
      }
       
      <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="#72254">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../../Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72255">in</a></span>)
      <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Expected: '&quot;)</span><span class="string">&quot;Expected: '&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">List[Parsers.this.Elem]</span><a href="#72254">these</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../../../List.scala.html#20869">head</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;', found: '&quot;)</span><span class="string">&quot;', found: '&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.Input</span><a href="#72255">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;'&quot;)</span><span class="string">&quot;'&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72251">in0</a></span>)
    }
  }    

  <span class="comment">/** The parser that matches an element in the domain of the partial function `f'
   *&lt;p&gt;
   * If `f' is defined on the first element in the input, `f' is applied to it to produce 
   * this parser's result.&lt;/p&gt;
   *&lt;p&gt;
   * Example: The parser &lt;code&gt;accept(&quot;name&quot;, {case Identifier(n) =&gt; Name(n)})&lt;/code&gt; 
   *          accepts an &lt;code&gt;Identifier(n)&lt;/code&gt; and returns a &lt;code&gt;Name(n)&lt;/code&gt;.&lt;/p&gt;
   *
   * @param expected a description of the kind of element this parser expects (for error messages)
   * @param f a partial function that determines when this parser is successful and what its output is
   * @return A parser that succeeds if `f' is applicable to the first element of the input, 
   *         applying `f' to it to produce the result.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[U](String,PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]</span><a id="29492">accept</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29494">U</a></span>](<span class="typed"><span class="type">String</span><a id="72260">expected</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a id="72261">f</a></span>: <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[Elem, U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="72262" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="72264">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72266">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) =
      <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a href="#72261">f</a></span>.<span class="typed"><span class="type">(Parsers.this.Elem)Boolean</span><a href="../../../PartialFunction.scala.html#17289">isDefinedAt</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72266">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>)) <span class="typed"><span class="type">(U,Parsers.this.Input)Parsers.this.Success[U]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">(Parsers.this.Elem)U</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72266">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72266">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>)
      <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">String</span><a href="#72260">expected</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; expected&quot;)</span><span class="string">&quot; expected&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72266">in</a></span>)
  }

  <span class="comment">/** A parser that always fails 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(String)Parsers.this.Parser[Nothing]{def apply(Parsers.this.Input): Parsers.this.Failure}</span><a id="29495">failure</a></span>(<span class="typed"><span class="type">String</span><a id="72269">msg</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>) = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[Nothing]</span><a id="72271" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[Nothing]</span><a href="#29467">Parser</a></span>[Nothing] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.Failure</span><a id="72273">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72275">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">String</span><a href="#72269">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72275">in</a></span>)
  }

  <span class="comment">/** A unit-parser that always fails 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */</span>  
  <span class="keyword">def</span> <span class="typed"><span class="type">(String)Parsers.this.UnitParser{def apply(Parsers.this.Input): Parsers.this.Failure}</span><a id="29496">fail</a></span>(<span class="typed"><span class="type">String</span><a id="72282">msg</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>) = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72284" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.Failure</span><a id="72286">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72288">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#49175">Failure</a></span>(<span class="typed"><span class="type">String</span><a href="#72282">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72288">in</a></span>)
  }

  <span class="comment">/** A parser that always succeeds 
   *
   * @param v The result for the parser
   * @return A parser that always succeeds, with the given result `v'
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](T)Parsers.this.Parser[T]{def apply(Parsers.this.Input): Parsers.this.Success[T]}</span><a id="29497">success</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29499">T</a></span>](<span class="typed"><span class="type">T</span><a id="72295">v</a></span>: <span class="typed"><span class="type">T</span><a href="#29499">T</a></span>) = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="72297" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.Success[T]</span><a id="72299">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72301">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(T,Parsers.this.Input)Parsers.this.Success[T]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">T</span><a href="#72295">v</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72301">in</a></span>)
  }

  <span class="comment">/** A unit-parser that always succeeds  */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; &lt;refinement&gt; extends Parsers.this.UnitParser</span><a id="29500">success</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72314" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.Success[Unit]</span><a id="72316">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72318">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72318">in</a></span>)
  }
  
  <span class="comment">/** A unit-parser that always succeeds, discarding `p's result
  *
  * @param p The parser whose result is to be discarded
  * @return A parser that always succeeds, with the empty result
  */</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.UnitParser</span><a id="29501">discard</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29503">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="49112">p</a></span>: =&gt; Parser[T]) = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="49114" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="49139">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="49141">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#49141">in</a></span>) <span class="typed"><span class="type">((T) =&gt; Unit)Parsers.this.ParseResult[Unit]</span><a href="#29661">map</a></span> {(<span class="typed"><span class="type">T</span><a id="49151">x</a></span>) =&gt; <span class="typed"><span class="type">Unit</span><span >(</span></span>)}
  }
  
  
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])(String)Parsers.this.Parser[T]</span><a id="29504">log</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29506">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="72326">p</a></span>: =&gt; Parser[T])(<span class="typed"><span class="type">String</span><a id="72327">name</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="72328" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="72330">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72332">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = {<span class="typed"><span class="type">(Any)Unit</span><a href="../../../Predef.scala.html#13489">println</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;trying &quot;)</span><span class="string">&quot;trying &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">String</span><a href="#72327">name</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; at &quot;)</span><span class="string">&quot; at &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.Input</span><a href="#72332">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>); <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a id="72334">r</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72332">in</a></span>); <span class="typed"><span class="type">(Any)Unit</span><a href="../../../Predef.scala.html#13489">println</a></span>(<span class="typed"><span class="type">String</span><a href="#72327">name</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; --&gt; &quot;)</span><span class="string">&quot; --&gt; &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#72334">r</a></span>); <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#72334">r</a></span> }
  }
  
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(String)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="29507"><a id="72343">log</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29509">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72341">p</a></span>: =&gt; Q)(<span class="typed"><span class="type">String</span><a id="72342">name</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser</span><a id="72344" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="72346">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72348">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = {<span class="typed"><span class="type">(Any)Unit</span><a href="../../../Predef.scala.html#13489">println</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;trying &quot;)</span><span class="string">&quot;trying &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">String</span><a href="#72342">name</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; at &quot;)</span><span class="string">&quot; at &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.Input</span><a href="#72348">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>); <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a id="72350">r</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72348">in</a></span>); <span class="typed"><span class="type">(Any)Unit</span><a href="../../../Predef.scala.html#13489">println</a></span>(<span class="typed"><span class="type">String</span><a href="#72342">name</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; --&gt; &quot;)</span><span class="string">&quot; --&gt; &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#72350">r</a></span>); <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#72350">r</a></span> }
  }
    
    
  <span class="comment">/** A parser generator for repetitions.
   *  
   * &lt;p&gt; rep(p)   repeatedly uses `p' to parse the input until `p' fails (the result is a List 
   *  of the consecutive results of `p') &lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="29510">rep</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29512">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71927">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29521">rep1</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71927">p</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]</span><a href="#29600">|</a></span> <span class="typed"><span class="type">(List[Nothing])Parsers.this.Parser[List[Nothing]]{def apply(Parsers.this.Input): Parsers.this.Success[List[Nothing]]}</span><a href="#29497">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">List</a></span>())

  <span class="comment">/** A parser generator for repetitions.
   *  
   * &lt;p&gt; rep(p)   repeatedly uses `p' to parse the input until `p' fails&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that repeatedly applies `p' to the input.
   */</span>  
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="29513"><a id="71925">rep</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29515">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71924">p</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">(=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29530">rep1</a></span>(<span class="typed"><span class="type">=&gt; Q</span><a href="#71924">p</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.UnitParser{def apply(Parsers.this.Input): Parsers.this.Success[Unit]})(implicit (Parsers.this.UnitParser{def apply(Parsers.this.Input): Parsers.this.Success[Unit]}) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#49129">|</a></span> <span class="typed"><span class="type">=&gt; &lt;refinement&gt; extends Parsers.this.UnitParser</span><a href="#29500">success</a></span>
    
  <span class="comment">/** A parser generator for interleaved repetitions.
   *  
   * &lt;p&gt; repsep(p, q)   repeatedly uses `p' interleaved with `q' to parse the input, until `p' fails.
   *  (The result is a `List' of the results of `p'.) &lt;/p&gt;
   *
   * &lt;p&gt;Example: &lt;code&gt;repsep(term, &quot;,&quot;)&lt;/code&gt; parses a comma-separated list of term's, 
   *          yielding a list of these terms&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `UnitParser' that parses the elements that separate the elements parsed by `p'
   * @return A parser that returns a list of results produced by repeatedly applying `p' (interleaved
   *         with `q') to the input.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T, Q](=&gt; Parsers.this.Parser[T],=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><span id="29516"><a id="71941">repsep</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29519">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29520">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71939">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Q</span><a id="71940">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = 
    <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><a href="#29541">rep1sep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71939">p</a></span>, <span class="typed"><span class="type">=&gt; Q</span><a href="#71940">q</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]</span><a href="#29600">|</a></span> <span class="typed"><span class="type">(List[Nothing])Parsers.this.Parser[List[Nothing]]{def apply(Parsers.this.Input): Parsers.this.Success[List[Nothing]]}</span><a href="#29497">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">List</a></span>())
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(p) repeatedly uses `p' to parse the input until `p' fails -- `p' must succeed at least
   *             once (the result is a `List' of the consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches at least once).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="29521">rep1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29523">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71968">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29524">rep1</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71968">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71968">p</a></span>)
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(f, p) first uses `f' (which must succeed) and then repeatedly uses `p' to 
   *     parse the input until `p' fails 
   *     (the result is a `List' of the consecutive results of `f' and `p')&lt;/p&gt;
   *
   * @param first a `Parser' that parses the first piece of input
   * @param p a `Parser' that is to be applied successively to the rest of the input (if any)
   * @return A parser that returns a list of results produced by first applying `f' and then 
   *         repeatedly `p' to the input (it only succeeds if `f' matches).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="29524">rep1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29526">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71965">first</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71966">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71965">first</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,List[T]]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29510">rep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71966">p</a></span>) <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]</span><a href="#29606">^^</a></span> <span class="typed"><span class="type">List[T]</span><a href="#72514">{</a></span> <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <a id="1">~</a>(<span class="typed"><span class="type">T</span><a id="72515">x</a></span>, <span class="typed"><span class="type">List[T]</span><a id="72516">xs</a></span>) =&gt; <span class="typed"><span class="type">T</span><a href="#72515">x</a></span> <span class="typed"><span class="type">(T)List[T]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[T]</span><a href="#72516">xs</a></span> }
  
  <span class="comment">/* new Parser[List[T]] {
    def apply(in0: Input) = {
      val xs = new scala.collection.mutable.ListBuffer[T]
      var in = in0
      
      var res = first(in)
      
      while(res.successful) {
        xs += res.get
        in = res.next
        res = p(in)
      }
      
      if (!xs.isEmpty) Success(xs.toList, res.next)
      else Failure(&quot;TODO&quot;, TODO)
    }
  }*/</span>

  <span class="comment">/** A parser generator for a specified number of repetitions.
   *  
   * &lt;p&gt; repN(n, p)  uses `p' exactly `n' time to parse the input 
   *       (the result is a `List' of the `n' consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param n the exact number of times `p' must succeed
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches exactly `n' times).
   */</span>  
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](Int,=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="29527">repN</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29529">T</a></span>](<span class="typed"><span class="type">Int</span><a id="72520">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="72521">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = 
    <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">Int</span><a href="#72520">n</a></span><span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span><span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) <span class="typed"><span class="type">(object Nil)Parsers.this.Parser[object Nil]{def apply(Parsers.this.Input): Parsers.this.Success[object Nil]}</span><a href="#29497">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">Nil</a></span>) <span class="keyword">else</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#72521">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,List[T]]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">(Int,=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29527">repN</a></span>(<span class="typed"><span class="type">Int</span><a href="#72520">n</a></span><span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span><span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#72521">p</a></span>) <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]</span><a href="#29606">^^</a></span> <span class="typed"><span class="type">List[T]</span><a href="#72581">{</a></span> <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <a id="1">~</a>(<span class="typed"><span class="type">T</span><a id="72582">x</a></span>, <span class="typed"><span class="type">List[T]</span><a id="72583">xs</a></span>) =&gt; <span class="typed"><span class="type">T</span><a href="#72582">x</a></span> <span class="typed"><span class="type">(T)List[T]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[T]</span><a href="#72583">xs</a></span> }
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(p) repeatedly uses `p' to parse the input until `p' fails -- `p' must succeed at least
   *             once&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A unitparser that repeatedly applies `p' to the input
   *        (and that only succeeds if `p' matches at least once).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="29530"><a id="71963">rep1</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29532">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71962">p</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = 
    <span class="typed"><span class="type">(Q)Parsers.this.UnitParser</span><a href="../../../Function1.scala.html#17300">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.UnitParser)(implicit (Parsers.this.UnitParser) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#49120">~</a></span> <span class="typed"><span class="type">(=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29513">rep</a></span>(<span class="typed"><span class="type">=&gt; Q</span><a href="#71962">p</a></span>)
  
  <span class="comment">/** A parser generator for a specified number of repetitions.
   *  
   * &lt;p&gt; repN(n, p)  uses `p' exactly `n' time to parse the input&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param n the exact number of times `p' must succeed
   * @return A unitparser that repeatedly applies `p' to the input
   *        (and that only succeeds if `p' matches at exactly `n' times).
   */</span>  
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](Int,=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="29533"><a id="72561">repN</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29535">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">Int</span><a id="72559">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">=&gt; Q</span><a id="72560">p</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = 
    <span class="typed"><span class="type">Parsers.this.UnitParser</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">Int</span><a href="#72559">n</a></span><span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span><span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) <span class="typed"><span class="type">=&gt; &lt;refinement&gt; extends Parsers.this.UnitParser</span><a href="#29500">success</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">(Q)Parsers.this.UnitParser</span><a href="../../../Function1.scala.html#17300">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.UnitParser)(implicit (Parsers.this.UnitParser) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#49120">~</a></span> <span class="typed"><span class="type">(Int,=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29533">repN</a></span>(<span class="typed"><span class="type">Int</span><a href="#72559">n</a></span><span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span><span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>, <span class="typed"><span class="type">=&gt; Q</span><a href="#72560">p</a></span>) 
   
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   *  &lt;p&gt;rep1sep(first, p, q) starts by using `first', followed by repeatedly uses of `p' interleaved with `q' 
   *                to parse the input, until `p' fails. `first' must succeed (the result is a `List' of the 
   *                consecutive results of `first' and `p')&lt;/p&gt;
   *
   * @param first a `Parser' that is to be applied to the first element of input
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `UnitParser' that parses the elements that separate the elements parsed by `p' 
   *          (interleaved with `q')   
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches at least once).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T, Q](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T],=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><span id="29536"><a id="72440">rep1sep</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29539">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29540">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="72437">first</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="72438">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Q</span><a id="72439">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = 
    <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#72437">first</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,List[T]]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#29510">rep</a></span>(<span class="typed"><span class="type">(Q)Parsers.this.UnitParser</span><a href="../../../Function1.scala.html#17300">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a href="#49117">~</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#72438">p</a></span>) <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]</span><a href="#29606">^^</a></span> <span class="typed"><span class="type">List[T]</span><a href="#72680">{</a></span> <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="72681">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[T]</span><a id="72682">y</a></span> =&gt; <span class="typed"><span class="type">T</span><a href="#72681">x</a></span> <span class="typed"><span class="type">(T)List[T]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[T]</span><a href="#72682">y</a></span> }

  <span class="keyword">def</span> <span class="typed"><span class="type">[T, Q](=&gt; Parsers.this.Parser[T],=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><span id="29541"><a id="72434">rep1sep</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29544">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29545">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="72432">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Q</span><a id="72433">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#29467">Parser</a></span>[List[T]] = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T],=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[List[T]]</span><a href="#29536">rep1sep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#72432">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#72432">p</a></span>, <span class="typed"><span class="type">=&gt; Q</span><a href="#72433">q</a></span>)
   
  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * &lt;p&gt; From: J. Fokker. Functional parsers. In J. Jeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, pages 1--23. Springer, 1995.&lt;/p&gt;
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]</span><a id="29546">chainl1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29548">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71955">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, T) =&gt; T]</span><a id="71956">q</a></span>: =&gt; Parser[(T, T) =&gt; T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = 
    <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71955">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,List[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]])Parsers.this.Parser[List[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]]</span><a href="#29510">rep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, T) =&gt; T]</span><a href="#71956">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71955">p</a></span>) <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[T,List[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]]) =&gt; T)Parsers.this.Parser[T]</span><a href="#29606">^^</a></span> <span class="typed"><span class="type">T</span><a href="#72728">{</a></span><span class="typed"><span class="type">T</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="72729">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]</span><a id="72730">xs</a></span> =&gt; <span class="typed"><span class="type">List[scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]]</span><a href="#72730">xs</a></span>.<span class="typed"><span class="type">(T)((T, scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]) =&gt; T)T</span><a href="../../../List.scala.html#20919">foldLeft</a></span>(<span class="typed"><span class="type">T</span><a href="#72729">x</a></span>)((<span class="typed"><span class="type">T</span><a id="72733">a</a></span>, <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]</span><a id="72734">f_b</a></span>) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]</span><a href="#72734">f_b</a></span>.<span class="typed"><span class="type">(T,T)T</span><a href="../../../Function2.scala.html#20399">_1</a></span>(<span class="typed"><span class="type">T</span><a href="#72733">a</a></span>, <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, T) =&gt; T,T]</span><a href="#72734">f_b</a></span>.<span class="typed"><span class="type">=&gt; T</span><a href="$tilde.scala.html#40205">_2</a></span>))}  <span class="comment">// ((a, {f, b}) =&gt; f(a, b)) </span>

  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * @param first a parser that parses the first element
   * @param p a parser that parses the subsequent elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T, U](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[U],=&gt; Parsers.this.Parser[(T, U) =&gt; T])Parsers.this.Parser[T]</span><a id="29549">chainl1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29552">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29553">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71950">first</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="71951">p</a></span>: =&gt; Parser[U], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, U) =&gt; T]</span><a id="71952">q</a></span>: =&gt; Parser[(T, U) =&gt; T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = 
    <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71950">first</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,List[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]])Parsers.this.Parser[List[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]]</span><a href="#29510">rep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, U) =&gt; T]</span><a href="#71952">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#71951">p</a></span>) <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[T,List[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]]) =&gt; T)Parsers.this.Parser[T]</span><a href="#29606">^^</a></span> <span class="typed"><span class="type">T</span><a href="#72767">{</a></span><span class="typed"><span class="type">T</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="72768">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]</span><a id="72769">xs</a></span> =&gt; <span class="typed"><span class="type">List[scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]]</span><a href="#72769">xs</a></span>.<span class="typed"><span class="type">(T)((T, scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]) =&gt; T)T</span><a href="../../../List.scala.html#20919">foldLeft</a></span>(<span class="typed"><span class="type">T</span><a href="#72768">x</a></span>)((<span class="typed"><span class="type">T</span><a id="72772">a</a></span>, <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]</span><a id="72773">f_b</a></span>) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]</span><a href="#72773">f_b</a></span>.<span class="typed"><span class="type">(T,U)T</span><a href="../../../Function2.scala.html#20399">_1</a></span>(<span class="typed"><span class="type">T</span><a href="#72772">a</a></span>, <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; T,U]</span><a href="#72773">f_b</a></span>.<span class="typed"><span class="type">=&gt; U</span><a href="$tilde.scala.html#40205">_2</a></span>))}  <span class="comment">// ((a, {f, b}) =&gt; f(a, b)) </span>
        
  <span class="comment">/** A parser generator that generalises the rep1sep generator so that `q', which parses the separator,
   * produces a right-associative function that combines the elements it separates. Additionally,
   * The right-most (last) element and the left-most combinating function have to be supplied.
   * 
   * rep1sep(p: Parser[T], q) corresponds to chainr1(p, q ^^ cons, cons, Nil) (where val cons = (x: T, y: List[T]) =&gt; x :: y)
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a right-associative function that 
   *          combines two elements into one 
   * @param combine the &quot;last&quot; (left-most) combination function to be applied
   * @param first   the &quot;first&quot; (right-most) element to be combined
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T, U](Parsers.this.Parser[T],Parsers.this.Parser[(T, U) =&gt; U],(T, U) =&gt; U,U)Parsers.this.Parser[U]</span><a id="29554">chainr1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29557">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29558">U</a></span>](<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a id="72774">p</a></span>: <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T], <span class="typed"><span class="type">Parsers.this.Parser[(T, U) =&gt; U]</span><a id="72775">q</a></span>: <span class="typed"><span class="type">Parsers.this.Parser[(T, U) =&gt; U]</span><a href="#29467">Parser</a></span>[(T, U) =&gt; U], <span class="typed"><span class="type">(T, U) =&gt; U</span><a id="72776">combine</a></span>: (T, U) =&gt; U, <span class="typed"><span class="type">U</span><a id="72777">first</a></span>: <span class="typed"><span class="type">U</span><a href="#29558">U</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = 
    <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#72774">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]])Parsers.this.Parser[List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]]</span><a href="#29510">rep</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[(T, U) =&gt; U]</span><a href="#72775">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]</span><a href="#29588">~</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#72774">p</a></span>) <span class="typed"><span class="type">((scala.util.parsing.combinatorold.~[T,List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]]) =&gt; U)Parsers.this.Parser[U]</span><a href="#29606">^^</a></span> <span class="typed"><span class="type">U</span><a href="#72810">{</a></span><span class="typed"><span class="type">U</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="72811">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]</span><a id="72812">xs</a></span> =&gt; 
                          (<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]</span><a href="$tilde.scala.html#11682">~</a></span>(<span class="typed"><span class="type">(T, U) =&gt; U</span><a href="#72776">combine</a></span>, <span class="typed"><span class="type">T</span><a href="#72811">x</a></span>) <span class="typed"><span class="type">(scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T])List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]]</span><a href="#72812">xs</a></span>).<span class="typed"><span class="type">(U)((scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T], U) =&gt; U)U</span><a href="../../../List.scala.html#20922">foldRight</a></span>(<span class="typed"><span class="type">U</span><a href="#72777">first</a></span>)((<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]</span><a id="72821">f_a</a></span>, <span class="typed"><span class="type">U</span><a id="72822">b</a></span>) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]</span><a href="#72821">f_a</a></span>.<span class="typed"><span class="type">(T,U)U</span><a href="../../../Function2.scala.html#20399">_1</a></span>(<span class="typed"><span class="type">scala.util.parsing.combinatorold.~[(T, U) =&gt; U,T]</span><a href="#72821">f_a</a></span>.<span class="typed"><span class="type">=&gt; T</span><a href="$tilde.scala.html#40205">_2</a></span>, <span class="typed"><span class="type">U</span><a href="#72822">b</a></span>))}  <span class="comment">// (({f, a}, b) =&gt; f(a, b))     </span>
    
  <span class="comment">/** A parser generator for optional sub-phrases.
   *  
   *  &lt;p&gt;opt(p) is a parser that returns `Some(x)' if `p' returns `x' and `None' if `p' fails&lt;/p&gt;
   *
   * @param p A `Parser' that is tried on the input
   * @return a `Parser' that always succeeds: either with the result provided by `p' or 
   *         with the empty result
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]</span><a id="29559">opt</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29561">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="71984">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[Option[T]]</span><a href="#29467">Parser</a></span>[Option[T]] = 
    <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#71984">p</a></span> <span class="typed"><span class="type">((T) =&gt; Some[T])Parsers.this.Parser[Some[T]]</span><a href="#29606">^^</a></span> (<span class="typed"><span class="type">T</span><a id="72825">x</a></span> =&gt; <span class="typed"><span class="type">(T)Some[T]</span><a href="../../../Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">T</span><a href="#72825">x</a></span>)) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[Option[T]])Parsers.this.Parser[Option[T]]</span><a href="#29600">|</a></span> <span class="typed"><span class="type">(object None)Parsers.this.Parser[object None]{def apply(Parsers.this.Input): Parsers.this.Success[object None]}</span><a href="#29497">success</a></span>(<span class="typed"><span class="type">object None</span><a href="../../../Option.scala.html#534">None</a></span>)


  <span class="comment">/** Turns a unit-parser into a boolean-parser that denotes whether the unit-parser succeeded.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[Boolean]</span><span id="29562"><a id="71982">opt</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29564">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="71981">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[Boolean]</span><a href="#29467">Parser</a></span>[Boolean] = <span class="typed"><span class="type">(Q)Parsers.this.UnitParser</span><a href="../../../Function1.scala.html#17300">q</a></span> <span class="typed"><span class="type">(Boolean)Parsers.this.Parser[Boolean]</span><a href="#49135">^^</a></span> <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[Boolean])Parsers.this.Parser[Boolean]</span><a href="#29600">|</a></span> <span class="typed"><span class="type">(Boolean)Parsers.this.Parser[Boolean]{def apply(Parsers.this.Input): Parsers.this.Success[Boolean]}</span><a href="#29497">success</a></span>(<span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>) 
    
    
  <span class="comment">/** `positioned' decorates a parser's result with the start position of the input it consumed. 
   * 
   * @param p a `Parser' whose result conforms to `Positional'.
   * @return A parser that has the same behaviour as `p', but which marks its result with the 
   *         start position of the input it consumed, if it didn't already have a position.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T &lt;: scala.util.parsing.input.Positional](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a id="29565">positioned</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: scala.util.parsing.input.Positional</span><a id="29567">T</a></span> &lt;: Positional](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="72915">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="72916" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="72918">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72920">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29587">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72920">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">T</span><a id="72926">t</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72927">in1</a></span>) =&gt; <span class="typed"><span class="type">(T,Parsers.this.Input)Parsers.this.Success[T]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">T</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">T</span><a href="#72926">t</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Positional.scala.html#34333">pos</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">object scala.util.parsing.input.NoPosition</span><a href="../input/NoPosition.scala.html#10021">NoPosition</a></span>) <span class="typed"><span class="type">T</span><a href="#72926">t</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)t.type</span><a href="../input/Positional.scala.html#34336">setPos</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72920">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">T</span><a href="#72926">t</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72927">in1</a></span>)
      <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="72931">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#72931">ns</a></span>
    }
  }

  <span class="comment">/** &lt;code&gt;positioned&lt;/code&gt; decorates a unit-parser so that it returns the
   *  start position of the input it consumed. 
   * 
   *  @param p a `UnitParser'.
   *  @return  A parser that has the same behaviour as `p', but which returns
   *           the start position of the input it consumed.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[scala.util.parsing.input.Position]</span><span id="29568"><a id="72933">positioned</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29570">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72932">p</a></span>: =&gt; Q) = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[scala.util.parsing.input.Position]</span><a id="72935" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.input.Position]</span><a href="#29467">Parser</a></span>[Position] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.input.Position]</span><a id="72937">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72939">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#49116">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72939">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[scala.util.parsing.input.Position]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.Success[scala.util.parsing.input.Position]</span><span class="keyword">case</span></span> <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="72955">in1</a></span>) =&gt; <span class="typed"><span class="type">(scala.util.parsing.input.Position,Parsers.this.Input)Parsers.this.Success[scala.util.parsing.input.Position]</span><a href="#29657">Success</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72939">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#72955">in1</a></span>) 
      <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="72957">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#29460">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#72957">ns</a></span>
    }
  }
  
  <span class="comment">/** A parser whose ~ combinator disallows back-tracking.
   */</span>
  <span class="keyword">trait</span> <span class="typed"><span class="type">trait OnceParser[+T] extends Parsers.this.Parser[T] with ScalaObject</span><a id="29571">OnceParser</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="29572">T</a></span>] <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] {
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a id="71674">~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="71676">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="72965">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29467">Parser</a></span>[~[T, U]] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]] with Parsers.this.OnceParser[scala.util.parsing.combinatorold.~[T,U]]</span><a id="72966" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29467">Parser</a></span>[~[T, U]] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29571">OnceParser</a></span>[~[T, U]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.combinatorold.~[T,U]]</span><a id="72968">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72971">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((T, U) =&gt; scala.util.parsing.combinatorold.~[T,U])(Parsers.this.Input)Parsers.this.ParseResult[scala.util.parsing.combinatorold.~[T,U]]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.OnceParser[T]</span><a href="#29571">OnceParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#29477">commit</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#72965">q</a></span>))((<span class="typed"><span class="type">T</span><a id="72987">x</a></span>, <span class="typed"><span class="type">U</span><a id="72988">y</a></span>) =&gt; <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[T,U]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.util.parsing.combinatorold.~[T,U]</span><a href="$tilde.scala.html#11682">~</a></span>(<span class="typed"><span class="type">T</span><a href="#72987">x</a></span>, <span class="typed"><span class="type">U</span><a href="#72988">y</a></span>))(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72971">in</a></span>)
    }
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[Q](=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.Parser[T]</span><span id="71677"><a id="72992">~</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="71679">Q</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; Q</span><a id="72991">q</a></span>: =&gt; Q): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]</span><a id="72993" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#29467">Parser</a></span>[T] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[T]</span><a href="#29571">OnceParser</a></span>[T] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="72995">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="72998">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])((T, Unit) =&gt; T)(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.OnceParser[T]</span><a href="#29571">OnceParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Q)(implicit (Q) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29480">commit</a></span>(<span class="typed"><span class="type">=&gt; Q</span><a href="#72991">q</a></span>))((<span class="typed"><span class="type">T</span><a id="73013">x</a></span>, <span class="typed"><span class="type">Unit</span><a id="73014">y</a></span>) =&gt; <span class="typed"><span class="type">T</span><a href="#73013">x</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#72998">in</a></span>)
    }
  }
  
  <span class="comment">/** A parser whose ~ combinator disallows back-tracking.
   */</span>
  <span class="keyword">trait</span> <span class="typed"><span class="type">trait UnitOnceParser extends Parsers.this.UnitParser with ScalaObject</span><a id="29573">UnitOnceParser</a></span> <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> {
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="72061">~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="72063">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="73017">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U] with Parsers.this.OnceParser[U]</span><a id="73018" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#29467">Parser</a></span>[U] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[U]</span><a href="#29571">OnceParser</a></span>[U]{
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="73020">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="73023">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#29454">ParseResult</a></span>[U] = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((Unit, U) =&gt; U)(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.UnitOnceParser</span><a href="#29573">UnitOnceParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#29477">commit</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#73017">q</a></span>))((<span class="typed"><span class="type">Unit</span><a id="73038">x</a></span>, <span class="typed"><span class="type">U</span><a id="73039">y</a></span>) =&gt; <span class="typed"><span class="type">U</span><a href="#73039">y</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#73023">in</a></span>)
    }
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[A](=&gt; A)(implicit (A) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><span id="72064"><a id="73041">~</a></span></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="72066">A</a></span> &lt;% UnitParser](<span class="typed"><span class="type">=&gt; A</span><a id="73040">q</a></span>: =&gt; A): <span class="typed"><span class="type">Parsers.this.UnitParser</span><a href="#29469">UnitParser</a></span> = <span class="typed"><span class="type">template $anon extends Parsers.this.UnitParser with Parsers.this.UnitOnceParser</span><a id="73042" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.UnitOnceParser</span><a href="#29573">UnitOnceParser</a></span> {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a id="73044">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="73047">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><a href="#29454">ParseResult</a></span>[Unit] = <span class="typed"><span class="type">(=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])((Unit, Unit) =&gt; Unit)(Parsers.this.Input)Parsers.this.ParseResult[Unit]</span><a href="#29470">seq</a></span>(<span class="typed"><span class="type">Parsers.this.UnitOnceParser</span><a href="#29573">UnitOnceParser</a></span>.<span class="keyword">this</span>, <span class="typed"><span class="type">(=&gt; A)(implicit (A) =&gt; Parsers.this.UnitParser)Parsers.this.UnitParser</span><a href="#29480">commit</a></span>(<span class="typed"><span class="type">=&gt; A</span><a href="#73040">q</a></span>))((<span class="typed"><span class="type">Unit</span><a id="73061">x</a></span>, <span class="typed"><span class="type">Unit</span><a id="73062">y</a></span>) =&gt; <span class="typed"><span class="type">Unit</span><a href="#73062">y</a></span>)(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#73047">in</a></span>)
    }
  }
}

        </pre>
    </body>
</html>