<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/combinator/lexical/StdLexical.scala</title>
        <script type="text/javascript" src="../../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: StdLexical.scala 17218 2009-02-28 01:32:20Z extempore $</span>


<span class="keyword">package</span> scala.util.parsing.combinator.lexical

<span class="keyword">import</span> scala.util.parsing.syntax._
<span class="keyword">import</span> scala.util.parsing.input.CharArrayReader.EofCh
<span class="keyword">import</span> collection.mutable.HashSet

<span class="comment">/** &lt;p&gt;
 *    This component provides a standard lexical parser for a simple, Scala-like language. 
 *    It parses keywords and identifiers, numeric literals (integers), strings, and delimiters. 
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    To distinguish between identifiers and keywords, it uses a set of reserved identifiers: 
 *    every string contained in `reserved' is returned as a keyword token.
 *    (Note that &quot;=&gt;&quot; is hard-coded as a keyword.) 
 *    Additionally, the kinds of delimiters can be specified by the `delimiters' set.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Usually this component is used to break character-based input into bigger tokens,
 *    which are then passed to a token-parser {@see TokenParsers}.
 *  &lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */</span>
<span class="keyword">class</span> <span class="typed"><span class="type">class StdLexical extends scala.util.parsing.combinator.lexical.Lexical with scala.util.parsing.syntax.StdTokens with ScalaObject</span><a id="10174">StdLexical</a></span> <span class="keyword">extends</span> <span class="typed"><span class="type">scala.util.parsing.combinator.lexical.Lexical</span><a href="Lexical.scala.html#10213">Lexical</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">scala.util.parsing.syntax.StdTokens</span><a href="../../syntax/StdTokens.scala.html#14182">StdTokens</a></span> {
  <span class="comment">// see `token' in `Scanners'</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a id="18130">token</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Token] = 
    ( <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="#18131">identChar</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#18044">rep</a></span>( <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="#18131">identChar</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18126">digit</a></span> )              <span class="typed"><span class="type">((StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]) =&gt; Product with StdLexical.this.Token)StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24047">^^</a></span> <span class="typed"><span class="type">&lt;refinement&gt; extends Product with StdLexical.this.Token</span><a href="#66406">{</a></span> <span class="typed"><span class="type">&lt;refinement&gt; extends Product with StdLexical.this.Token</span><span class="keyword">case</span></span> <span class="typed"><span class="type">StdLexical.this.Elem</span><a id="66407">first</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a id="66408">rest</a></span> =&gt; <span class="typed"><span class="type">(String)Product with StdLexical.this.Token</span><a href="#18138">processIdent</a></span>(<span class="typed"><span class="type">StdLexical.this.Elem</span><a href="#66407">first</a></span> <span class="typed"><span class="type">(StdLexical.this.Elem)List[StdLexical.this.Elem]</span><a href="../../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a href="#66408">rest</a></span> <span class="typed"><span class="type">(String)String</span><a href="../../../../Iterable.scala.html#17364">mkString</a></span> <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>) }
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18126">digit</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#18044">rep</a></span>( <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18126">digit</a></span> )                              <span class="typed"><span class="type">((StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]) =&gt; StdLexical.this.NumericLit)StdLexical.this.Parser[StdLexical.this.NumericLit]</span><a href="../Parsers.scala.html#24047">^^</a></span> <span class="typed"><span class="type">StdLexical.this.NumericLit</span><a href="#66454">{</a></span> <span class="typed"><span class="type">StdLexical.this.NumericLit</span><span class="keyword">case</span></span> <span class="typed"><span class="type">StdLexical.this.Elem</span><a id="66455">first</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a id="66456">rest</a></span> =&gt; <span class="typed"><span class="type">(String)StdLexical.this.NumericLit</span><a href="../../syntax/StdTokens.scala.html#66458">NumericLit</a></span>(<span class="typed"><span class="type">StdLexical.this.Elem</span><a href="#66455">first</a></span> <span class="typed"><span class="type">(StdLexical.this.Elem)List[StdLexical.this.Elem]</span><a href="../../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a href="#66456">rest</a></span> <span class="typed"><span class="type">(String)String</span><a href="../../../../Iterable.scala.html#17364">mkString</a></span> <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>) }
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'\''</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#18044">rep</a></span>( <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18127">chrExcept</a></span>(<span class="typed"><span class="type">Char(''')</span><span class="char">'\''</span></span>, <span class="typed"><span class="type">Char('\012')</span><span class="char">'\n'</span></span>, <span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>) ) <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]],StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'\''</a></span> <span class="typed"><span class="type">((StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]],StdLexical.this.Elem]) =&gt; StdLexical.this.StringLit)StdLexical.this.Parser[StdLexical.this.StringLit]</span><a href="../Parsers.scala.html#24047">^^</a></span> <span class="typed"><span class="type">StdLexical.this.StringLit</span><a href="#66515">{</a></span> <span class="typed"><span class="type">StdLexical.this.StringLit</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Char(''')</span><span class="char">'\''</span></span> <a id="1">~</a> <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a id="66516">chars</a></span> <a id="1">~</a> <span class="typed"><span class="type">Char(''')</span><span class="char">'\''</span></span> =&gt; <span class="typed"><span class="type">(String)StdLexical.this.StringLit</span><a href="../../syntax/StdTokens.scala.html#66518">StringLit</a></span>(<span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a href="#66516">chars</a></span> <span class="typed"><span class="type">(String)String</span><a href="../../../../Iterable.scala.html#17364">mkString</a></span> <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>) }
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'\&quot;'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#18044">rep</a></span>( <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18127">chrExcept</a></span>(<span class="typed"><span class="type">Char('&quot;')</span><span class="char">'\&quot;'</span></span>, <span class="typed"><span class="type">Char('\012')</span><span class="char">'\n'</span></span>, <span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>) ) <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]],StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'\&quot;'</a></span> <span class="typed"><span class="type">((StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,List[StdLexical.this.Elem]],StdLexical.this.Elem]) =&gt; StdLexical.this.StringLit)StdLexical.this.Parser[StdLexical.this.StringLit]</span><a href="../Parsers.scala.html#24047">^^</a></span> <span class="typed"><span class="type">StdLexical.this.StringLit</span><a href="#66558">{</a></span> <span class="typed"><span class="type">StdLexical.this.StringLit</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Char('&quot;')</span><span class="char">'\&quot;'</span></span> <a id="1">~</a> <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a id="66559">chars</a></span> <a id="1">~</a> <span class="typed"><span class="type">Char('&quot;')</span><span class="char">'\&quot;'</span></span> =&gt; <span class="typed"><span class="type">(String)StdLexical.this.StringLit</span><a href="../../syntax/StdTokens.scala.html#66518">StringLit</a></span>(<span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a href="#66559">chars</a></span> <span class="typed"><span class="type">(String)String</span><a href="../../../../Iterable.scala.html#17364">mkString</a></span> <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>) }
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022">EofCh</a></span>                                             <span class="typed"><span class="type">(object StdLexical.this.EOF)StdLexical.this.Parser[object StdLexical.this.EOF]</span><a href="../Parsers.scala.html#24050">^^^</a></span> <span class="typed"><span class="type">object StdLexical.this.EOF</span><a href="../../syntax/Tokens.scala.html#18154">EOF</a></span>
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'\''</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Nothing])StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#24032">~&gt;</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#18036">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;unclosed string literal&quot;)</span><span class="string">&quot;unclosed string literal&quot;</span></span>)        
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Product with StdLexical.this.Token])StdLexical.this.Parser[Product with StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'\&quot;'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Nothing])StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#24032">~&gt;</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#18036">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;unclosed string literal&quot;)</span><span class="string">&quot;unclosed string literal&quot;</span></span>)        
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#18142">delim</a></span>                                             
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#18036">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;illegal character&quot;)</span><span class="string">&quot;illegal character&quot;</span></span>)
    )
  
  <span class="comment">// legal identifier chars other than digits</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a id="18131">identChar</a></span> = <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18125">letter</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">(StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18021">elem</a></span>(<span class="typed"><span class="type">Char('_')</span><span class="char">'_'</span></span>)

  <span class="comment">// see `whitespace in `Scanners'</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a id="18132">whitespace</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Any] = <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[List[Any]]</span><a href="../Parsers.scala.html#18044">rep</a></span>(
      <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18128">whitespaceChar</a></span>
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'*'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem],Any]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a href="#18133">comment</a></span>
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[List[StdLexical.this.Elem]])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem],List[StdLexical.this.Elem]]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#18044">rep</a></span>( <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18127">chrExcept</a></span>(<span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>, <span class="typed"><span class="type">Char('\012')</span><span class="char">'\n'</span></span>) )
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'/'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'*'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Nothing])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem],Nothing]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[Nothing]</span><a href="../Parsers.scala.html#18036">failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;unclosed comment&quot;)</span><span class="string">&quot;unclosed comment&quot;</span></span>)
    )

  <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a id="18133">comment</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Any] = (
      <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'*'</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Elem])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (StdLexical.this.Elem)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="../Parsers.scala.html#18022" class="char">'/'</a></span>  <span class="typed"><span class="type">((StdLexical.this.~[StdLexical.this.Elem,StdLexical.this.Elem]) =&gt; Char)StdLexical.this.Parser[Char]</span><a href="../Parsers.scala.html#24047">^^</a></span> <span class="typed"><span class="type">Char</span><a href="#66758">{</a></span> <span class="typed"><span class="type">Char(' ')</span><span class="keyword">case</span></span> _ =&gt; <span class="typed"><span class="type">Char(' ')</span><span class="char">' '</span></span>  }
    <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[Any]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">(Char*)StdLexical.this.Parser[StdLexical.this.Elem]</span><a href="Lexical.scala.html#18127">chrExcept</a></span>(<span class="typed"><span class="type">Char('\032')</span><span >EofCh</span></span>) <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[Any])StdLexical.this.Parser[StdLexical.this.~[StdLexical.this.Elem,Any]]</span><a href="../Parsers.scala.html#24029">~</a></span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[Any]</span><a href="#18133">comment</a></span>
    )

  <span class="comment">/** The set of reserved identifiers: these will be returned as `Keyword's */</span>
  <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span id="18135"><a id="18134">reserved</a></span></span> = <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><a href="../../../../collection/mutable/HashSet.scala.html#11140">HashSet</a></span>[String]

  <span class="comment">/** The set of delimiters (ordering does not matter) */</span>
  <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span id="18137"><a id="18136">delimiters</a></span></span> = <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.HashSet[String]</span><a href="../../../../collection/mutable/HashSet.scala.html#11140">HashSet</a></span>[String]

  <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">(String)Product with StdLexical.this.Token</span><a id="18138">processIdent</a></span>(<span class="typed"><span class="type">String</span><a id="66409">name</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>) = 
    <span class="typed"><span class="type">&lt;refinement&gt; extends Product with StdLexical.this.Token</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; scala.collection.mutable.HashSet[String]</span><a href="#18134">reserved</a></span> <span class="typed"><span class="type">(String)Boolean</span><a href="../../../../collection/mutable/HashSet.scala.html#38147">contains</a></span> <span class="typed"><span class="type">String</span><a href="#66409">name</a></span>) <span class="typed"><span class="type">(String)StdLexical.this.Keyword</span><a href="../../syntax/StdTokens.scala.html#66413">Keyword</a></span>(<span class="typed"><span class="type">String</span><a href="#66409">name</a></span>) <span class="keyword">else</span> <span class="typed"><span class="type">(String)StdLexical.this.Identifier</span><a href="../../syntax/StdTokens.scala.html#66422">Identifier</a></span>(<span class="typed"><span class="type">String</span><a href="#66409">name</a></span>)

  <span class="keyword">private</span> <span class="keyword">var</span> <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><span id="18141"><span id="18139"><span id="18140"><a id="66366">_delim</a></span></span></span></span>: <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Token] = <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>
  <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a id="18142">delim</a></span>: <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Token] = {
    <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#18139">_delim</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5792">eq</a></span> <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>) { <span class="comment">// construct parser for delimiters by |'ing together the parsers for the individual delimiters, </span>
    <span class="comment">// starting with the longest one (hence the sort + reverse) -- otherwise a delimiter D will never be matched if </span>
    <span class="comment">// there is another delimiter that is a prefix of D   </span>
      <span class="keyword">def</span> <span class="typed"><span class="type">(String)StdLexical.this.Parser[StdLexical.this.Token]</span><a id="66768">parseDelim</a></span>(<span class="typed"><span class="type">String</span><a id="66770">s</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Token] = <span class="typed"><span class="type">(List[Char])(implicit (List[Char]) =&gt; List[StdLexical.this.Elem])StdLexical.this.Parser[List[StdLexical.this.Elem]]</span><a href="../Parsers.scala.html#18023">accept</a></span>(<span class="typed"><span class="type">implicit scala.Predef.stringWrapper : (String)scala.runtime.RichString</span><a href="../../../../Predef.scala.html#13518">s</a></span>.<span class="typed"><span class="type">=&gt; List[Char]</span><a href="../../../../Iterable.scala.html#17360">toList</a></span>) <span class="typed"><span class="type">((List[StdLexical.this.Elem]) =&gt; StdLexical.this.Keyword)StdLexical.this.Parser[StdLexical.this.Keyword]</span><a href="../Parsers.scala.html#24047">^^</a></span> { <span class="typed"><span class="type">List[StdLexical.this.Elem]</span><a id="66786">x</a></span> =&gt; <span class="typed"><span class="type">(String)StdLexical.this.Keyword</span><a href="../../syntax/StdTokens.scala.html#66413">Keyword</a></span>(<span class="typed"><span class="type">String</span><a href="#66770">s</a></span>) }
      
      <span class="keyword">val</span> <span class="typed"><span class="type">Array[String]</span><a id="66769">d</a></span> = <span class="typed"><span class="type">Array[String]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Array[String]</span><a href="../../../../Array.scala.html#1070">Array</a></span>[String](<span class="typed"><span class="type">=&gt; scala.collection.mutable.HashSet[String]</span><a href="#18136">delimiters</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="../../../../collection/mutable/FlatHashTable.scala.html#38167">size</a></span>)
      <span class="typed"><span class="type">=&gt; scala.collection.mutable.HashSet[String]</span><a href="#18136">delimiters</a></span>.<span class="typed"><span class="type">(Array[String],Int)Unit</span><a href="../../../../Iterable.scala.html#17369">copyToArray</a></span>(<span class="typed"><span class="type">Array[String]</span><a href="#66769">d</a></span>,<span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)
      scala.util.<span class="typed"><span class="type">object scala.util.Sorting</span><a href="../../../Sorting.scala.html#6703">Sorting</a></span>.<span class="typed"><span class="type">(Array[String])(implicit (String) =&gt; Ordered[String])Unit</span><a href="../../../Sorting.scala.html#66795">quickSort</a></span>(<span class="typed"><span class="type">Array[String]</span><a href="#66769">d</a></span>) 
      <span class="typed"><span class="type">(StdLexical.this.Parser[StdLexical.this.Token])Unit</span><a href="#18140">_delim</a></span> = <span class="typed"><span class="type">Array[String]</span><a href="#66769">d</a></span>.<span class="typed"><span class="type">=&gt; List[String]</span><a href="../../../../Iterable.scala.html#17360">toList</a></span>.<span class="typed"><span class="type">=&gt; List[String]</span><a href="../../../../List.scala.html#20934">reverse</a></span>.<span class="typed"><span class="type">((String) =&gt; StdLexical.this.Parser[StdLexical.this.Token])List[StdLexical.this.Parser[StdLexical.this.Token]]</span><a href="../../../../List.scala.html#20904">map</a></span>(<span class="typed"><span class="type">(String)StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#66768">parseDelim</a></span>).<span class="typed"><span class="type">((StdLexical.this.Parser[StdLexical.this.Token], StdLexical.this.Parser[StdLexical.this.Token]) =&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../../../../List.scala.html#20928">reduceRight</a></span>[<span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#18008">Parser</a></span>[Token]](<span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#66899">_</a></span> <span class="typed"><span class="type">(=&gt; StdLexical.this.Parser[StdLexical.this.Token])StdLexical.this.Parser[StdLexical.this.Token]</span><a href="../Parsers.scala.html#24041">|</a></span> <span class="typed"><span class="type">StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#66900">_</a></span>) <span class="comment">// no offence :-)      </span>
    }
    
    <span class="typed"><span class="type">=&gt; StdLexical.this.Parser[StdLexical.this.Token]</span><a href="#18139">_delim</a></span>
  }

  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T]((String) =&gt; T)(List[Char])T</span><a id="18143">lift</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18145">T</a></span>](<span class="typed"><span class="type">(String) =&gt; T</span><a id="66903">f</a></span>: String =&gt; T)(<span class="typed"><span class="type">List[Char]</span><a id="66904">xs</a></span>: <span class="typed"><span class="type">List[Char]</span><a href="../../../../List.scala.html#524">List</a></span>[Char]): <span class="typed"><span class="type">T</span><a href="#18145">T</a></span> = <span class="typed"><span class="type">(String)T</span><a href="../../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">List[Char]</span><a href="#66904">xs</a></span>.<span class="typed"><span class="type">(String,String,String)String</span><a href="../../../../Iterable.scala.html#17363">mkString</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>, <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>, <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>))

  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T]((String) =&gt; T)(StdLexical.this.~[Char,List[Char]])T</span><a id="18146">lift2</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18148">T</a></span>](<span class="typed"><span class="type">(String) =&gt; T</span><a id="66910">f</a></span>: String =&gt; T)(<span class="typed"><span class="type">StdLexical.this.~[Char,List[Char]]</span><a id="66911">p</a></span>: <span class="typed"><span class="type">StdLexical.this.~[Char,List[Char]]</span><a href="../Parsers.scala.html#18090">~</a></span>[Char, List[Char]]): <span class="typed"><span class="type">T</span><a href="#18148">T</a></span> = <span class="typed"><span class="type">((String) =&gt; T)(List[Char])T</span><a href="#18143">lift</a></span>(<span class="typed"><span class="type">(String) =&gt; T</span><a href="#66910">f</a></span>)(<span class="typed"><span class="type">StdLexical.this.~[Char,List[Char]]</span><a href="#66911">p</a></span>.<span class="typed"><span class="type">=&gt; Char</span><a href="../Parsers.scala.html#33833">_1</a></span> <span class="typed"><span class="type">(Char)List[Char]</span><a href="../../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">StdLexical.this.~[Char,List[Char]]</span><a href="#66911">p</a></span>.<span class="typed"><span class="type">=&gt; List[Char]</span><a href="../Parsers.scala.html#33835">_2</a></span>)
}

        </pre>
    </body>
</html>