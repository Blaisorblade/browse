<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/combinator/Parsers.scala</title>
        <script type="text/javascript" src="../../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
    </head>
    <body>
        <pre>
/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */

// $Id: Parsers.scala 17657 2009-05-06 15:38:18Z extempore $

<span class="keyword">package</span> scala.util.parsing.combinator

<span class="keyword">import</span> scala.util.parsing.input._
<span class="keyword">import</span> scala.collection.mutable.{Map=&gt;MutableMap}

// TODO: better error handling (labelling like parsec's &lt;?&gt;)

/** &lt;p&gt;
 *    &lt;code&gt;Parsers&lt;/code&gt; is a component that &lt;i&gt;provides&lt;/i&gt; generic
 *    parser combinators.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    It &lt;i&gt;requires&lt;/i&gt; the type of the elements these parsers should parse 
 *    (each parser is polymorphic in the type of result it produces).
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    There are two aspects to the result of a parser: (1) success or failure,
 *    and (2) the result. A &lt;code&gt;Parser[T]&lt;/code&gt; provides both kinds of
 *    information.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    The term ``parser combinator'' refers to the fact that these parsers
 *    are constructed from primitive parsers and composition operators, such
 *    as sequencing, alternation, optionality, repetition, lifting, and so on.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    A ``primitive parser'' is a parser that accepts or rejects a single
 *    piece of input, based on a certain criterion, such as whether the
 *    input...
 *  &lt;/p&gt;&lt;ul&gt;
 *    &lt;li&gt; is equal to some given object, &lt;/li&gt;
 *    &lt;li&gt; satisfies a certain predicate, &lt;/li&gt;
 *    &lt;li&gt; is in the domain of a given partial function,.... &lt;/li&gt;
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *    Even more primitive parsers always produce the same result, irrespective
 *    of the input.
 *  &lt;/p&gt;
 *
 * @requires Elem the type of elements the provided parsers consume 
 *              (When consuming invidual characters, a parser is typically called a ``scanner'', 
 *               which produces ``tokens'' that are consumed by what is normally called a ``parser''.
 *               Nonetheless, the same principles apply, regardless of the input type.)&lt;/p&gt;
 *&lt;p&gt;
 * @provides Input = Reader[Elem] 
 *              The type of input the parsers in this component expect.&lt;/p&gt;
 *&lt;p&gt;
 * @provides Parser[+T] extends (Input =&gt; ParseResult[T]) 
 *              Essentially, a `Parser[T]' is a function from `Input' to `ParseResult[T]'.&lt;/p&gt;
 *&lt;p&gt;
 * @provides ParseResult[+T] is like an `Option[T]', in the sense that it is either
 *              `Success[T]', which consists of some result (:T) (and the rest of the input) or
 *              `Failure[T]', which provides an error message (and the rest of the input).&lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */
<span class="keyword">trait</span> <a title="trait Parsers extends java.lang.Object with ScalaObject" id="12639">Parsers</a> <a href="../../../ScalaObject.scala.html#969" title="ScalaObject">{</a>
  /** the type of input elements */
  <span class="keyword">type</span> <a title="&gt;: Nothing &lt;: Any" id="57486">Elem</a>

  /** The parser input is an abstract reader of input elements */
  <span class="keyword">type</span> <a title="scala.util.parsing.input.Reader[Parsers.this.Elem]" id="57487">Input</a> = <a href="../input/Reader.scala.html#9517" title="scala.util.parsing.input.Reader[Parsers.this.Elem]">Reader</a>[Elem]

  /** A base class for parser results. 
   *  A result is either successful or not (failure may be fatal, i.e.,
   *  an Error, or not, i.e., a Failure)
   *  On success, provides a result of type &lt;code&gt;T&lt;/code&gt;. 
   */
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class ParseResult[+T] extends java.lang.Object with ScalaObject" id="57488">ParseResult</a>[+<a title="&gt;: Nothing &lt;: Any" id="57489">T</a>] <a href="../../../ScalaObject.scala.html#969" title="ScalaObject">{</a>
    /** Functional composition of ParseResults
     * 
     * @param `f' the function to be lifted over this result
     * @return `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'
     */
    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; U)Parsers.this.ParseResult[U]" id="85053">map</a>[<a title="&gt;: Nothing &lt;: Any" id="85055">U</a>](<a title="(T) =&gt; U" id="199328">f</a>: T =&gt; U): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U]
    
    /** Partial functional composition of ParseResults
     * 
     * @param `f' the partial function to be lifted over this result
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable (it is called when this is the case)
     * @return &lt;i&gt;if `f' f is defined at the result in this `ParseResult',&lt;/i&gt;
     *         `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'.
     *         If `f' is not defined, `Failure'.
     */
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U],error: (T) =&gt; String)Parsers.this.ParseResult[U]" id="85056">mapPartial</a>[<a title="&gt;: Nothing &lt;: Any" id="85058">U</a>](<a title="PartialFunction[T,U]" id="199331">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[T,U]">PartialFunction</a>[T, U], <a title="(T) =&gt; String" id="199332">error</a>: T =&gt; String): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U]   
    
    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="85059">flatMapWithNext</a>[<a title="&gt;: Nothing &lt;: Any" id="85061">U</a>](<a title="(T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]" id="199336">f</a>: T =&gt; Input =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U]     

    <span class="keyword">def</span> <a title="[U &gt;: T](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="85062">append</a>[<a title="&gt;: T &lt;: Any" id="85064">U</a> &gt;: T](<a title="=&gt; Parsers.this.ParseResult[U]" id="199339">a</a>: =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U]
    
    <span class="keyword">def</span> <a title="=&gt; Boolean" id="85065">isEmpty</a> = <span title="=&gt; Boolean">!</span><a href="#85071" title="=&gt; Boolean">successful</a>
    
    /** Returns the embedded result */
    <span class="keyword">def</span> <a title="=&gt; T" id="85066">get</a>: <a href="#57489" title="T">T</a>
    
    <span class="keyword">def</span> <a title="[B &gt;: T](default: =&gt; B)B" id="85067">getOrElse</a>[<a title="&gt;: T &lt;: Any" id="85069">B</a> &gt;: T](<a title="=&gt; B" id="199347">default</a>: =&gt; B): <a href="#85069" title="B">B</a> = 
        <span title="B" class="keyword">if</span> (<a href="#85065" title="=&gt; Boolean">isEmpty</a>) <a href="#199347" title="=&gt; B">default</a> <span class="keyword">else</span> <a href="#57488" title="ParseResult.this.type" class="keyword">this</a>.<a href="#85066" title="=&gt; T">get</a>
    
    <span class="keyword">val</span> <a title="=&gt; Parsers.this.Input" id="85070">next</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>
    
    <span class="keyword">val</span> <a title="=&gt; Boolean" id="85071">successful</a>: <a title="Boolean" id="1964">Boolean</a>
  }

  /** The success case of ParseResult: contains the result and the remaining input.
   *
   *  @param result The parser's output 
   *  @param next   The parser's remaining input
   */
  case <span class="keyword">class</span> <a title="class Success[+T] extends Parsers.this.ParseResult[T] with ScalaObject with Product" id="125344">Success</a>[+<a title="&gt;: Nothing &lt;: Any" id="125346">T</a>]<a href="../../../ScalaObject.scala.html#969" title="ScalaObject">(</a><a title="T" id="199366">result</a>: <a href="#125346" title="T">T</a>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Parsers.this.Input" id="199367">next</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) <span class="keyword">extends</span> <a href="#57488" title="Parsers.this.ParseResult[T]">ParseResult</a>[T] {
    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; U)Parsers.this.Success[U]" id="125354">map</a>[<a title="&gt;: Nothing &lt;: Any" id="125356">U</a>](<a title="(T) =&gt; U" id="199355">f</a>: T =&gt; U) = <a href="#125344" title="(result: U,next: Parsers.this.Input)Parsers.this.Success[U]">Success</a>(<a href="../../../Function1.scala.html#17226" title="(v1: T)U">f</a>(<a href="#199366" title="=&gt; T">result</a>), <a href="#199367" title="=&gt; Parsers.this.Input">next</a>)
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U],error: (T) =&gt; String)Parsers.this.ParseResult[U]" id="125357">mapPartial</a>[<a title="&gt;: Nothing &lt;: Any" id="125359">U</a>](<a title="PartialFunction[T,U]" id="199382">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[T,U]">PartialFunction</a>[T, U], <a title="(T) =&gt; String" id="199383">error</a>: T =&gt; String): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] 
       = <span title="Parsers.this.ParseResult[U]" class="keyword">if</span>(<a href="#199382" title="PartialFunction[T,U]">f</a>.<a href="../../../PartialFunction.scala.html#17178" title="(x: T)Boolean">isDefinedAt</a>(<a href="#199366" title="=&gt; T">result</a>)) <a href="#125344" title="(result: U,next: Parsers.this.Input)Parsers.this.Success[U]">Success</a>(<a href="../../../Function1.scala.html#17226" title="(v1: T)U">f</a>(<a href="#199366" title="=&gt; T">result</a>), <a href="#199367" title="=&gt; Parsers.this.Input">next</a>) 
         <span class="keyword">else</span> <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<a href="../../../Function1.scala.html#17226" title="(v1: T)String">error</a>(<a href="#199366" title="=&gt; T">result</a>), <a href="#199367" title="=&gt; Parsers.this.Input">next</a>)

    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="125360">flatMapWithNext</a>[<a title="&gt;: Nothing &lt;: Any" id="125362">U</a>](<a title="(T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]" id="199419">f</a>: T =&gt; Input =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] 
      = <a href="../../../Function1.scala.html#17226" title="(v1: T)(Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]">f</a><a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[U]">(</a><a href="#199366" title="=&gt; T">result</a>)(<a href="#199367" title="=&gt; Parsers.this.Input">next</a>) 

    <span class="keyword">def</span> <a title="[U &gt;: T](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="125363">append</a>[<a title="&gt;: T &lt;: Any" id="125365">U</a> &gt;: T](<a title="=&gt; Parsers.this.ParseResult[U]" id="199431">a</a>: =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] = <a href="#125344" title="Parsers.this.Success[T]" class="keyword">this</a>

    <span class="keyword">def</span> <a title="=&gt; T" id="125366">get</a>: <a href="#125346" title="T">T</a> = <a href="#199366" title="=&gt; T">result</a>
    
    /** The toString method of a Success */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="125367">toString</a> = <span title="(x$1: Any)java.lang.String" class="string">&quot;[&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#199367" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;] parsed: &quot;)" class="string">&quot;] parsed: &quot;</span>+<a href="#199366" title="=&gt; T">result</a>
    
    <span class="keyword">val</span> <a title="Boolean" id="125368">successful</a> = <span title="Boolean(true)" class="keyword">true</span>
  }

  <span class="keyword">var</span> <a title="Parsers.this.NoSuccess" id="57495">lastNoSuccess</a>: <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a> = <span title="Null(null)" class="keyword">null</span>

  /** A common super-class for unsuccessful parse results
   */
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class NoSuccess extends Parsers.this.ParseResult[Nothing] with ScalaObject" id="57497">NoSuccess</a><a href="../../../ScalaObject.scala.html#969" title="ScalaObject">(</a><span class="keyword">val</span> <a title="String" id="199514">msg</a>: <span title="String">String</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a title="Parsers.this.Input" id="199515">next</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) <span class="keyword">extends</span> <a href="#57488" title="Parsers.this.ParseResult[Nothing]">ParseResult</a>[Nothing] { // when we don't care about the difference between Failure and Error
    <span class="keyword">val</span> <a title="Boolean" id="85079">successful</a> = <span title="Boolean(false)" class="keyword">false</span>
    <span title="Unit" class="keyword">if</span> (<span title="=&gt; Boolean">!</span>(<a href="#57495" title="(x$1: AnyRef)Boolean" id="6592">lastNoSuccess</a> <span title="(x$1: Boolean)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> &amp;&amp; <a href="#199515" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Position.scala.html#23157" title="(that: scala.util.parsing.input.Position)Boolean">pos</a> &lt; <a href="#57495" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>.<a href="#199515" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>))
      <a href="#57495" title="(x$1: Parsers.this.NoSuccess)Unit">lastNoSuccess</a> = <a href="#57497" title="Parsers.this.NoSuccess" class="keyword">this</a>

    <span class="keyword">def</span> <a title="[U](f: (Nothing) =&gt; U)Parsers.this.NoSuccess" id="85081">map</a>[<a title="&gt;: Nothing &lt;: Any" id="85083">U</a>](<a title="(Nothing) =&gt; U" id="199532">f</a>: Nothing =&gt; U) = <a href="#57497" title="Parsers.this.NoSuccess" class="keyword">this</a>
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[Nothing,U],error: (Nothing) =&gt; String)Parsers.this.ParseResult[U]" id="85084">mapPartial</a>[<a title="&gt;: Nothing &lt;: Any" id="85086">U</a>](<a title="PartialFunction[Nothing,U]" id="199544">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[Nothing,U]">PartialFunction</a>[Nothing, U], <a title="(Nothing) =&gt; String" id="199545">error</a>: Nothing =&gt; String): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] = <a href="#57497" title="Parsers.this.NoSuccess" class="keyword">this</a>

    <span class="keyword">def</span> <a title="[U](f: (Nothing) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="85087">flatMapWithNext</a>[<a title="&gt;: Nothing &lt;: Any" id="85089">U</a>](<a title="(Nothing) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]" id="199555">f</a>: Nothing =&gt; Input =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] 
      = <a href="#57497" title="Parsers.this.NoSuccess" class="keyword">this</a>

    <span class="keyword">def</span> <a title="=&gt; Nothing" id="85090">get</a>: <a title="Nothing" id="3635">Nothing</a> = <a href="../../../Predef.scala.html#16315" title="(message: String)Nothing">error</a>(<span title="java.lang.String(&quot;No result when parsing failed&quot;)" class="string">&quot;No result when parsing failed&quot;</span>)
  }
  /** An extractor so NoSuccess(msg, next) can be used in matches
   *  Note: case class inheritance is currently sketchy and may be
   *  deprecated, so an explicit extractor is better.
   */
  <span class="keyword">object</span> <a title="object Parsers.this.NoSuccess" id="57498">NoSuccess</a> <a href="../../../ScalaObject.scala.html#969" title="ScalaObject">{</a>
    <span class="keyword">def</span> <a title="[T](x: Parsers.this.ParseResult[T])Option[(String, Parsers.this.Input)]" id="199567">unapply</a>[<a title="&gt;: Nothing &lt;: Any" id="199569">T</a>](<a title="Parsers.this.ParseResult[T]" id="199573">x</a>: <a href="#57488" title="Parsers.this.ParseResult[T]">ParseResult</a>[T]) = <a href="#199573" title="Parsers.this.ParseResult[T]">x</a> <span title="Option[(String, Parsers.this.Input)]" class="keyword">match</span> {
      <span title="Some[(String, Parsers.this.Input)]" class="keyword">case</span> Failure(<a title="String" id="199576">msg</a>, <a title="Parsers.this.Input" id="199577">next</a>)   =&gt; <a href="../../../Option.scala.html#19907" title="(x: (String, Parsers.this.Input))Some[(String, Parsers.this.Input)]">Some</a><a href="../../../Tuple2.scala.html#20777" title="(_1: String,_2: Parsers.this.Input)(String, Parsers.this.Input)">(</a><a href="#199576" title="String">msg</a>, <a href="#199577" title="Parsers.this.Input">next</a>)
      <span title="Some[(String, Parsers.this.Input)]" class="keyword">case</span> Error(<a title="String" id="199593">msg</a>, <a title="Parsers.this.Input" id="199594">next</a>)     =&gt; <a href="../../../Option.scala.html#19907" title="(x: (String, Parsers.this.Input))Some[(String, Parsers.this.Input)]">Some</a><a href="../../../Tuple2.scala.html#20777" title="(_1: String,_2: Parsers.this.Input)(String, Parsers.this.Input)">(</a><a href="#199593" title="String">msg</a>, <a href="#199594" title="Parsers.this.Input">next</a>)
      <span title="None.type" class="keyword">case</span> _                    =&gt; <a href="../../../Option.scala.html#472" title="object None">None</a>
    }
  }
  
  /** The failure case of ParseResult: contains an error-message and the remaining input.
   * Parsing will back-track when a failure occurs.
   *
   *  @param msg    An error message string describing the failure.
   *  @param next   The parser's unconsumed input at the point where the failure occurred.
   */
  case <span class="keyword">class</span> <a title="class Failure extends Parsers.this.NoSuccess with ScalaObject with Product" id="85051">Failure</a><a href="../../../ScalaObject.scala.html#969" title="ScalaObject">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a href="#199514" title="String" id="85104">msg</a>: <span title="String">String</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a href="#199515" title="Parsers.this.Input" id="85105">next</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) <span class="keyword">extends</span> <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a>(<a href="#85104" title="String">msg</a>, <a href="#85105" title="Parsers.this.Input">next</a>) {
    /** The toString method of a Failure yields an error message */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="85098">toString</a> = <span title="(x$1: Any)java.lang.String" class="string">&quot;[&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#85105" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;] failure: &quot;)" class="string">&quot;] failure: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#85104" title="=&gt; String">msg</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;\012\012&quot;)" class="string">&quot;\n\n&quot;</span>+<a href="#85105" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>.<a href="../input/Position.scala.html#23156" title="=&gt; java.lang.String">longString</a>
    
    <span class="keyword">def</span> <a title="[U](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="85099">append</a>[<a title="&gt;: Nothing &lt;: Any" id="85101">U</a> &gt;: Nothing](<a title="=&gt; Parsers.this.ParseResult[U]" id="199652">a</a>: =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] = { <span class="keyword">val</span> <a title="Parsers.this.ParseResult[U]" id="199659">alt</a> = <a href="#199652" title="=&gt; Parsers.this.ParseResult[U]">a</a>; <a href="#199659" title="Parsers.this.ParseResult[U]">alt</a> <span title="Parsers.this.ParseResult[U]" class="keyword">match</span> {
      <span title="Parsers.this.ParseResult[U]" class="keyword">case</span> Success(_, _) =&gt; <a href="#199659" title="Parsers.this.ParseResult[U]">alt</a>
      <span title="Parsers.this.ParseResult[U]" class="keyword">case</span> <a title="Parsers.this.NoSuccess" id="199664">ns</a>: <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> (<a href="#199659" title="Parsers.this.ParseResult[U]">alt</a>.<a href="#85070" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Position.scala.html#23157" title="(that: scala.util.parsing.input.Position)Boolean">pos</a> &lt; <a href="#85105" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>) <a href="#85051" title="Parsers.this.Failure" class="keyword">this</a> <span class="keyword">else</span> <a href="#199659" title="Parsers.this.ParseResult[U]">alt</a>
    }}
  }
  
  /** The fatal failure case of ParseResult: contains an error-message and the remaining input.
   * No back-tracking is done when a parser returns an `Error' 
   *
   *  @param msg    An error message string describing the error.
   *  @param next   The parser's unconsumed input at the point where the error occurred.
   */
  case <span class="keyword">class</span> <a title="class Error extends Parsers.this.NoSuccess with ScalaObject with Product" id="137264">Error</a><a href="../../../ScalaObject.scala.html#969" title="ScalaObject">(</a><span class="keyword">override</span> <span class="keyword">val</span> <a href="#199514" title="String" id="200058">msg</a>: <span title="String">String</span>, <span class="keyword">override</span> <span class="keyword">val</span> <a href="#199515" title="Parsers.this.Input" id="200059">next</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) <span class="keyword">extends</span> <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a>(<a href="#200058" title="String">msg</a>, <a href="#200059" title="Parsers.this.Input">next</a>) {
    /** The toString method of an Error yields an error message */
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="137272">toString</a> = <span title="(x$1: Any)java.lang.String" class="string">&quot;[&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#200059" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;] error: &quot;)" class="string">&quot;] error: &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#200058" title="=&gt; String">msg</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;\012\012&quot;)" class="string">&quot;\n\n&quot;</span>+<a href="#200059" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>.<a href="../input/Position.scala.html#23156" title="=&gt; java.lang.String">longString</a>
    <span class="keyword">def</span> <a title="[U](a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]" id="137273">append</a>[<a title="&gt;: Nothing &lt;: Any" id="137275">U</a> &gt;: Nothing](<a title="=&gt; Parsers.this.ParseResult[U]" id="199741">a</a>: =&gt; ParseResult[U]): <a href="#57488" title="Parsers.this.ParseResult[U]">ParseResult</a>[U] = <a href="#137264" title="Parsers.this.Error" class="keyword">this</a>
  }
  

  <span class="keyword">def</span> <a title="[T](f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]" id="57506">Parser</a>[<a title="&gt;: Nothing &lt;: Any" id="57508">T</a>](<a title="(Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]" id="85043">f</a>: Input =&gt; ParseResult[T]): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] 
    = <a href="#199804" title="Parsers.this.Parser[T]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[T]" id="199804">Parser</a>[T]{ <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="199806">apply</a>(<a title="Parsers.this.Input" id="199810">in</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) = <a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">f</a>(<a href="#199810" title="Parsers.this.Input">in</a>) }
  
  <span class="keyword">def</span> <a title="[T](f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" id="57509">OnceParser</a>[<a title="&gt;: Nothing &lt;: Any" id="57511">T</a>](<a title="(Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]" id="199820">f</a>: Input =&gt; ParseResult[T]): <a href="#199821" title="&lt;refinement&gt; extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]">Parser</a>[T] <span class="keyword">with</span> OnceParser[T] 
    = <a href="#199829" title="Parsers.this.Parser[T] with Parsers.this.OnceParser[T]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]" id="199829">Parser</a>[T] <span class="keyword">with</span> <a href="#57602" title="Parsers.this.OnceParser[T]">OnceParser</a>[T] { <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="199831">apply</a>(<a title="Parsers.this.Input" id="199836">in</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) = <a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">f</a>(<a href="#199836" title="Parsers.this.Input">in</a>) }
  
  /** The root class of parsers. 
   *  Parsers are functions from the Input type to ParseResult 
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class Parser[+T] extends java.lang.Object with (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T] with ScalaObject" id="57512">Parser</a>[+<a title="&gt;: Nothing &lt;: Any" id="57513">T</a>] <a href="../../../ScalaObject.scala.html#969" title="ScalaObject" class="keyword">extends</a> (Input =&gt; ParseResult[T]) {
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="String" id="57677">name</a>: <span title="String">String</span> = <span title="java.lang.String(&quot;&quot;)" class="string">&quot;&quot;</span>
    <span class="keyword">def</span> <a title="(n: String)Parser.this.type" id="57679">named</a>(<a title="String" id="199850">n</a>: <span title="String">String</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = {<a href="#57677" title="(x$1: String)Unit">name</a>=<a href="#199850" title="String">n</a>; <a href="#57512" title="Parser.this.type" class="keyword">this</a>}
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="57680">toString</a>() = <span title="(x$1: Any)java.lang.String" class="string">&quot;Parser (&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#57677" title="=&gt; String">name</a> +<span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
    
    /** An unspecified method that defines the behaviour of this parser.
     */
    <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="57681">apply</a>(<a title="Parsers.this.Input" id="125327">in</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>): <a href="#57488" title="Parsers.this.ParseResult[T]">ParseResult</a>[T]

    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57682">flatMap</a>[<a title="&gt;: Nothing &lt;: Any" id="57684">U</a>](<a title="(T) =&gt; Parsers.this.Parser[U]" id="199860">f</a>: T =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U]
      = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a>{ <a title="Parsers.this.Input" id="199866">in</a> =&gt; <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><a href="#85059" title="(f: (T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]">(</a><a href="#199866" title="Parsers.this.Input">in</a>) flatMapWithNext(<a href="#199860" title="(T) =&gt; Parsers.this.Parser[U]">f</a>)}
                                      
    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; U)Parsers.this.Parser[U]" id="57685">map</a>[<a title="&gt;: Nothing &lt;: Any" id="57687">U</a>](<a title="(T) =&gt; U" id="199886">f</a>: T =&gt; U): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] //= flatMap{x =&gt; success(f(x))}
      = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a>{ <a title="Parsers.this.Input" id="199892">in</a> =&gt; <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><a href="#85053" title="(f: (T) =&gt; U)Parsers.this.ParseResult[U]">(</a><a href="#199892" title="Parsers.this.Input">in</a>) map(<a href="#199886" title="(T) =&gt; U">f</a>)}

    // no filter yet, dealing with zero is tricky!
  
    <span class="keyword">def</span> <a title="[U &gt;: T](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57688">append</a>[<a title="&gt;: T &lt;: Any" id="57690">U</a> &gt;: T](<a title="=&gt; Parsers.this.Parser[U]" id="199912">p</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] 
      = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a>{ <a title="Parsers.this.Input" id="199918">in</a> =&gt; <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a><a href="#85062" title="(a: =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]">(</a><a href="#199918" title="Parsers.this.Input">in</a>) append <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]">p</a>(<a href="#199918" title="Parsers.this.Input">in</a>)}

                                      
    // the operator formerly known as +++, ++, &amp;, but now, behold the venerable ~
    // it's short, light (looks like whitespace), has few overloaded meaning (thanks to the recent change from ~ to unary_~)
    // and we love it! (or do we like `,` better?)
                                      
    /** A parser combinator for sequential composition 
     *
     * &lt;p&gt; `p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails.
     */
    <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="57691">~</a> [<a title="&gt;: Nothing &lt;: Any" id="57693">U</a>](<a title="=&gt; Parsers.this.Parser[U]" id="125753">p</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a>[~[T, U]] = (<span class="keyword">for</span>(<a title="T" id="199952">a</a> &lt;- <a href="#57682" title="(f: (T) =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]" class="keyword">this</a>; <a title="U" id="199957">b</a> &lt;- <a href="#57685" title="(f: (U) =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]">p</a>) <span class="keyword">yield</span> <span title="Parsers.this.~[T,U]" class="keyword">new</span> <a href="#125520" title="Parsers.this.~[T,U]">~</a>(<a href="#199952" title="T">a</a>,<a href="#199957" title="U">b</a>)).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a>(<span title="java.lang.String(&quot;~&quot;)" class="string">&quot;~&quot;</span>)

    /** A parser combinator for sequential composition which keeps only the right result 
     *
     * &lt;p&gt; `p ~&gt; q' succeeds if `p' succeeds and `q' succeeds on the input
     *           left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `q'.
     */
    <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57694">~&gt;</a> [<a title="&gt;: Nothing &lt;: Any" id="57696">U</a>](<a title="=&gt; Parsers.this.Parser[U]" id="125645">p</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = (<span class="keyword">for</span>(<a title="T" id="199980">a</a> &lt;- <a href="#57682" title="(f: (T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" class="keyword">this</a>; <a title="U" id="199985">b</a> &lt;- <a href="#57685" title="(f: (U) =&gt; U)Parsers.this.Parser[U]">p</a>) <span class="keyword">yield</span> <a href="#199985" title="U">b</a>).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a>(<span title="java.lang.String(&quot;~&gt;&quot;)" class="string">&quot;~&gt;&quot;</span>)

    /** A parser combinator for sequential composition which keeps only the left result 
     *
     * &lt;p&gt; `p &amp;lt;~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *           left over by `p'.&lt;/p&gt;
     * 
     * &lt;b&gt;Note:&lt;/b&gt; &amp;lt;~ has lower operator precedence than ~ or ~&gt;.
     *
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `p'.
     */
    <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[T]" id="57697">&lt;~</a> [<a title="&gt;: Nothing &lt;: Any" id="57699">U</a>](<a title="=&gt; Parsers.this.Parser[U]" id="125822">p</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] = (<span class="keyword">for</span>(<a title="T" id="200000">a</a> &lt;- <a href="#57682" title="(f: (T) =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" class="keyword">this</a>; <a title="U" id="200005">b</a> &lt;- <a href="#57685" title="(f: (U) =&gt; T)Parsers.this.Parser[T]">p</a>) <span class="keyword">yield</span> <a href="#200000" title="T">a</a>).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[T]">named</a>(<span title="java.lang.String(&quot;&lt;~&quot;)" class="string">&quot;&lt;~&quot;</span>)

     /* not really useful: V cannot be inferred because Parser is covariant in first type parameter (V is always trivially Nothing)
    def ~~ [U, V](q: =&gt; Parser[U])(implicit combine: (T, U) =&gt; V): Parser[V] = new Parser[V] {
      def apply(in: Input) = seq(Parser.this, q)((x, y) =&gt; combine(x,y))(in)
    }  */   

    /** A parser combinator for non-back-tracking sequential composition 
     *
     *&lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails, this failure is fatal.
     */
    <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="57700">~!</a> [<a title="&gt;: Nothing &lt;: Any" id="57702">U</a>](<a title="=&gt; Parsers.this.Parser[U]" id="200017">p</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a>[~[T, U]] 
      = <a href="#57509" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]">OnceParser</a>{ (<span class="keyword">for</span>(<a title="T" id="200027">a</a> &lt;- <a href="#57682" title="(f: (T) =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]" class="keyword">this</a>; <a title="U" id="200144">b</a> &lt;- <a href="#57521" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">commit</a><a href="#57685" title="(f: (U) =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]">(</a><a href="#200017" title="=&gt; Parsers.this.Parser[U]">p</a>)) <span class="keyword">yield</span> <span title="Parsers.this.~[T,U]" class="keyword">new</span> <a href="#125520" title="Parsers.this.~[T,U]">~</a>(<a href="#200027" title="T">a</a>,<a href="#200144" title="U">b</a>)).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a>(<span title="java.lang.String(&quot;~!&quot;)" class="string">&quot;~!&quot;</span>) }
        
    /** A parser combinator for alternative composition 
     *
     *&lt;p&gt;`p | q' succeeds if `p' succeeds or `q' succeeds
     *          Note that `q' is only tried if `p's failure is non-fatal (i.e., back-tracking is
     *          allowed).&lt;/p&gt;
     * 
     * @param q a parser that will be executed if `p' (this parser) fails (and allows back-tracking)
     * @return a `Parser' that returns the result of the first parser to succeed (out of `p' and `q')
     *         The resulting parser succeeds if (and only if) &lt;ul&gt;
     *           &lt;li&gt; `p' succeeds, &lt;i&gt;or&lt;/i&gt;  &lt;/li&gt;
     *           &lt;li&gt; if `p' fails allowing back-tracking and `q' succeeds. &lt;/li&gt; &lt;/ul&gt;
     */
    <span class="keyword">def</span> <a title="[U &gt;: T](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57703">|</a> [<a title="&gt;: T &lt;: Any" id="57705">U</a> &gt;: T](<a title="=&gt; Parsers.this.Parser[U]" id="125837">q</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57688" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">append</a>(<a href="#125837" title="=&gt; Parsers.this.Parser[U]">q</a>).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a>(<span title="java.lang.String(&quot;|&quot;)" class="string">&quot;|&quot;</span>)

    // TODO
    /** A parser combinator for alternative with longest match composition 
     *
     *&lt;p&gt;`p ||| q' succeeds if `p' succeeds or `q' succeeds
     *          If `p' and `q' both succeed, the parser that consumed the most
     *          characters accepts.&lt;/p&gt;
     * 
     * @param q a parser that accepts if p consumes less characters.
     * @return a `Parser' that returns the result of the parser consuming the most characteres (out of `p' and `q').
     */
    <span class="keyword">def</span> <a title="[U &gt;: T](q: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57706">|||</a> [<a title="&gt;: T &lt;: Any" id="57708">U</a> &gt;: T](<a title="=&gt; Parsers.this.Parser[U]" id="200179">q</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#200182" title="Parsers.this.Parser[U]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[U]" id="200182">Parser</a>[U] {
      <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]" id="200184">apply</a>(<a title="Parsers.this.Input" id="200189">in</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) = {
        <span class="keyword">val</span> <a title="Parsers.this.ParseResult[T]" id="200194">res1</a> = <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">Parser</a>.<span class="keyword">this</span>(<a href="#200189" title="Parsers.this.Input">in</a>)
        <span class="keyword">val</span> <a title="Parsers.this.ParseResult[U]" id="200195">res2</a> = <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[U]">q</a>(<a href="#200189" title="Parsers.this.Input">in</a>)
        
        <a href="../../../Tuple2.scala.html#20777" title="(_1: Parsers.this.ParseResult[T],_2: Parsers.this.ParseResult[U])(Parsers.this.ParseResult[T], Parsers.this.ParseResult[U])">(</a><a href="#200194" title="Parsers.this.ParseResult[T]">res1</a>, <a href="#200195" title="Parsers.this.ParseResult[U]">res2</a>) <span title="Parsers.this.ParseResult[U]" class="keyword">match</span> {
          <span title="Parsers.this.ParseResult[U]" class="keyword">case</span> (<a title="Parsers.this.Success[T]" id="200226">s1</a> @ Success(_, <a title="Parsers.this.Input" id="200229">next1</a>), <a title="Parsers.this.Success[U]" id="200232">s2</a> @ Success(_, <a title="Parsers.this.Input" id="200235">next2</a>)) =&gt; <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> (<a href="#200235" title="Parsers.this.Input">next2</a>.<a href="../input/Position.scala.html#23157" title="(that: scala.util.parsing.input.Position)Boolean">pos</a> &lt; <a href="#200229" title="Parsers.this.Input">next1</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>) <a href="#200226" title="Parsers.this.Success[T]">s1</a> <span class="keyword">else</span> <a href="#200232" title="Parsers.this.Success[U]">s2</a>
          <span title="Parsers.this.Success[T]" class="keyword">case</span> (<a title="Parsers.this.Success[T]" id="200244">s1</a> @ Success(_, _), _) =&gt; <a href="#200244" title="Parsers.this.Success[T]">s1</a>
          <span title="Parsers.this.Success[U]" class="keyword">case</span> (_, <a title="Parsers.this.Success[U]" id="200253">s2</a> @ Success(_, _)) =&gt; <a href="#200253" title="Parsers.this.Success[U]">s2</a>
          <span title="Parsers.this.Error" class="keyword">case</span> (<a title="Parsers.this.Error" id="200262">e1</a> @ Error(_, _), _) =&gt; <a href="#200262" title="Parsers.this.Error">e1</a>
          <span title="Parsers.this.ParseResult[U]" class="keyword">case</span> (<a title="Parsers.this.Failure" id="200269">f1</a> @ Failure(_, <a title="Parsers.this.Input" id="200270">next1</a>), <a title="Parsers.this.ParseResult[U]" id="200273">ns2</a> @ <a href="#199567" title="(x: Parsers.this.ParseResult[U])Option[(String, Parsers.this.Input)]">NoSuccess</a>(_, <a title="Parsers.this.Input" id="200282">next2</a>)) =&gt; <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> (<a href="#200282" title="Parsers.this.Input">next2</a>.<a href="../input/Position.scala.html#23157" title="(that: scala.util.parsing.input.Position)Boolean">pos</a> &lt; <a href="#200270" title="Parsers.this.Input">next1</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>) <a href="#200269" title="Parsers.this.Failure">f1</a> <span class="keyword">else</span> <a href="#200273" title="Parsers.this.ParseResult[U]">ns2</a>
        }
      }
      <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="200185">toString</a> = <span title="java.lang.String(&quot;|||&quot;)" class="string">&quot;|||&quot;</span>
    }

    /** A parser combinator for function application 
     *
     *&lt;p&gt;`p ^^ f' succeeds if `p' succeeds; it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a function that will be applied to this parser's result (see `map' in `ParseResult').
     * @return a parser that has the same behaviour as the current parser, but whose result is
     *         transformed by `f'.
     */
    <span class="keyword">def</span> <a title="[U](f: (T) =&gt; U)Parsers.this.Parser[U]" id="57709">^^</a> [<a title="&gt;: Nothing &lt;: Any" id="57711">U</a>](<a title="(T) =&gt; U" id="125784">f</a>: T =&gt; U): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57685" title="(f: (T) =&gt; U)Parsers.this.Parser[U]">map</a>(<a href="#125784" title="(T) =&gt; U">f</a>).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a>(<a href="#57680" title="(x$1: Any)java.lang.String">toString</a>+<span title="java.lang.String(&quot;^^&quot;)" class="string">&quot;^^&quot;</span>)
    

    <span class="keyword">def</span> <a title="[U](r: U)Parsers.this.Parser[U]" id="57712">^^^</a> [<a title="&gt;: Nothing &lt;: Any" id="57714">U</a>](<a title="U" id="126950">r</a>: <a href="#57714" title="U">U</a>): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57709" title="(f: (T) =&gt; U)Parsers.this.Parser[U]">^^</a> (<a title="T" id="200310">x</a> =&gt; <a href="#126950" title="U">r</a>)
    
    /** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? (f, error)' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'. If `f' is not applicable,
     *  error(the result of `p') should explain why.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U],error: (T) =&gt; String)Parsers.this.Parser[U]" id="57715">^?</a> [<a title="&gt;: Nothing &lt;: Any" id="57717">U</a>](<a title="PartialFunction[T,U]" id="200314">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[T,U]">PartialFunction</a>[T, U], <a title="(T) =&gt; String" id="200315">error</a>: T =&gt; String): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a>{ <a title="Parsers.this.Input" id="200322">in</a> =&gt;
      <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" class="keyword">this</a>(<a href="#200322" title="Parsers.this.Input">in</a>).<a href="#85056" title="(f: PartialFunction[T,U],error: (T) =&gt; String)Parsers.this.ParseResult[U]">mapPartial</a>(<a href="#200314" title="PartialFunction[T,U]">f</a>, <a href="#200315" title="(T) =&gt; String">error</a>)}.<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[U]">named</a>(<a href="#57680" title="(x$1: Any)java.lang.String">toString</a>+<span title="java.lang.String(&quot;^?&quot;)" class="string">&quot;^?&quot;</span>)
     
    /** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? f' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */
    <span class="keyword">def</span> <a title="[U](f: PartialFunction[T,U])Parsers.this.Parser[U]" id="57718">^?</a> [<a title="&gt;: Nothing &lt;: Any" id="57720">U</a>](<a title="PartialFunction[T,U]" id="200354">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[T,U]">PartialFunction</a>[T, U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57715" title="(f: PartialFunction[T,U],error: (T) =&gt; String)Parsers.this.Parser[U]">^?</a>(<a href="#200354" title="PartialFunction[T,U]">f</a>, <a title="T" id="200382">r</a> =&gt; <span title="(x$1: Any)java.lang.String" class="string">&quot;Constructor function not defined at &quot;</span>+<a href="#200382" title="T">r</a>)
    
       
    /** A parser combinator that parameterises a subsequent parser with the result of this one
     *
     *&lt;p&gt;
     * Use this combinator when a parser depends on the result of a previous parser. `p' should be
     * a function that takes the result from the first parser and returns the second parser.&lt;/p&gt;
     *
     *&lt;p&gt; `p into fq' (with `fq' typically `{x =&gt; q}') first applies `p', and then, if `p' successfully  
     *    returned result `r', applies `fq(r)' to the rest of the input. &lt;/p&gt;
     *
     *&lt;p&gt; From: G. Hutton. Higher-order functions for parsing. J. Funct. Program., 2(3):323--343, 1992. &lt;/p&gt;
     *
     * @param fq a function that, given the result from this parser, returns the second parser to be applied
     * @return a parser that succeeds if this parser succeeds (with result `x') and if then `fq(x)' succeeds
     */
    <span class="keyword">def</span> <a title="[U](fq: (T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57721">into</a>[<a title="&gt;: Nothing &lt;: Any" id="57723">U</a>](<a title="(T) =&gt; Parsers.this.Parser[U]" id="200389">fq</a>: T =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57682" title="(f: (T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">flatMap</a>(<a href="#200389" title="(T) =&gt; Parsers.this.Parser[U]">fq</a>)
    
    // shortcuts for combinators:
    
    /** Returns into(fq) */
    <span class="keyword">def</span> <a title="[U](fq: (T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]" id="57724">&gt;&gt;</a>[<a title="&gt;: Nothing &lt;: Any" id="57726">U</a>](<a title="(T) =&gt; Parsers.this.Parser[U]" id="200397">fq</a>: T =&gt; Parser[U])=<a href="#57721" title="(fq: (T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">into</a>(<a href="#200397" title="(T) =&gt; Parsers.this.Parser[U]">fq</a>)
    
    
    /** Returns a parser that repeatedly parses what this parser parses
     *
     * @return rep(this) 
     */
    <span class="keyword">def</span> <a title="=&gt; Parsers.this.Parser[List[T]]" id="57727">*</a> = <a href="#57548" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep</a>(<a href="#57512" title="Parsers.this.Parser[T]" class="keyword">this</a>)
    
    /** Returns a parser that repeatedly parses what this parser parses, interleaved with the `sep' parser.
     * The `sep' parser specifies how the results parsed by this parser should be combined.
     *
     * @return chainl1(this, sep) 
     */    
    <span class="keyword">def</span> <a title="[U &gt;: T](sep: =&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]" id="57728">*</a>[<a title="&gt;: T &lt;: Any" id="57730">U</a> &gt;: T](<a title="=&gt; Parsers.this.Parser[(U, U) =&gt; U]" id="200414">sep</a>: =&gt; Parser[(U, U) =&gt; U]) = <a href="#57566" title="(p: =&gt; Parsers.this.Parser[U],q: =&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]">chainl1</a>(<a href="#57512" title="Parsers.this.Parser[T]" class="keyword">this</a>, <a href="#200414" title="=&gt; Parsers.this.Parser[(U, U) =&gt; U]">sep</a>)
    
    // TODO: improve precedence? a ~ b*(&quot;,&quot;) = a ~ (b*(&quot;,&quot;))  should be true 
    
    /** Returns a parser that repeatedly (at least once) parses what this parser parses.
     *
     * @return rep1(this) 
     */      
    <span class="keyword">def</span> <a title="=&gt; Parsers.this.Parser[List[T]]" id="57731">+</a> = <a href="#57554" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a>(<a href="#57512" title="Parsers.this.Parser[T]" class="keyword">this</a>)
    
    /** Returns a parser that optionally parses what this parser parses.
     *
     * @return opt(this) 
     */       
    <span class="keyword">def</span> <a title="=&gt; Parsers.this.Parser[Option[T]]" id="57732">?</a> = <a href="#57579" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]">opt</a>(<a href="#57512" title="Parsers.this.Parser[T]" class="keyword">this</a>)
  }

  // TODO: can this implemented in ParseResult, like map?
  /** A helper method for sequential composition of (unit-)parsers
  */
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="[T, U, V](p: =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],q: =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])(compose: (T, U) =&gt; V)(in: Parsers.this.Input)Parsers.this.ParseResult[V]" id="57514">seq</a>[<a title="&gt;: Nothing &lt;: Any" id="57518">T</a>, <a title="&gt;: Nothing &lt;: Any" id="57519">U</a>, <a title="&gt;: Nothing &lt;: Any" id="57520">V</a>](<a title="=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]" id="200474">p</a>: =&gt; Input =&gt; ParseResult[T], <a title="=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]" id="200475">q</a>: =&gt; Input =&gt; ParseResult[U])
                          (<a title="(T, U) =&gt; V" id="200476">compose</a>: (T, U) =&gt; V)
                          (<a title="Parsers.this.Input" id="200477">in</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>): <a href="#57488" title="Parsers.this.ParseResult[V]">ParseResult</a>[V] 
    = <a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#200477" title="Parsers.this.Input">in</a>) <span title="Parsers.this.ParseResult[V]" class="keyword">match</span> {
      <span title="Parsers.this.ParseResult[V]" class="keyword">case</span> Success(<a title="T" id="200487">x</a>, <a title="Parsers.this.Input" id="200488">next1</a>) =&gt; <a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Input)Parsers.this.ParseResult[U]">q</a>(<a href="#200488" title="Parsers.this.Input">next1</a>) <span title="Parsers.this.ParseResult[V]" class="keyword">match</span> {
          <span title="Parsers.this.Success[V]" class="keyword">case</span> Success(<a title="U" id="200496">y</a>, <a title="Parsers.this.Input" id="200497">next2</a>) =&gt; <a href="#125344" title="(result: V,next: Parsers.this.Input)Parsers.this.Success[V]">Success</a>(<a href="../../../Function2.scala.html#20550" title="(v1: T,v2: U)V">compose</a>(<a href="#200487" title="T">x</a>, <a href="#200496" title="U">y</a>), <a href="#200497" title="Parsers.this.Input">next2</a>)
          <span title="Parsers.this.NoSuccess" class="keyword">case</span> <a title="Parsers.this.NoSuccess" id="200511">ns</a>: <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <a href="#200511" title="Parsers.this.NoSuccess">ns</a>
        }
      <span title="Parsers.this.NoSuccess" class="keyword">case</span> <a title="Parsers.this.NoSuccess" id="200512">ns</a>: <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <a href="#200512" title="Parsers.this.NoSuccess">ns</a>
    }
  
  /** Wrap a parser so that its failures become errors (the | combinator will give up as soon as 
   *  it encounters an error, on failure it simply tries the next alternative) 
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="57521">commit</a>[<a title="&gt;: Nothing &lt;: Any" id="57523">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="200028">p</a>: =&gt; Parser[T]) = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a>{ <a title="Parsers.this.Input" id="200034">in</a> =&gt;
    <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#200034" title="Parsers.this.Input">in</a>) <span title="&lt;refinement&gt; extends Product with Parsers.this.ParseResult[T]" class="keyword">match</span>{
      <span title="Parsers.this.Success[T]" class="keyword">case</span> <a title="Parsers.this.Success[T]" id="200045">s</a> @ Success(_, _) =&gt; <a href="#200045" title="Parsers.this.Success[T]">s</a>
      <span title="Parsers.this.Error" class="keyword">case</span> <a title="Parsers.this.Error" id="200050">e</a> @ Error(_, _) =&gt; <a href="#200050" title="Parsers.this.Error">e</a>
      <span title="Parsers.this.Error" class="keyword">case</span> <a title="Parsers.this.Failure" id="200053">f</a> @ Failure(<a title="String" id="200054">msg</a>, <a title="Parsers.this.Input" id="200055">next</a>) =&gt; <a href="#137264" title="(msg: String,next: Parsers.this.Input)Parsers.this.Error">Error</a>(<a href="#200054" title="String">msg</a>, <a href="#200055" title="Parsers.this.Input">next</a>)
    }
  }
  
	/*trait ElemFun
  case class EFCons(hd: Elem =&gt; ElemFun, tl: ElemFun) extends ElemFun
  case class EFNil(res: Boolean) extends ElemFun*/

   
  /** A parser matching input elements that satisfy a given predicate
   *
   * &lt;p&gt;elem(kind, p) succeeds if the input starts with an element `e' for which p(e) is true.&lt;/p&gt;
   *
   * @param  kind   The element kind, used for error messages
   * @param  p      A predicate that determines which elements match.
   * @return 
   */
  <span class="keyword">def</span> <a title="(kind: String,p: (Parsers.this.Elem) =&gt; Boolean)Parsers.this.Parser[Parsers.this.Elem]" id="57524">elem</a>(<a title="String" id="57652">kind</a>: <span title="String">String</span>, <a title="(Parsers.this.Elem) =&gt; Boolean" id="57653">p</a>: Elem =&gt; Boolean) = <a href="#57533" title="(p: (Parsers.this.Elem) =&gt; Boolean)(err: (Parsers.this.Elem) =&gt; String)Parsers.this.Parser[Parsers.this.Elem]">acceptIf</a>(<a href="#57653" title="(Parsers.this.Elem) =&gt; Boolean">p</a>)(<a title="Parsers.this.Elem" id="57662">inEl</a> =&gt; <a href="#57652" title="(x$1: Any)java.lang.String">kind</a>+<span title="java.lang.String(&quot; expected&quot;)" class="string">&quot; expected&quot;</span>)
   
  /** A parser that matches only the given element `e'
   *
   * &lt;p&gt;elem(e) succeeds if the input starts with an element `e'&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `Parser' that succeeds if `e' is the next available input (and returns it).
   */
  <span class="keyword">def</span> <a title="(e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]" id="57525">elem</a>(<a title="Parsers.this.Elem" id="57633">e</a>: <a href="#57486" title="Parsers.this.Elem">Elem</a>): <a href="#57512" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a>[Elem] = <a href="#57526" title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]">accept</a>(<a href="#57633" title="Parsers.this.Elem">e</a>)
  
  
  /** A parser that matches only the given element `e' 
   *&lt;p&gt;
   * The method is implicit so that elements can automatically be lifted to their parsers. 
   * For example, when parsing `Token's, Identifier(&quot;new&quot;) (which is a `Token') can be used directly,
   * instead of first creating a `Parser' using accept(Identifier(&quot;new&quot;)).&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `tParser' that succeeds if `e' is the next available input.
   */
   
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]" id="57526">accept</a>(<a title="Parsers.this.Elem" id="57637">e</a>: <a href="#57486" title="Parsers.this.Elem">Elem</a>): <a href="#57512" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a>[Elem] = <a href="#57533" title="(p: (Parsers.this.Elem) =&gt; Boolean)(err: (Parsers.this.Elem) =&gt; String)Parsers.this.Parser[Parsers.this.Elem]">acceptIf</a>(<a href="#200527" title="(x$1: Any)Boolean">_</a> == <a href="#57637" title="Parsers.this.Elem">e</a>)(<span title="(x$1: Any)java.lang.String" class="string">&quot;`&quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#57637" title="Parsers.this.Elem">e</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;' expected but &quot;)" class="string">&quot;' expected but &quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#200533" title="Parsers.this.Elem">_</a> + <span title="java.lang.String(&quot; found&quot;)" class="string">&quot; found&quot;</span>)
  
  /** A parser that matches only the given list of element `es'
   *
   * &lt;p&gt;accept(es) succeeds if the input subsequently provides the elements in the list `es'.&lt;/p&gt;
   *
   * @param  es the list of expected elements
   * @return a Parser that recognizes a specified list of elements
   */
  <span class="keyword">def</span> <a title="[ES](es: ES)(implicit evidence$1: (ES) =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]" id="125719">accept</a>[<a title="&gt;: Nothing &lt;: Any" id="57529">ES</a> &lt;% List[Elem]](<a title="ES" id="125718">es</a>: <a href="#57529" title="ES">ES</a>): <a href="#57512" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a>[List[Elem]] = <a href="#200545" title="(es: ES)(implicit evidence$2: (ES) =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]">acceptSeq</a><a href="#125719" title="(ES) =&gt; List[Parsers.this.Elem]">(</a><a href="#125718" title="ES">es</a>)

  /** The parser that matches an element in the domain of the partial function `f'
   *&lt;p&gt;
   * If `f' is defined on the first element in the input, `f' is applied to it to produce 
   * this parser's result.&lt;/p&gt;
   *&lt;p&gt;
   * Example: The parser &lt;code&gt;accept(&quot;name&quot;, {case Identifier(n) =&gt; Name(n)})&lt;/code&gt; 
   *          accepts an &lt;code&gt;Identifier(n)&lt;/code&gt; and returns a &lt;code&gt;Name(n)&lt;/code&gt;.&lt;/p&gt;
   *
   * @param expected a description of the kind of element this parser expects (for error messages)
   * @param f a partial function that determines when this parser is successful and what its output is
   * @return A parser that succeeds if `f' is applicable to the first element of the input, 
   *         applying `f' to it to produce the result.
   */
  <span class="keyword">def</span> <a title="[U](expected: String,f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]" id="57530">accept</a>[<a title="&gt;: Nothing &lt;: Any" id="57532">U</a>](<a title="String" id="125708">expected</a>: <span title="String">String</span>, <a title="PartialFunction[Parsers.this.Elem,U]" id="125709">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[Parsers.this.Elem,U]">PartialFunction</a>[Elem, U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57534" title="(expected: String,f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]">acceptMatch</a>(<a href="#125708" title="String">expected</a>, <a href="#125709" title="PartialFunction[Parsers.this.Elem,U]">f</a>)


  <span class="keyword">def</span> <a title="(p: (Parsers.this.Elem) =&gt; Boolean)(err: (Parsers.this.Elem) =&gt; String)Parsers.this.Parser[Parsers.this.Elem]" id="57533">acceptIf</a>(<a title="(Parsers.this.Elem) =&gt; Boolean" id="57656">p</a>: Elem =&gt; Boolean)(<a title="(Parsers.this.Elem) =&gt; String" id="57657">err</a>: Elem =&gt; String): <a href="#57512" title="Parsers.this.Parser[Parsers.this.Elem]">Parser</a>[Elem] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Parsers.this.Elem])Parsers.this.Parser[Parsers.this.Elem]">Parser</a> { <a title="Parsers.this.Input" id="200587">in</a> =&gt;
    <span title="Parsers.this.ParseResult[Parsers.this.Elem]" class="keyword">if</span> (<a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Elem)Boolean">p</a>(<a href="#200587" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21997" title="=&gt; Parsers.this.Elem">first</a>)) <a href="#125344" title="(result: Parsers.this.Elem,next: Parsers.this.Input)Parsers.this.Success[Parsers.this.Elem]">Success</a>(<a href="#200587" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21997" title="=&gt; Parsers.this.Elem">first</a>, <a href="#200587" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21998" title="=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]">rest</a>)
    <span class="keyword">else</span> <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Elem)String">err</a>(<a href="#200587" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21997" title="=&gt; Parsers.this.Elem">first</a>), <a href="#200587" title="Parsers.this.Input">in</a>)
  }
  
  <span class="keyword">def</span> <a title="[U](expected: String,f: PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]" id="57534">acceptMatch</a>[<a title="&gt;: Nothing &lt;: Any" id="57536">U</a>](<a title="String" id="200572">expected</a>: <span title="String">String</span>, <a title="PartialFunction[Parsers.this.Elem,U]" id="200573">f</a>: <a href="../../../PartialFunction.scala.html#1098" title="PartialFunction[Parsers.this.Elem,U]">PartialFunction</a>[Elem, U]): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]">Parser</a>{ <a title="Parsers.this.Input" id="200617">in</a> =&gt; 
    <span title="Parsers.this.ParseResult[U]" class="keyword">if</span> (<a href="#200573" title="PartialFunction[Parsers.this.Elem,U]">f</a>.<a href="../../../PartialFunction.scala.html#17178" title="(x: Parsers.this.Elem)Boolean">isDefinedAt</a>(<a href="#200617" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21997" title="=&gt; Parsers.this.Elem">first</a>)) <a href="#125344" title="(result: U,next: Parsers.this.Input)Parsers.this.Success[U]">Success</a>(<a href="../../../Function1.scala.html#17226" title="(v1: Parsers.this.Elem)U">f</a>(<a href="#200617" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21997" title="=&gt; Parsers.this.Elem">first</a>), <a href="#200617" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#21998" title="=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]">rest</a>)
    <span class="keyword">else</span> <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<a href="#200572" title="(x$1: Any)java.lang.String">expected</a>+<span title="java.lang.String(&quot; expected&quot;)" class="string">&quot; expected&quot;</span>, <a href="#200617" title="Parsers.this.Input">in</a>)
  }
  
  <span class="keyword">def</span> <a title="[ES](es: ES)(implicit evidence$2: (ES) =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]" id="200545">acceptSeq</a>[<a title="&gt;: Nothing &lt;: Any" id="57539">ES</a> &lt;% Iterable[Elem]](<a title="ES" id="200544">es</a>: <a href="#57539" title="ES">ES</a>): <a href="#57512" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a>[List[Elem]] = <a href="../../../Function1.scala.html#17226" title="(v1: ES)Iterable[Parsers.this.Elem]">es</a>.<a href="../../../collection/generic/IterableTemplate.scala.html#17398" title="[B](z: B)(op: (Parsers.this.Elem, B) =&gt; B)B">foldRight</a><span title="(z: Parsers.this.Parser[List[Parsers.this.Elem]])(op: (Parsers.this.Elem, Parsers.this.Parser[List[Parsers.this.Elem]]) =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[List[Parsers.this.Elem]]">[</span><a href="#57512" title="Parsers.this.Parser[List[Parsers.this.Elem]]">Parser</a>[List[Elem]]](<a href="#57542" title="(v: object Nil)Parsers.this.Parser[object Nil]">success</a>(<a href="../../../collection/immutable/List.scala.html#9334" title="object Nil">Nil</a>)){(<a title="Parsers.this.Elem" id="200710">x</a>, <a title="Parsers.this.Parser[List[Parsers.this.Elem]]" id="200711">pxs</a>) =&gt; <a href="#57526" title="implicit scala.util.parsing.combinator.Parsers.accept : (e: Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]">accept</a><a href="#57691" title="(p: =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]]">(</a><a href="#200710" title="Parsers.this.Elem">x</a>) <a href="#57709" title="(f: (Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]) =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]">~</a> <a href="#200711" title="Parsers.this.Parser[List[Parsers.this.Elem]]">pxs</a> ^^ <a href="#57594" title="(Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]) =&gt; List[Parsers.this.Elem]">mkList</a>}

  /** A parser that always fails 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */
  <span class="keyword">def</span> <a title="(msg: String)Parsers.this.Parser[Nothing]" id="57540">failure</a>(<a title="String" id="85040">msg</a>: <span title="String">String</span>) = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]">Parser</a>{ <a title="Parsers.this.Input" id="85049">in</a> =&gt; <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<a href="#85040" title="String">msg</a>, <a href="#85049" title="Parsers.this.Input">in</a>) }

  /** A parser that results in an error 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */  
  <span class="keyword">def</span> <a title="(msg: String)Parsers.this.Parser[Nothing]" id="57541">err</a>(<a title="String" id="200775">msg</a>: <span title="String">String</span>) = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]">Parser</a>{ <a title="Parsers.this.Input" id="200781">in</a> =&gt; <a href="#137264" title="(msg: String,next: Parsers.this.Input)Parsers.this.Error">Error</a>(<a href="#200775" title="String">msg</a>, <a href="#200781" title="Parsers.this.Input">in</a>) }


  /** A parser that always succeeds 
   *
   * @param v The result for the parser
   * @return A parser that always succeeds, with the given result `v'
   */
  <span class="keyword">def</span> <a title="[T](v: T)Parsers.this.Parser[T]" id="57542">success</a>[<a title="&gt;: Nothing &lt;: Any" id="57544">T</a>](<a title="T" id="200679">v</a>: <a href="#57544" title="T">T</a>) = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a>{ <a title="Parsers.this.Input" id="200685">in</a> =&gt; <a href="#125344" title="(result: T,next: Parsers.this.Input)Parsers.this.Success[T]">Success</a>(<a href="#200679" title="T">v</a>, <a href="#200685" title="Parsers.this.Input">in</a>) }

  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])(name: String)Parsers.this.Parser[T]" id="57545">log</a>[<a title="&gt;: Nothing &lt;: Any" id="57547">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="200795">p</a>: =&gt; Parser[T])(<a title="String" id="200796">name</a>: <span title="String">String</span>): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a>{ <a title="Parsers.this.Input" id="200802">in</a> =&gt;
    <a href="../../../Predef.scala.html#16446" title="(x: Any)Unit">println</a>(<span title="(x$1: Any)java.lang.String" class="string">&quot;trying &quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#200796" title="String">name</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; at &quot;)" class="string">&quot; at &quot;</span>+ <a href="#200802" title="Parsers.this.Input">in</a>)
    <span class="keyword">val</span> <a title="Parsers.this.ParseResult[T]" id="200803">r</a> = <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#200802" title="Parsers.this.Input">in</a>)
    <a href="../../../Predef.scala.html#16446" title="(x: Any)Unit">println</a>(<a href="#200796" title="(x$1: Any)java.lang.String">name</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot; --&gt; &quot;)" class="string">&quot; --&gt; &quot;</span>+ <a href="#200803" title="Parsers.this.ParseResult[T]">r</a>)
    <a href="#200803" title="Parsers.this.ParseResult[T]">r</a>
  } 

  
  /** A parser generator for repetitions.
   *  
   * &lt;p&gt; rep(p)   repeatedly uses `p' to parse the input until `p' fails (the result is a List 
   *  of the consecutive results of `p') &lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input.
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="57548">rep</a>[<a title="&gt;: Nothing &lt;: Any" id="57550">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="126477">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[List[T]]">Parser</a>[List[T]] = <a href="#57554" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a><a href="#57703" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]">(</a><a href="#126477" title="=&gt; Parsers.this.Parser[T]">p</a>) | <a href="#57542" title="(v: List[Nothing])Parsers.this.Parser[List[Nothing]]">success</a>(List<a href="../../../collection/immutable/List.scala.html#9334" title="object Nil">(</a>))

  /** A parser generator for interleaved repetitions.
   *  
   * &lt;p&gt; repsep(p, q)   repeatedly uses `p' interleaved with `q' to parse the input, until `p' fails.
   *  (The result is a `List' of the results of `p'.) &lt;/p&gt;
   *
   * &lt;p&gt;Example: &lt;code&gt;repsep(term, &quot;,&quot;)&lt;/code&gt; parses a comma-separated list of term's, 
   *          yielding a list of these terms&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `Parser' that parses the elements that separate the elements parsed by `p'
   * @return A parser that returns a list of results produced by repeatedly applying `p' (interleaved
   *         with `q') to the input. 
   *         The results of `p' are collected in a list. The results of `q' are discarded.    
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T],q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]" id="57551">repsep</a>[<a title="&gt;: Nothing &lt;: Any" id="57553">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="125689">p</a>: =&gt; Parser[T], <a title="=&gt; Parsers.this.Parser[Any]" id="125690">q</a>: =&gt; Parser[Any]): <a href="#57512" title="Parsers.this.Parser[List[T]]">Parser</a>[List[T]] = 
    <a href="#57563" title="(p: =&gt; Parsers.this.Parser[T],q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]">rep1sep</a><a href="#57703" title="(q: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]">(</a><a href="#125689" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#125690" title="=&gt; Parsers.this.Parser[Any]">q</a>) | <a href="#57542" title="(v: List[Nothing])Parsers.this.Parser[List[Nothing]]">success</a>(List<a href="../../../collection/immutable/List.scala.html#9334" title="object Nil">(</a>))
  
  /** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(p) repeatedly uses `p' to parse the input until `p' fails -- `p' must succeed at least
   *             once (the result is a `List' of the consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches at least once).
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="57554">rep1</a>[<a title="&gt;: Nothing &lt;: Any" id="57556">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="140358">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[List[T]]">Parser</a>[List[T]] = <a href="#57557" title="(first: =&gt; Parsers.this.Parser[T],p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep1</a>(<a href="#140358" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#140358" title="=&gt; Parsers.this.Parser[T]">p</a>)
  
  /** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(f, p) first uses `f' (which must succeed) and then repeatedly uses `p' to 
   *     parse the input until `p' fails 
   *     (the result is a `List' of the consecutive results of `f' and `p')&lt;/p&gt;
   *
   * @param first a `Parser' that parses the first piece of input
   * @param p a `Parser' that is to be applied successively to the rest of the input (if any)
   * @return A parser that returns a list of results produced by first applying `f' and then 
   *         repeatedly `p' to the input (it only succeeds if `f' matches).
   */
  <span class="keyword">def</span> <a title="[T](first: =&gt; Parsers.this.Parser[T],p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="57557">rep1</a>[<a title="&gt;: Nothing &lt;: Any" id="57559">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="140348">first</a>: =&gt; Parser[T], <a title="=&gt; Parsers.this.Parser[T]" id="140349">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[List[T]]">Parser</a>[List[T]] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[List[T]])Parsers.this.Parser[List[T]]">Parser</a>{ <a title="Parsers.this.Input" id="200943">in0</a> =&gt;
    <span class="keyword">val</span> <a title="scala.collection.mutable.ListBuffer[T]" id="200944">xs</a> = <span title="scala.collection.mutable.ListBuffer[T]" class="keyword">new</span> scala.collection.mutable.<a href="../../../collection/mutable/ListBuffer.scala.html#7683" title="scala.collection.mutable.ListBuffer[T]">ListBuffer</a>[T]
    <span class="keyword">var</span> <a title="Parsers.this.Input" id="200945">in</a> = <a href="#200943" title="Parsers.this.Input">in0</a>

    <span class="keyword">var</span> <a title="Parsers.this.ParseResult[T]" id="200946">res</a> = <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">first</a>(<a href="#200945" title="Parsers.this.Input">in</a>)

    <span title="Unit" class="keyword">while</span>(<a href="#200946" title="Parsers.this.ParseResult[T]">res</a>.<a href="#85071" title="=&gt; Boolean">successful</a>) <a href="#200947" title="()Unit">{</a>
      <a href="../../../collection/mutable/ListBuffer.scala.html#46655" title="(x: T)xs.type">xs</a> += <a href="#200946" title="Parsers.this.ParseResult[T]">res</a>.<a href="#85066" title="=&gt; T">get</a>
      <a href="#200945" title="Parsers.this.Input">in</a> = <a href="#200946" title="Parsers.this.ParseResult[T]">res</a>.<a href="#85070" title="=&gt; Parsers.this.Input">next</a>
      <a href="#200946" title="Parsers.this.ParseResult[T]">res</a> = <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#200945" title="Parsers.this.Input">in</a>)
    }

    // assert(res.isInstanceOf[NoSuccess])

    <a href="#200946" title="Parsers.this.ParseResult[T]">res</a> <span title="Parsers.this.ParseResult[List[T]]" class="keyword">match</span> {
      <span title="Parsers.this.Error" class="keyword">case</span> <a title="Parsers.this.Error" id="201003">e</a>: <a href="#137264" title="Parsers.this.Error">Error</a> =&gt; <a href="#201003" title="Parsers.this.Error">e</a>
      <span title="Parsers.this.ParseResult[List[T]]" class="keyword">case</span> _  =&gt; 
        <span title="Parsers.this.ParseResult[List[T]]" class="keyword">if</span> (<span title="=&gt; Boolean">!</span><a href="#200944" title="scala.collection.mutable.ListBuffer[T]">xs</a>.<a href="../../../collection/generic/TraversableForwarder.scala.html#46703" title="=&gt; Boolean">isEmpty</a>) {
          // the next parser should start parsing where p failed, 
          // since `!p(in).successful', the next input to be consumed is `in'
          <a href="#125344" title="(result: List[T],next: Parsers.this.Input)Parsers.this.Success[List[T]]">Success</a>(<a href="#200944" title="scala.collection.mutable.ListBuffer[T]">xs</a>.<a href="../../../collection/mutable/ListBuffer.scala.html#46661" title="=&gt; List[T]">toList</a>, <a href="#200945" title="Parsers.this.Input">in</a>)  // TODO: I don't think in == res.next holds
        }
        <span class="keyword">else</span> {
          <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<a href="#200946" title="Parsers.this.ParseResult[T]">res</a>.<span title="[T0]T0">asInstanceOf</span><span title="Parsers.this.NoSuccess">[</span><a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a>].<a href="#199514" title="=&gt; String">msg</a>, <a href="#200943" title="Parsers.this.Input">in0</a>)
        }
    }
  }
  
  //= first ~ rep(p) ^^ { case ~(x, xs) =&gt; x :: xs }
  

  /** A parser generator for a specified number of repetitions.
   *  
   * &lt;p&gt; repN(n, p)  uses `p' exactly `n' time to parse the input 
   *       (the result is a `List' of the `n' consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param n the exact number of times `p' must succeed
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches exactly `n' times).
   */  
  <span class="keyword">def</span> <a title="[T](n: Int,p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]" id="57560">repN</a>[<a title="&gt;: Nothing &lt;: Any" id="57562">T</a>](<a title="Int" id="201028">n</a>: <a title="Int" id="2190">Int</a>, <a title="=&gt; Parsers.this.Parser[T]" id="201029">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[List[T]]">Parser</a>[List[T]] = 
    <span title="Parsers.this.Parser[List[T]]" class="keyword">if</span>(<a href="#201028" title="(x$1: Int)Boolean" id="2965">n</a>==<span title="Int(0)" class="int">0</span>) <a href="#57542" title="(v: object Nil)Parsers.this.Parser[object Nil]">success</a>(<a href="../../../collection/immutable/List.scala.html#9334" title="object Nil">Nil</a>) <span class="keyword">else</span> <a href="#57691" title="(p: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[T,List[T]]]">p</a> <a href="#57709" title="(f: (Parsers.this.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]">~</a> <a href="#57560" title="(n: Int,p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">repN</a>(<a href="#201028" title="(x$1: Int)Int" id="2979">n</a>-<span title="Int(1)" class="int">1</span>, <a href="#201029" title="=&gt; Parsers.this.Parser[T]">p</a>) ^^ <a href="#201083" title="List[T]">{</a> <span title="List[T]" class="keyword">case</span> ~(<a title="T" id="201086">x</a>, <a title="List[T]" id="201087">xs</a>) =&gt; <a href="#201086" title="T">x</a> <a href="#201090" title="T">::</a> <a href="../../../collection/immutable/List.scala.html#17737" title="(x: T)List[T]">xs</a> }
  
  /** A parser generator for non-empty repetitions.
   *  
   *  &lt;p&gt;rep1sep(p, q) repeatedly applies `p' interleaved with `q' to parse the input, until `p' fails.
   *                The parser `p' must succeed at least once.&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `Parser' that parses the elements that separate the elements parsed by `p' 
   *          (interleaved with `q')   
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *         (and that only succeeds if `p' matches at least once).
   *         The results of `p' are collected in a list. The results of `q' are discarded.    
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T],q: =&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]" id="57563">rep1sep</a>[<a title="&gt;: Nothing &lt;: Any" id="57565">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="200874">p</a> : =&gt; Parser[T], <a title="=&gt; Parsers.this.Parser[Any]" id="200875">q</a> : =&gt; Parser[Any]): <a href="#57512" title="Parsers.this.Parser[List[T]]">Parser</a>[List[T]] = 
    <a href="#57691" title="(p: =&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[T,List[T]]]">p</a> <a href="#57709" title="(f: (Parsers.this.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]">~</a> <a href="#57548" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]">rep</a>(<a href="#57694" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]">q</a> ~&gt; <a href="#200874" title="=&gt; Parsers.this.Parser[T]">p</a>) ^^ <a href="#201125" title="List[T]">{</a><span title="List[T]" class="keyword">case</span> <a title="T" id="201128">x</a>~<a title="List[T]" id="201129">y</a> =&gt; <a href="#201128" title="T">x</a><a href="#201132" title="T">::</a><a href="../../../collection/immutable/List.scala.html#17737" title="(x: T)List[T]">y</a>} 
   

  /** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * &lt;p&gt; From: J. Fokker. Functional parsers. In J. Jeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, pages 1--23. Springer, 1995.&lt;/p&gt;
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T],q: =&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]" id="57566">chainl1</a>[<a title="&gt;: Nothing &lt;: Any" id="57568">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="200432">p</a>: =&gt; Parser[T], <a title="=&gt; Parsers.this.Parser[(T, T) =&gt; T]" id="200433">q</a>: =&gt; Parser[(T, T) =&gt; T]): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T]  
    = <a href="#57569" title="(first: =&gt; Parsers.this.Parser[T],p: =&gt; Parsers.this.Parser[T],q: =&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]">chainl1</a>(<a href="#200432" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#200432" title="=&gt; Parsers.this.Parser[T]">p</a>, <a href="#200433" title="=&gt; Parsers.this.Parser[(T, T) =&gt; T]">q</a>)

  /** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * @param first a parser that parses the first element
   * @param p a parser that parses the subsequent elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */
  <span class="keyword">def</span> <a title="[T, U](first: =&gt; Parsers.this.Parser[T],p: =&gt; Parsers.this.Parser[U],q: =&gt; Parsers.this.Parser[(T, U) =&gt; T])Parsers.this.Parser[T]" id="57569">chainl1</a>[<a title="&gt;: Nothing &lt;: Any" id="57572">T</a>, <a title="&gt;: Nothing &lt;: Any" id="57573">U</a>](<a title="=&gt; Parsers.this.Parser[T]" id="200420">first</a>: =&gt; Parser[T], <a title="=&gt; Parsers.this.Parser[U]" id="200421">p</a>: =&gt; Parser[U], <a title="=&gt; Parsers.this.Parser[(T, U) =&gt; T]" id="200422">q</a>: =&gt; Parser[(T, U) =&gt; T]): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] 
    = <a href="#57691" title="(p: =&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]]]">first</a> <a href="#57709" title="(f: (Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]]) =&gt; T)Parsers.this.Parser[T]">~</a> <a href="#57548" title="(p: =&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]]">rep</a>(<a href="#57691" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]]">q</a> ~ <a href="#200421" title="=&gt; Parsers.this.Parser[U]">p</a>) ^^ <a href="#201183" title="T">{</a>
        <span title="T" class="keyword">case</span> <a title="T" id="201186">x</a> ~ <a title="List[Parsers.this.~[(T, U) =&gt; T,U]]" id="201187">xs</a> =&gt; <a href="#201187" title="List[Parsers.this.~[(T, U) =&gt; T,U]]">xs</a>.<a href="../../../collection/generic/LinearSequenceTemplate.scala.html#19516" title="(z: T)(f: (T, Parsers.this.~[(T, U) =&gt; T,U]) =&gt; T)T">foldLeft</a>(<a href="#201186" title="T">x</a>){<a href="../../../Tuple2.scala.html#20777" title="(_1: T,_2: Parsers.this.~[(T, U) =&gt; T,U])(T, Parsers.this.~[(T, U) =&gt; T,U])">(</a><a href="#201205" title="T">_</a>, <a href="#201206" title="Parsers.this.~[(T, U) =&gt; T,U]">_</a>) <span title="T" class="keyword">match</span> {<span title="T" class="keyword">case</span> (<a title="T" id="201217">a</a>, <a title="(T, U) =&gt; T" id="201220">f</a> ~ <a title="U" id="201221">b</a>) =&gt; <a href="../../../Function2.scala.html#20550" title="(v1: T,v2: U)T">f</a>(<a href="#201217" title="T">a</a>, <a href="#201221" title="U">b</a>)}}
      }
        
  /** A parser generator that generalises the rep1sep generator so that `q', which parses the separator,
   * produces a right-associative function that combines the elements it separates. Additionally,
   * The right-most (last) element and the left-most combinating function have to be supplied.
   * 
   * rep1sep(p: Parser[T], q) corresponds to chainr1(p, q ^^ cons, cons, Nil) (where val cons = (x: T, y: List[T]) =&gt; x :: y)
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a right-associative function that 
   *          combines two elements into one 
   * @param combine the &quot;last&quot; (left-most) combination function to be applied
   * @param first   the &quot;first&quot; (right-most) element to be combined
   */
  <span class="keyword">def</span> <a title="[T, U](p: =&gt; Parsers.this.Parser[T],q: =&gt; Parsers.this.Parser[(T, U) =&gt; U],combine: (T, U) =&gt; U,first: U)Parsers.this.Parser[U]" id="57574">chainr1</a>[<a title="&gt;: Nothing &lt;: Any" id="57577">T</a>, <a title="&gt;: Nothing &lt;: Any" id="57578">U</a>](<a title="=&gt; Parsers.this.Parser[T]" id="201235">p</a>: =&gt; Parser[T], <a title="=&gt; Parsers.this.Parser[(T, U) =&gt; U]" id="201236">q</a>: =&gt; Parser[(T, U) =&gt; U], <a title="(T, U) =&gt; U" id="201237">combine</a>: (T, U) =&gt; U, <a title="U" id="201238">first</a>: <a href="#57578" title="U">U</a>): <a href="#57512" title="Parsers.this.Parser[U]">Parser</a>[U]
    = <a href="#57691" title="(p: =&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]]]">p</a> <a href="#57709" title="(f: (Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]]) =&gt; U)Parsers.this.Parser[U]">~</a> <a href="#57548" title="(p: =&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]]">rep</a>(<a href="#57691" title="(p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]]">q</a> ~ <a href="#201235" title="=&gt; Parsers.this.Parser[T]">p</a>) ^^ <a href="#201263" title="U">{</a>
        <span title="U" class="keyword">case</span> <a title="T" id="201266">x</a> ~ <a title="List[Parsers.this.~[(T, U) =&gt; U,T]]" id="201267">xs</a> =&gt; (<span title="Parsers.this.~[(T, U) =&gt; U,T]" class="keyword">new</span> <a href="#125520" title="Parsers.this.~[(T, U) =&gt; U,T]">~</a>(<a href="#201237" title="(T, U) =&gt; U">combine</a>, <a href="#201266" title="T">x</a>) <a href="#201270" title="Parsers.this.~[(T, U) =&gt; U,T]">::</a> <a href="../../../collection/immutable/List.scala.html#17737" title="(x: Parsers.this.~[(T, U) =&gt; U,T])List[Parsers.this.~[(T, U) =&gt; U,T]]">xs</a>).
                            <a href="../../../collection/generic/LinearSequenceTemplate.scala.html#19519" title="(z: U)(f: (Parsers.this.~[(T, U) =&gt; U,T], U) =&gt; U)U">foldRight</a>(<a href="#201238" title="U">first</a>){<a href="../../../Tuple2.scala.html#20777" title="(_1: Parsers.this.~[(T, U) =&gt; U,T],_2: U)(Parsers.this.~[(T, U) =&gt; U,T], U)">(</a><a href="#201306" title="Parsers.this.~[(T, U) =&gt; U,T]">_</a>, <a href="#201307" title="U">_</a>) <span title="U" class="keyword">match</span> {<span title="U" class="keyword">case</span> (<a title="(T, U) =&gt; U" id="201320">f</a> ~ <a title="T" id="201321">a</a>, <a title="U" id="201324">b</a>) =&gt; <a href="../../../Function2.scala.html#20550" title="(v1: T,v2: U)U">f</a>(<a href="#201321" title="T">a</a>, <a href="#201324" title="U">b</a>)}}
      }
    
  /** A parser generator for optional sub-phrases.
   *  
   *  &lt;p&gt;opt(p) is a parser that returns `Some(x)' if `p' returns `x' and `None' if `p' fails&lt;/p&gt;
   *
   * @param p A `Parser' that is tried on the input
   * @return a `Parser' that always succeeds: either with the result provided by `p' or 
   *         with the empty result
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]" id="57579">opt</a>[<a title="&gt;: Nothing &lt;: Any" id="57581">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="140152">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[Option[T]]">Parser</a>[Option[T]] = 
    <a href="#57709" title="(f: (T) =&gt; Some[T])Parsers.this.Parser[Some[T]]">p</a> <a href="#57703" title="(q: =&gt; Parsers.this.Parser[Option[T]])Parsers.this.Parser[Option[T]]">^^</a> (<a title="T" id="201340">x</a> =&gt; <a href="../../../Option.scala.html#19907" title="(x: T)Some[T]">Some</a>(<a href="#201340" title="T">x</a>)) | <a href="#57542" title="(v: object None)Parsers.this.Parser[object None]">success</a>(<a href="../../../Option.scala.html#472" title="object None">None</a>)

  /** Wrap a parser so that its failures&amp;errors become success and vice versa -- it never consumes any input 
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[Unit]" id="57582">not</a>[<a title="&gt;: Nothing &lt;: Any" id="57584">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="201384">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[Unit]">Parser</a>[Unit] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])Parsers.this.Parser[Unit]">Parser</a> { <a title="Parsers.this.Input" id="201390">in</a> =&gt;
    <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#201390" title="Parsers.this.Input">in</a>) <span title="Parsers.this.ParseResult[Unit]" class="keyword">match</span> {
      <span title="Parsers.this.Failure" class="keyword">case</span> Success(_, _)  =&gt; <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<span title="java.lang.String(&quot;Expected failure&quot;)" class="string">&quot;Expected failure&quot;</span>, <a href="#201390" title="Parsers.this.Input">in</a>)
      <span title="Parsers.this.Success[Unit]" class="keyword">case</span> _              =&gt; <a href="#125344" title="(result: Unit,next: Parsers.this.Input)Parsers.this.Success[Unit]">Success</a>(<span title="Unit">(</span>), <a href="#201390" title="Parsers.this.Input">in</a>)
    }
  }  

  /** A parser generator for guard expressions. The resulting parser will fail or succeed 
   * just like the one given as parameter but it will not consume any input.
   *
   * @param p a `Parser' that is to be applied to the input
   * @return A parser that returns success if and only if 'p' succeeds but never consumes any input
   */
  <span class="keyword">def</span> <a title="[T](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="57585">guard</a>[<a title="&gt;: Nothing &lt;: Any" id="57587">T</a>](<a title="=&gt; Parsers.this.Parser[T]" id="201425">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a> { <a title="Parsers.this.Input" id="201431">in</a> =&gt;
    <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#201431" title="Parsers.this.Input">in</a>) <span title="Parsers.this.ParseResult[T]" class="keyword">match</span>{
      <span title="Parsers.this.Success[T]" class="keyword">case</span> <a title="Parsers.this.Success[T]" id="201442">s</a>@ Success(<a title="T" id="201445">s1</a>,_) =&gt; <a href="#125344" title="(result: T,next: Parsers.this.Input)Parsers.this.Success[T]">Success</a>(<a href="#201445" title="T">s1</a>, <a href="#201431" title="Parsers.this.Input">in</a>)
      <span title="Parsers.this.ParseResult[T]" class="keyword">case</span> <a title="Parsers.this.ParseResult[T]" id="201455">e</a> =&gt; <a href="#201455" title="Parsers.this.ParseResult[T]">e</a>
    }
  }

  
  /** `positioned' decorates a parser's result with the start position of the input it consumed. 
   * 
   * @param p a `Parser' whose result conforms to `Positional'.
   * @return A parser that has the same behaviour as `p', but which marks its result with the 
   *         start position of the input it consumed, if it didn't already have a position.
   */
  <span class="keyword">def</span> <a title="[T &lt;: scala.util.parsing.input.Positional](p: =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]" id="57588">positioned</a>[<a title="&gt;: Nothing &lt;: scala.util.parsing.input.Positional" id="57590">T</a> &lt;: Positional](<a title="=&gt; Parsers.this.Parser[T]" id="201459">p</a>: =&gt; Parser[T]): <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] = <a href="#57506" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]">Parser</a> { <a title="Parsers.this.Input" id="201465">in</a> =&gt;
    <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#201465" title="Parsers.this.Input">in</a>) <span title="Parsers.this.ParseResult[T]" class="keyword">match</span> {
      <span title="Parsers.this.Success[T]" class="keyword">case</span> Success(<a title="T" id="201478">t</a>, <a title="Parsers.this.Input" id="201479">in1</a>) =&gt; <a href="#125344" title="(result: T,next: Parsers.this.Input)Parsers.this.Success[T]">Success</a>(<span title="T" class="keyword">if</span> (<a href="#201478" title="T">t</a>.<a href="../input/Positional.scala.html#139705" title="(x$1: AnyRef)Boolean">pos</a> == <a href="../input/NoPosition.scala.html#9524" title="object scala.util.parsing.input.NoPosition">NoPosition</a>) <a href="../input/Positional.scala.html#139708" title="(newpos: scala.util.parsing.input.Position)t.type">t</a> setPos <a href="#201465" title="Parsers.this.Input">in</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a> <span class="keyword">else</span> <a href="#201478" title="T">t</a>, <a href="#201479" title="Parsers.this.Input">in1</a>)
      <span title="Parsers.this.NoSuccess" class="keyword">case</span> <a title="Parsers.this.NoSuccess" id="201498">ns</a>: <a href="#57497" title="Parsers.this.NoSuccess">NoSuccess</a> =&gt; <a href="#201498" title="Parsers.this.NoSuccess">ns</a>
    }
  }

  /** &lt;p&gt;
   *    A parser generator delimiting whole phrases (i.e. programs).
   *  &lt;/p&gt;
   *  &lt;p&gt;
   *    &lt;code&gt;phrase(p)&lt;/code&gt; succeeds if &lt;code&gt;p&lt;/code&gt; succeeds and
   *    no input is left over after &lt;code&gt;p&lt;/code&gt;.
   *  &lt;/p&gt;
   *
   *  @param p the parser that must consume all input for the resulting parser
   *           to succeed.
   *  @return  a parser that has the same result as `p', but that only succeeds
   *           if &lt;code&gt;p&lt;/code&gt; consumed all the input.
   */
  <span class="keyword">def</span> <a title="[T](p: Parsers.this.Parser[T])Parsers.this.Parser[T]" id="57591">phrase</a>[<a title="&gt;: Nothing &lt;: Any" id="57593">T</a>](<a title="Parsers.this.Parser[T]" id="125313">p</a>: <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T]) = <a href="#125316" title="Parsers.this.Parser[T]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends Parsers.this.Parser[T]" id="125316">Parser</a>[T] {
    <a href="#57495" title="(x$1: Parsers.this.NoSuccess)Unit">lastNoSuccess</a> = <span title="Null(null)" class="keyword">null</span>
    <span class="keyword">def</span> <a title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]" id="125318">apply</a>(<a title="Parsers.this.Input" id="125325">in</a>: <a href="../input/Reader.scala.html#9517" title="Parsers.this.Input">Input</a>) = <a href="#57681" title="(in: Parsers.this.Input)Parsers.this.ParseResult[T]">p</a>(<a href="#125325" title="Parsers.this.Input">in</a>) <span title="Parsers.this.ParseResult[T]" class="keyword">match</span> {
      <span title="Parsers.this.ParseResult[T]" class="keyword">case</span> <a title="Parsers.this.Success[T]" id="125342">s</a> @ Success(<a title="T" id="125397">out</a>, <a title="Parsers.this.Input" id="125398">in1</a>) =&gt;
        <span title="Parsers.this.ParseResult[T]" class="keyword">if</span> (<a href="#125398" title="Parsers.this.Input">in1</a>.<a href="../input/Reader.scala.html#22001" title="=&gt; Boolean">atEnd</a>) 
          <a href="#125342" title="Parsers.this.Success[T]">s</a>
        <span class="keyword">else</span> <span title="Parsers.this.ParseResult[T]" class="keyword">if</span> (<a href="#57495" title="(x$1: AnyRef)Boolean">lastNoSuccess</a> <span title="(x$1: Boolean)Boolean">==</span> <span title="Null(null)" class="keyword">null</span> || <a href="#57495" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>.<a href="#199515" title="=&gt; Parsers.this.Input">next</a>.<a href="../input/Position.scala.html#23157" title="(that: scala.util.parsing.input.Position)Boolean">pos</a> &lt; <a href="#125398" title="Parsers.this.Input">in1</a>.<a href="../input/Reader.scala.html#22000" title="=&gt; scala.util.parsing.input.Position">pos</a>)
          <a href="#85051" title="(msg: String,next: Parsers.this.Input)Parsers.this.Failure">Failure</a>(<span title="java.lang.String(&quot;end of input expected&quot;)" class="string">&quot;end of input expected&quot;</span>, <a href="#125398" title="Parsers.this.Input">in1</a>)
        <span class="keyword">else</span> 
          <a href="#57495" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>
      <span title="Parsers.this.NoSuccess" class="keyword">case</span> _ =&gt; <a href="#57495" title="=&gt; Parsers.this.NoSuccess">lastNoSuccess</a>
    }
  }

  <span class="keyword">def</span> <a title="[T](Parsers.this.~[T,List[T]]) =&gt; List[T]" id="57594">mkList</a>[<a title="&gt;: Nothing &lt;: Any" id="57596">T</a>] = (<a href="#200754" title="Parsers.this.~[T,List[T]]">_</a>: <a href="#125520" title="Parsers.this.~[T,List[T]]">~</a>[T, List[T]]) <span title="List[T]" class="keyword">match</span> { <span title="List[T]" class="keyword">case</span> <a title="T" id="200757">x</a> ~ <a title="List[T]" id="200758">xs</a> =&gt; <a href="#200757" title="T">x</a> <a href="#200761" title="T">::</a> <a href="../../../collection/immutable/List.scala.html#17737" title="(x: T)List[T]">xs</a> }
  case <span class="keyword">class</span> <a title="class ~[+a, +b] extends java.lang.Object with ScalaObject with Product" id="125520">~</a>[+<a title="&gt;: Nothing &lt;: Any" id="125523">a</a>, +<a title="&gt;: Nothing &lt;: Any" id="125524">b</a>]<a href="../../../ScalaObject.scala.html#969" title="ScalaObject">(</a><a title="a" id="201633">_1</a>: <a href="#125523" title="a">a</a>, <a title="b" id="201634">_2</a>: <a href="#125524" title="b">b</a>) {
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()java.lang.String" id="125487">toString</a> = <span title="(x$1: Any)java.lang.String" class="string">&quot;(&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#201633" title="=&gt; a">_1</a> <span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;~&quot;)" class="string">&quot;~&quot;</span><span title="(x$1: Any)java.lang.String">+</span> <a href="#201634" title="=&gt; b">_2</a> +<span title="java.lang.String(&quot;)&quot;)" class="string">&quot;)&quot;</span>
  }

  /** A parser whose ~ combinator disallows back-tracking.
   */
  <span class="keyword">trait</span> <a title="trait OnceParser[+T] extends Parsers.this.Parser[T] with ScalaObject" id="57602">OnceParser</a>[+<a title="&gt;: Nothing &lt;: Any" id="57603">T</a>] <a href="../../../ScalaObject.scala.html#969" title="ScalaObject" class="keyword">extends</a> <a href="#57512" title="Parsers.this.Parser[T]">Parser</a>[T] {
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="[U](p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]" id="199826">~</a> [<a title="&gt;: Nothing &lt;: Any" id="199828">U</a>](<a title="=&gt; Parsers.this.Parser[U]" id="201582">p</a>: =&gt; Parser[U]): <a href="#57512" title="Parsers.this.Parser[Parsers.this.~[T,U]]">Parser</a>[~[T, U]]
      = <a href="#57509" title="(f: (Parsers.this.Input) =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]">OnceParser</a>{ (<span class="keyword">for</span>(<a title="T" id="201595">a</a> &lt;- <a href="#57682" title="(f: (T) =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]" class="keyword">this</a>; <a title="U" id="201605">b</a> &lt;- <a href="#57521" title="(p: =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]">commit</a><a href="#57685" title="(f: (U) =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]">(</a><a href="#201582" title="=&gt; Parsers.this.Parser[U]">p</a>)) <span class="keyword">yield</span> <span title="Parsers.this.~[T,U]" class="keyword">new</span> <a href="#125520" title="Parsers.this.~[T,U]">~</a>(<a href="#201595" title="T">a</a>,<a href="#201605" title="U">b</a>)).<a href="#57679" title="(n: java.lang.String)Parsers.this.Parser[Parsers.this.~[T,U]]">named</a>(<span title="java.lang.String(&quot;~&quot;)" class="string">&quot;~&quot;</span>) }
  }
}

        </pre>
    </body>
</html>