<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/combinator/Parsers.scala</title>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: Parsers.scala 17132 2009-02-17 13:06:27Z extempore $</span>

<span class="keyword">package</span> scala.util.parsing.combinator

<span class="keyword">import</span> scala.util.parsing.input._
<span class="keyword">import</span> scala.collection.mutable.{Map=&gt;MutableMap}

<span class="comment">// TODO: better error handling (labelling like parsec's &lt;?&gt;)</span>
<span class="comment">// TODO: memoisation (like packrat parsers?) </span>

<span class="comment">/** &lt;p&gt;
 *    &lt;code&gt;Parsers&lt;/code&gt; is a component that &lt;i&gt;provides&lt;/i&gt; generic
 *    parser combinators.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    It &lt;i&gt;requires&lt;/i&gt; the type of the elements these parsers should parse 
 *    (each parser is polymorphic in the type of result it produces).
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    There are two aspects to the result of a parser: (1) success or failure,
 *    and (2) the result. A &lt;code&gt;Parser[T]&lt;/code&gt; provides both kinds of
 *    information.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    The term ``parser combinator'' refers to the fact that these parsers
 *    are constructed from primitive parsers and composition operators, such
 *    as sequencing, alternation, optionality, repetition, lifting, and so on.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    A ``primitive parser'' is a parser that accepts or rejects a single
 *    piece of input, based on a certain criterion, such as whether the
 *    input...
 *  &lt;/p&gt;&lt;ul&gt;
 *    &lt;li&gt; is equal to some given object, &lt;/li&gt;
 *    &lt;li&gt; satisfies a certain predicate, &lt;/li&gt;
 *    &lt;li&gt; is in the domain of a given partial function,.... &lt;/li&gt;
 *  &lt;/ul&gt;
 *  &lt;p&gt;
 *    Even more primitive parsers always produce the same result, irrespective
 *    of the input.
 *  &lt;/p&gt;
 *
 * @requires Elem the type of elements the provided parsers consume 
 *              (When consuming invidual characters, a parser is typically called a ``scanner'', 
 *               which produces ``tokens'' that are consumed by what is normally called a ``parser''.
 *               Nonetheless, the same principles apply, regardless of the input type.)&lt;/p&gt;
 *&lt;p&gt;
 * @provides Input = Reader[Elem] 
 *              The type of input the parsers in this component expect.&lt;/p&gt;
 *&lt;p&gt;
 * @provides Parser[+T] extends (Input =&gt; ParseResult[T]) 
 *              Essentially, a `Parser[T]' is a function from `Input' to `ParseResult[T]'.&lt;/p&gt;
 *&lt;p&gt;
 * @provides ParseResult[+T] is like an `Option[T]', in the sense that it is either
 *              `Success[T]', which consists of some result (:T) (and the rest of the input) or
 *              `Failure[T]', which provides an error message (and the rest of the input).&lt;/p&gt;
 *
 * @author Martin Odersky, Iulian Dragos, Adriaan Moors 
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait Parsers extends java.lang.Object with ScalaObject</span><a id="6848">Parsers</a></span> {
  <span class="comment">/** the type of input elements */</span>
  <span class="keyword">type</span> <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17984">Elem</a></span>

  <span class="comment">/** The parser input is an abstract reader of input elements */</span>
  <span class="keyword">type</span> <span class="typed"><span class="type">scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a id="17985">Input</a></span> = <span class="typed"><span class="type">scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#10014">Reader</a></span>[Elem]

  <span class="comment">/** A base class for parser results. 
   *  A result is either successful or not (failure may be fatal, i.e.,
   *  an Error, or not, i.e., a Failure)
   *  On success, provides a result of type &lt;code&gt;T&lt;/code&gt;. 
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class ParseResult[+T] extends java.lang.Object with ScalaObject</span><a id="17986">ParseResult</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17987">T</a></span>] {
    <span class="comment">/** Functional composition of ParseResults
     * 
     * @param `f' the function to be lifted over this result
     * @return `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.ParseResult[U]</span><a id="24102">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24104">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="33628">f</a></span>: T =&gt; U): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U]
    
    <span class="comment">/** Partial functional composition of ParseResults
     * 
     * @param `f' the partial function to be lifted over this result
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable (it is called when this is the case)
     * @return &lt;i&gt;if `f' f is defined at the result in this `ParseResult',&lt;/i&gt;
     *         `f' applied to the result of this `ParseResult', packaged up as a new `ParseResult'.
     *         If `f' is not defined, `Failure'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a id="24105">mapPartial</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24107">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="33629">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U], <span class="typed"><span class="type">(T) =&gt; String</span><a id="33630">error</a></span>: T =&gt; String): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U]   
    
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="24108">flatMapWithNext</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24110">U</a></span>](<span class="typed"><span class="type">(T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]</span><a id="33631">f</a></span>: T =&gt; Input =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U]     

    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="24111">append</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24113">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.ParseResult[U]</span><a id="33632">a</a></span>: =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U]
    
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="24114">isEmpty</a></span> = <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">=&gt; Boolean</span><a href="#24120">successful</a></span>
    
    <span class="comment">/** Returns the embedded result */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; T</span><a id="24115">get</a></span>: <span class="typed"><span class="type">T</span><a href="#17987">T</a></span>
    
    <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: T](=&gt; B)B</span><a id="24116">getOrElse</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24118">B</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; B</span><a id="33636">default</a></span>: =&gt; B): <span class="typed"><span class="type">B</span><a href="#24118">B</a></span> = 
        <span class="typed"><span class="type">B</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="#24114">isEmpty</a></span>) <span class="typed"><span class="type">=&gt; B</span><a href="#33636">default</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">ParseResult.this.type</span><a href="#17986" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; T</span><a href="#24115">get</a></span>
    
    <span class="keyword">val</span> <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a id="24119">next</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>
    
    <span class="keyword">val</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="24120">successful</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span>
  }

  <span class="comment">/** The success case of ParseResult: contains the result and the remaining input.
   *
   *  @param result The parser's output 
   *  @param next   The parser's remaining input
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Success[+T] extends Parsers.this.ParseResult[T] with ScalaObject with Product</span><span id="24147"><span id="33670"><span id="33673"><span id="33678"><span id="2748"><span id="2749"><span id="33676"><span id="5792"><span id="33675"><span id="3494"><span id="19891"><span id="33669"><span id="33677"><span id="24098"><span id="3507"><span id="33671"><span id="24144"><span id="17990"><span id="3499"><span id="17988"><span id="33672"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="3498">Success</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><span id="17989"><span id="24146"><a id="24100">T</a></span></span></span>](<span class="typed"><span class="type">T</span><span id="24124"><span id="24123"><span id="24152"><a id="33642">result</a></span></span></span></span>: <span class="typed"><span class="type">T</span><a href="#17989">T</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="24126"><span id="24125"><span id="24153"><a id="33643">next</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#17986">ParseResult</a></span>[T] {
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.Success[U]</span><a id="24128">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24130">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="33640">f</a></span>: T =&gt; U) = <span class="typed"><span class="type">(U,Parsers.this.Input)Parsers.this.Success[U]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">(T)U</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>), <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24125">next</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a id="24131">mapPartial</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24133">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="33645">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U], <span class="typed"><span class="type">(T) =&gt; String</span><a id="33646">error</a></span>: T =&gt; String): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] 
       = <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">PartialFunction[T,U]</span><a href="#33645">f</a></span>.<span class="typed"><span class="type">(T)Boolean</span><a href="../../../PartialFunction.scala.html#17289">isDefinedAt</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>)) <span class="typed"><span class="type">(U,Parsers.this.Input)Parsers.this.Success[U]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">(T)U</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>), <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24125">next</a></span>) 
         <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">(T)String</span><a href="../../../Function1.scala.html#17300">error</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>), <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24125">next</a></span>)

    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="24134">flatMapWithNext</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24136">U</a></span>](<span class="typed"><span class="type">(T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]</span><a id="33664">f</a></span>: T =&gt; Input =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] 
      = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>)(<span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24125">next</a></span>) 

    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="24137">append</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24139">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.ParseResult[U]</span><a id="33665">a</a></span>: =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] = <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#17988" class="keyword">this</a></span>

    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; T</span><a id="24140">get</a></span>: <span class="typed"><span class="type">T</span><a href="#17989">T</a></span> = <span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>
    
    <span class="comment">/** The toString method of a Success */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="24141">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24125">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;] parsed: &quot;)</span><span class="string">&quot;] parsed: &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; T</span><a href="#24123">result</a></span>
    
    <span class="keyword">val</span> <span class="typed"><span class="type">Boolean</span><span id="24143"><a id="24142">successful</a></span></span> = <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
  }

  <span class="keyword">var</span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span id="17994"><span id="17992"><span id="17993"><a id="33626">lastNoSuccess</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span> = <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>

  <span class="comment">/** A common super-class for unsuccessful parse results
   */</span>
  <span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class NoSuccess extends Parsers.this.ParseResult[Nothing] with ScalaObject</span><a id="17995">NoSuccess</a></span>(<span class="keyword">val</span> <span class="typed"><span class="type">String</span><span id="24168"><span id="24167"><a id="33683">msg</a></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="24170"><span id="24169"><a id="33684">next</a></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.ParseResult[Nothing]</span><a href="#17986">ParseResult</a></span>[Nothing] { <span class="comment">// when we don't care about the difference between Failure and Error</span>
    <span class="keyword">val</span> <span class="typed"><span class="type">Boolean</span><span id="24173"><a id="24172">successful</a></span></span> = <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
    <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.NoSuccess</span><a href="#17992">lastNoSuccess</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5791">!=</a></span> <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24169">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.NoSuccess</span><a href="#17992">lastNoSuccess</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24169">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>))
      <span class="typed"><span class="type">(Parsers.this.NoSuccess)Unit</span><a href="#17993">lastNoSuccess</a></span> = <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995" class="keyword">this</a></span>

    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((Nothing) =&gt; U)Parsers.this.NoSuccess</span><a id="24174">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24176">U</a></span>](<span class="typed"><span class="type">(Nothing) =&gt; U</span><a id="33694">f</a></span>: Nothing =&gt; U) = <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995" class="keyword">this</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[Nothing,U],(Nothing) =&gt; String)Parsers.this.ParseResult[U]</span><a id="24177">mapPartial</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24179">U</a></span>](<span class="typed"><span class="type">PartialFunction[Nothing,U]</span><a id="33696">f</a></span>: <span class="typed"><span class="type">PartialFunction[Nothing,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[Nothing, U], <span class="typed"><span class="type">(Nothing) =&gt; String</span><a id="33697">error</a></span>: Nothing =&gt; String): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] = <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995" class="keyword">this</a></span>

    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((Nothing) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="24180">flatMapWithNext</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24182">U</a></span>](<span class="typed"><span class="type">(Nothing) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]</span><a id="33698">f</a></span>: Nothing =&gt; Input =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] 
      = <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995" class="keyword">this</a></span>

    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Nothing</span><a id="24183">get</a></span>: <span class="typed"><span class="type">Nothing</span><a id="2165">Nothing</a></span> = <span class="typed"><span class="type">(String)Nothing</span><a href="../../../Predef.scala.html#13358">error</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;No result when parsing failed&quot;)</span><span class="string">&quot;No result when parsing failed&quot;</span></span>)
  }
  
  <span class="comment">/** The failure case of ParseResult: contains an error-message and the remaining input.
   * Parsing will back-track when a failure occurs.
   *
   *  @param msg    An error message string describing the failure.
   *  @param next   The parser's unconsumed input at the point where the failure occurred.
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Failure extends Parsers.this.NoSuccess with ScalaObject with Product</span><span id="17997"><span id="17996"><span id="33649"><span id="33724"><span id="2748"><span id="33714"><span id="2749"><span id="33712"><span id="33723"><span id="5792"><span id="33725"><span id="19891"><span id="33661"><span id="33711"><span id="33726"><span id="33720"><span id="3507"><span id="33713"><span id="3499"><span id="33719"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="3498">Failure</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>(<span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">String</span><span id="33653"><span id="33652"><span id="33704"><a href="#24167" id="33662">msg</a></span></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="33655"><span id="33654"><span id="33705"><a href="#24169" id="33663">next</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span>(<span class="typed"><span class="type">String</span><a href="#33704">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#33705">next</a></span>) {
    <span class="comment">/** The toString method of a Failure yields an error message */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="33657">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#33654">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;] failure: &quot;)</span><span class="string">&quot;] failure: &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; String</span><a href="#33652">msg</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;\012\012&quot;)</span><span class="string">&quot;\n\n&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#33654">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>.<span class="typed"><span class="type">=&gt; java.lang.String</span><a href="../input/Position.scala.html#23453">longString</a></span>
    
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="33658">append</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="33660">U</a></span> &gt;: Nothing](<span class="typed"><span class="type">=&gt; Parsers.this.ParseResult[U]</span><a id="33708">a</a></span>: =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] = { <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a id="33709">alt</a></span> = <span class="typed"><span class="type">=&gt; Parsers.this.ParseResult[U]</span><a href="#33708">a</a></span>; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#33709">alt</a></span> <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#33709">alt</a></span>
      <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="33710">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#33709">alt</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24119">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#33654">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#17996" class="keyword">this</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#33709">alt</a></span>
    }}
  }
  
  <span class="comment">/** The fatal failure case of ParseResult: contains an error-message and the remaining input.
   * No back-tracking is done when a parser returns an `Error' 
   *
   *  @param msg    An error message string describing the error.
   *  @param next   The parser's unconsumed input at the point where the error occurred.
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Error extends Parsers.this.NoSuccess with ScalaObject with Product</span><span id="33765"><span id="33748"><span id="33749"><span id="2748"><span id="2749"><span id="17999"><span id="33763"><span id="5792"><span id="33747"><span id="33752"><span id="33758"><span id="19891"><span id="33753"><span id="3507"><span id="18000"><span id="33762"><span id="3499"><span id="33759"><span id="33764"><span id="3498"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="33751">Error</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>(<span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">String</span><span id="33731"><span id="33730"><span id="33742"><a href="#24167" id="33884">msg</a></span></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="keyword">override</span> <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.Input</span><span id="33733"><span id="33732"><span id="33743"><a href="#24169" id="33885">next</a></span></span></span></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span>(<span class="typed"><span class="type">String</span><a href="#33742">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#33743">next</a></span>) {
    <span class="comment">/** The toString method of an Error yields an error message */</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="33735">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#33732">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;] error: &quot;)</span><span class="string">&quot;] error: &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; String</span><a href="#33730">msg</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;\012\012&quot;)</span><span class="string">&quot;\n\n&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#33732">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>.<span class="typed"><span class="type">=&gt; java.lang.String</span><a href="../input/Position.scala.html#23453">longString</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a id="33736">append</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="33738">U</a></span> &gt;: Nothing](<span class="typed"><span class="type">=&gt; Parsers.this.ParseResult[U]</span><a id="33746">a</a></span>: =&gt; ParseResult[U]): <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#17986">ParseResult</a></span>[U] = <span class="typed"><span class="type">Parsers.this.Error</span><a href="#17999" class="keyword">this</a></span>
  }
  

  <span class="keyword">def</span> <span class="typed"><span class="type">[T]((Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]</span><a id="18002">Parser</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18004">T</a></span>](<span class="typed"><span class="type">(Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]</span><a id="33767">f</a></span>: Input =&gt; ParseResult[T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] 
    = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="33768" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T]{ <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="33770">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="33772">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33772">in</a></span>) }
  
  <span class="keyword">def</span> <span class="typed"><span class="type">[T]((Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T] with Parsers.this.OnceParser[T]</span><a id="18005">OnceParser</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18007">T</a></span>](<span class="typed"><span class="type">(Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]</span><a id="33774">f</a></span>: Input =&gt; ParseResult[T]): <span class="typed"><span class="type">&lt;refinement&gt; extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]</span><a href="#33775">Parser</a></span>[T] <span class="keyword">with</span> OnceParser[T] 
    = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T] with Parsers.this.OnceParser[T]</span><a id="33781" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] <span class="keyword">with</span> <span class="typed"><span class="type">Parsers.this.OnceParser[T]</span><a href="#18095">OnceParser</a></span>[T] { <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="33783">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="33786">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33786">in</a></span>) }
  
  <span class="comment">/** The root class of parsers. 
   *  Parsers are functions from the Input type to ParseResult 
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Parser[+T] extends java.lang.Object with (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T] with ScalaObject</span><a id="18008">Parser</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18009">T</a></span>] <span class="keyword">extends</span> (Input =&gt; ParseResult[T]) {
    <span class="keyword">private</span> <span class="keyword">var</span> <span class="typed"><span class="type">String</span><span id="24016"><span id="24014"><span id="24015"><a id="33789">name</a></span></span></span></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(String)Parser.this.type</span><a id="24017">named</a></span>(<span class="typed"><span class="type">String</span><a id="33790">n</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="keyword">this</span>.<span class="keyword">type</span> = {<span class="typed"><span class="type">(String)Unit</span><a href="#24015">name</a></span>=<span class="typed"><span class="type">String</span><a href="#33790">n</a></span>; <span class="typed"><span class="type">Parser.this.type</span><a href="#18008" class="keyword">this</a></span>}
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="24018">toString</a></span>() = <span class="typed"><span class="type">java.lang.String(&quot;Parser (&quot;)</span><span class="string">&quot;Parser (&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">=&gt; String</span><a href="#24014">name</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;)&quot;)</span><span class="string">&quot;)&quot;</span></span>
    
    <span class="comment">/** An unspecified method that defines the behaviour of this parser.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="24019">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="24093">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#17986">ParseResult</a></span>[T]

    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24020">flatMap</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24022">U</a></span>](<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a id="33792">f</a></span>: T =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U]
      = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="33795">in</a></span> =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019" class="keyword">this</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33795">in</a></span>) <span class="typed"><span class="type">((T) =&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a href="#24108">flatMapWithNext</a></span>(<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a href="#33792">f</a></span>)}
                                      
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.Parser[U]</span><a id="24023">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24025">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="33801">f</a></span>: T =&gt; U): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] <span class="comment">//= flatMap{x =&gt; success(f(x))}</span>
      = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="33804">in</a></span> =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019" class="keyword">this</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33804">in</a></span>) <span class="typed"><span class="type">((T) =&gt; U)Parsers.this.ParseResult[U]</span><a href="#24102">map</a></span>(<span class="typed"><span class="type">(T) =&gt; U</span><a href="#33801">f</a></span>)}

    <span class="comment">// no filter yet, dealing with zero is tricky!</span>
  
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24026">append</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24028">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33810">p</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] 
      = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="33813">in</a></span> =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019" class="keyword">this</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33813">in</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.ParseResult[U])Parsers.this.ParseResult[U]</span><a href="#24111">append</a></span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33813">in</a></span>)}

                                      
    <span class="comment">// the operator formerly known as +++, ++, &amp;, but now, behold the venerable ~</span>
    <span class="comment">// it's short, light (looks like whitespace), has few overloaded meaning (thanks to the recent change from ~ to unary_~)</span>
    <span class="comment">// and we love it! (or do we like `,` better?)</span>
                                      
    <span class="comment">/** A parser combinator for sequential composition 
     *
     * &lt;p&gt; `p ~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a id="24029">~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24031">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33824">p</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#18008">Parser</a></span>[~[T, U]] = (<span class="keyword">for</span>(<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24020" id="33827">a</a></span> &lt;- <span class="typed"><span class="type">Parser.this.type</span><a href="#18008" class="keyword">this</a></span>; <span class="typed"><span class="type">((U) =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24023" id="33830">b</a></span> &lt;- <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#33824">p</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">Parsers.this.~[T,U]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Parsers.this.~[T,U]</span><a href="#18090">~</a></span>(<span class="typed"><span class="type">T</span><a href="#33827">a</a></span>,<span class="typed"><span class="type">U</span><a href="#33830">b</a></span>)).<span class="typed"><span class="type">(String)Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span>)

    <span class="comment">/** A parser combinator for sequential composition which keeps only the right result 
     *
     * &lt;p&gt; `p ~&gt; q' succeeds if `p' succeeds and `q' succeeds on the input
     *           left over by `p'.&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `q'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24032">~&gt;</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24034">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33845">p</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = (<span class="keyword">for</span>(<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#24020" id="33848">a</a></span> &lt;- <span class="typed"><span class="type">Parser.this.type</span><a href="#18008" class="keyword">this</a></span>; <span class="typed"><span class="type">((U) =&gt; U)Parsers.this.Parser[U]</span><a href="#24023" id="33851">b</a></span> &lt;- <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#33845">p</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">U</span><a href="#33851">b</a></span>).<span class="typed"><span class="type">(String)Parsers.this.Parser[U]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;~&gt;&quot;)</span><span class="string">&quot;~&gt;&quot;</span></span>)

    <span class="comment">/** A parser combinator for sequential composition which keeps only the left result 
     *
     * &lt;p&gt; `p &amp;lt;~ q' succeeds if `p' succeeds and `q' succeeds on the input
     *           left over by `p'.&lt;/p&gt;
     * 
     * &lt;b&gt;Note:&lt;/b&gt; &amp;lt;~ has lower operator precedence than ~ or ~&gt;.
     *
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns the result of `p'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[T]</span><a id="24035">&lt;~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24037">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33854">p</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] = (<span class="keyword">for</span>(<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a href="#24020" id="33857">a</a></span> &lt;- <span class="typed"><span class="type">Parser.this.type</span><a href="#18008" class="keyword">this</a></span>; <span class="typed"><span class="type">((U) =&gt; T)Parsers.this.Parser[T]</span><a href="#24023" id="33860">b</a></span> &lt;- <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#33854">p</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">T</span><a href="#33857">a</a></span>).<span class="typed"><span class="type">(String)Parsers.this.Parser[T]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;&lt;~&quot;)</span><span class="string">&quot;&lt;~&quot;</span></span>)

     <span class="comment">/* not really useful: V cannot be inferred because Parser is covariant in first type parameter (V is always trivially Nothing)
    def ~~ [U, V](q: =&gt; Parser[U])(implicit combine: (T, U) =&gt; V): Parser[V] = new Parser[V] {
      def apply(in: Input) = seq(Parser.this, q)((x, y) =&gt; combine(x,y))(in)
    }  */</span>   

    <span class="comment">/** A parser combinator for non-back-tracking sequential composition 
     *
     *&lt;p&gt;`p ~! q' succeeds if `p' succeeds and `q' succeeds on the input
     *          left over by `p'. In case of failure, no back-tracking is performed 
     *          (in an earlier parser produced by the | combinator).&lt;/p&gt;
     * 
     * @param q a parser that will be executed after `p' (this parser) succeeds
     * @return a `Parser' that -- on success -- returns a `~' (like a Pair, but easier to pattern match on) 
     *         that contains the result of `p' and that of `q'. 
     *         The resulting parser fails if either `p' or `q' fails, this failure is fatal.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a id="24038">~!</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24040">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33863">p</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#18008">Parser</a></span>[~[T, U]] 
      = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]</span><a href="#18005">OnceParser</a></span>{ (<span class="keyword">for</span>(<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24020" id="33869">a</a></span> &lt;- <span class="typed"><span class="type">Parser.this.type</span><a href="#18008" class="keyword">this</a></span>; <span class="typed"><span class="type">((U) =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24023" id="33905">b</a></span> &lt;- <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#18017">commit</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#33863">p</a></span>)) <span class="keyword">yield</span> <span class="typed"><span class="type">Parsers.this.~[T,U]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Parsers.this.~[T,U]</span><a href="#18090">~</a></span>(<span class="typed"><span class="type">T</span><a href="#33869">a</a></span>,<span class="typed"><span class="type">U</span><a href="#33905">b</a></span>)).<span class="typed"><span class="type">(String)Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;~!&quot;)</span><span class="string">&quot;~!&quot;</span></span>) }
        
    <span class="comment">/** A parser combinator for alternative composition 
     *
     *&lt;p&gt;`p | q' succeeds if `p' succeeds or `q' succeeds
     *          Note that `q' is only tried if `p's failure is non-fatal (i.e., back-tracking is
     *          allowed).&lt;/p&gt;
     * 
     * @param q a parser that will be executed if `p' (this parser) fails (and allows back-tracking)
     * @return a `Parser' that returns the result of the first parser to succeed (out of `p' and `q')
     *         The resulting parser succeeds if (and only if) &lt;ul&gt;
     *           &lt;li&gt; `p' succeeds, &lt;i&gt;or&lt;/i&gt;  &lt;/li&gt;
     *           &lt;li&gt; if `p' fails allowing back-tracking and `q' succeeds. &lt;/li&gt; &lt;/ul&gt;
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24041">|</a></span> [<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24043">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33912">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#24026">append</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#33912">q</a></span>).<span class="typed"><span class="type">(String)Parsers.this.Parser[U]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;|&quot;)</span><span class="string">&quot;|&quot;</span></span>)

    <span class="comment">// TODO</span>
    <span class="comment">/** A parser combinator for alternative with longest match composition 
     *
     *&lt;p&gt;`p ||| q' succeeds if `p' succeeds or `q' succeeds
     *          If `p' and `q' both succeed, the parser that consumed the most
     *          characters accepts.&lt;/p&gt;
     * 
     * @param q a parser that accepts if p consumes less characters.
     * @return a `Parser' that returns the result of the parser consuming the most characteres (out of `p' and `q').
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24044">|||</a></span> [<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24046">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33916">q</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[U]</span><a id="33917" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a id="33919">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="33922">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = {
        <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a id="33924">res1</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">Parser</a></span>.<span class="keyword">this</span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33922">in</a></span>)
        <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a id="33925">res2</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="#24019">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33922">in</a></span>)
        
        <span class="typed"><span class="type">(Parsers.this.ParseResult[T],Parsers.this.ParseResult[U])(Parsers.this.ParseResult[T], Parsers.this.ParseResult[U])</span><a href="../../../Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#33924">res1</a></span>, <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><a href="#33925">res2</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">match</span></span> {
          <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="33936">s1</a></span> @ <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33937">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Success[U]</span><a id="33938">s2</a></span> @ <a id="1">Success</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33939">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33939">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#33937">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#33936">s1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Success[U]</span><a href="#33938">s2</a></span>
          <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="33940">s1</a></span> @ <a id="1">Success</a>(_, _), _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#33940">s1</a></span>
          <span class="typed"><span class="type">Parsers.this.Success[U]</span><span class="keyword">case</span></span> <a id="1">(</a>_, <span class="typed"><span class="type">Parsers.this.Success[U]</span><a id="33941">s2</a></span> @ <a id="1">Success</a>(_, _)) =&gt; <span class="typed"><span class="type">Parsers.this.Success[U]</span><a href="#33941">s2</a></span>
          <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Error</span><a id="33942">e1</a></span> @ <a id="1">Error</a>(_, _), _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#33942">e1</a></span>
          <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Failure</span><a id="33943">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33944">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Failure</span><a id="33945">f2</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33946">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33946">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#33944">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#33943">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#33945">f2</a></span>
          <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">Parsers.this.Failure</span><a id="33947">f1</a></span> @ <a id="1">Failure</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33948">next1</a></span>), <span class="typed"><span class="type">Parsers.this.Error</span><a id="33949">e2</a></span> @ <a id="1">Error</a>(_, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33950">next2</a></span>)) =&gt; <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33950">next2</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#33948">next1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>) <span class="typed"><span class="type">Parsers.this.Failure</span><a href="#33947">f1</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.Error</span><a href="#33949">e2</a></span>
        }
      }
      <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="33920">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;|||&quot;)</span><span class="string">&quot;|||&quot;</span></span>
    }

    <span class="comment">/** A parser combinator for function application 
     *
     *&lt;p&gt;`p ^^ f' succeeds if `p' succeeds; it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a function that will be applied to this parser's result (see `map' in `ParseResult').
     * @return a parser that has the same behaviour as the current parser, but whose result is
     *         transformed by `f'.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; U)Parsers.this.Parser[U]</span><a id="24047">^^</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24049">U</a></span>](<span class="typed"><span class="type">(T) =&gt; U</span><a id="33953">f</a></span>: T =&gt; U): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">((T) =&gt; U)Parsers.this.Parser[U]</span><a href="#24023">map</a></span>(<span class="typed"><span class="type">(T) =&gt; U</span><a href="#33953">f</a></span>).<span class="typed"><span class="type">(String)Parsers.this.Parser[U]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">()java.lang.String</span><a href="#24018">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;^^&quot;)</span><span class="string">&quot;^^&quot;</span></span>)
    

    <span class="keyword">def</span> <span class="typed"><span class="type">[U](U)Parsers.this.Parser[U]</span><a id="24050">^^^</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24052">U</a></span>](<span class="typed"><span class="type">U</span><a id="33957">r</a></span>: <span class="typed"><span class="type">U</span><a href="#24052">U</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">((T) =&gt; U)Parsers.this.Parser[U]</span><a href="#24047">^^</a></span> (<span class="typed"><span class="type">T</span><a id="33960">x</a></span> =&gt; <span class="typed"><span class="type">U</span><a href="#33957">r</a></span>)
    
    <span class="comment">/** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? (f, error)' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'. If `f' is not applicable,
     *  error(the result of `p') should explain why.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @param error a function that takes the same argument as `f' and produces an error message 
     *        to explain why `f' wasn't applicable
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U],(T) =&gt; String)Parsers.this.Parser[U]</span><a id="24053">^?</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24055">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="33961">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U], <span class="typed"><span class="type">(T) =&gt; String</span><a id="33962">error</a></span>: T =&gt; String): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="33965">in</a></span> =&gt;
      <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019" class="keyword">this</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33965">in</a></span>).<span class="typed"><span class="type">(PartialFunction[T,U],(T) =&gt; String)Parsers.this.ParseResult[U]</span><a href="#24105">mapPartial</a></span>(<span class="typed"><span class="type">PartialFunction[T,U]</span><a href="#33961">f</a></span>, <span class="typed"><span class="type">(T) =&gt; String</span><a href="#33962">error</a></span>)}.<span class="typed"><span class="type">(String)Parsers.this.Parser[U]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">()java.lang.String</span><a href="#24018">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;^?&quot;)</span><span class="string">&quot;^?&quot;</span></span>)
     
    <span class="comment">/** A parser combinator for partial function application 
     *
     *&lt;p&gt;`p ^? f' succeeds if `p' succeeds AND `f' is defined at the result of `p'; 
     *  in that case, it returns `f' applied to the result of `p'.&lt;/p&gt;
     *
     * @param f a partial function that will be applied to this parser's result 
     *          (see `mapPartial' in `ParseResult').
     * @return a parser that succeeds if the current parser succeeds &lt;i&gt;and&lt;/i&gt; `f' is applicable 
     *         to the result. If so, the result will be transformed by `f'.     
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U](PartialFunction[T,U])Parsers.this.Parser[U]</span><a id="24056">^?</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24058">U</a></span>](<span class="typed"><span class="type">PartialFunction[T,U]</span><a id="33973">f</a></span>: <span class="typed"><span class="type">PartialFunction[T,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[T, U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">(PartialFunction[T,U],(T) =&gt; String)Parsers.this.Parser[U]</span><a href="#24053">^?</a></span>(<span class="typed"><span class="type">PartialFunction[T,U]</span><a href="#33973">f</a></span>, <span class="typed"><span class="type">T</span><a id="33985">r</a></span> =&gt; <span class="typed"><span class="type">java.lang.String(&quot;Constructor function not defined at &quot;)</span><span class="string">&quot;Constructor function not defined at &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">T</span><a href="#33985">r</a></span>)
    
       
    <span class="comment">/** A parser combinator that parameterises a subsequent parser with the result of this one
     *
     *&lt;p&gt;
     * Use this combinator when a parser depends on the result of a previous parser. `p' should be
     * a function that takes the result from the first parser and returns the second parser.&lt;/p&gt;
     *
     *&lt;p&gt; `p into fq' (with `fq' typically `{x =&gt; q}') first applies `p', and then, if `p' successfully  
     *    returned result `r', applies `fq(r)' to the rest of the input. &lt;/p&gt;
     *
     *&lt;p&gt; From: G. Hutton. Higher-order functions for parsing. J. Funct. Program., 2(3):323--343, 1992. &lt;/p&gt;
     *
     * @param fq a function that, given the result from this parser, returns the second parser to be applied
     * @return a parser that succeeds if this parser succeeds (with result `x') and if then `fq(x)' succeeds
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24059">into</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24061">U</a></span>](<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a id="33986">fq</a></span>: T =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#24020">flatMap</a></span>(<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a href="#33986">fq</a></span>)
    
    <span class="comment">// shortcuts for combinators:</span>
    
    <span class="comment">/** Returns into(fq) */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">[U]((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a id="24062">&gt;&gt;</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="24064">U</a></span>](<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a id="33988">fq</a></span>: T =&gt; Parser[U])=<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#24059">into</a></span>(<span class="typed"><span class="type">(T) =&gt; Parsers.this.Parser[U]</span><a href="#33988">fq</a></span>)
    
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses
     *
     * @return rep(this) 
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[List[T]]</span><a id="24065">*</a></span> = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#18044">rep</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008" class="keyword">this</a></span>)
    
    <span class="comment">/** Returns a parser that repeatedly parses what this parser parses, interleaved with the `sep' parser.
     * The `sep' parser specifies how the results parsed by this parser should be combined.
     *
     * @return chainl1(this, sep) 
     */</span>    
    <span class="keyword">def</span> <span class="typed"><span class="type">[U &gt;: T](=&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]</span><a id="24066">*</a></span>[<span class="typed"><span class="type">&gt;: T &lt;: Any</span><a id="24068">U</a></span> &gt;: T](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[(U, U) =&gt; U]</span><a id="33995">sep</a></span>: =&gt; Parser[(U, U) =&gt; U]) = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U],=&gt; Parsers.this.Parser[(U, U) =&gt; U])Parsers.this.Parser[U]</span><a href="#18062">chainl1</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008" class="keyword">this</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(U, U) =&gt; U]</span><a href="#33995">sep</a></span>)
    
    <span class="comment">// TODO: improve precedence? a ~ b*(&quot;,&quot;) = a ~ (b*(&quot;,&quot;))  should be true </span>
    
    <span class="comment">/** Returns a parser that repeatedly (at least once) parses what this parser parses.
     *
     * @return rep1(this) 
     */</span>      
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[List[T]]</span><a id="24069">+</a></span> = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#18050">rep1</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008" class="keyword">this</a></span>)
    
    <span class="comment">/** Returns a parser that optionally parses what this parser parses.
     *
     * @return opt(this) 
     */</span>       
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[Option[T]]</span><a id="24070">?</a></span> = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]</span><a href="#18075">opt</a></span>(<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008" class="keyword">this</a></span>)
  }

  <span class="comment">// TODO: can this implemented in ParseResult, like map?</span>
  <span class="comment">/** A helper method for sequential composition of (unit-)parsers
  */</span>
  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">[T, U, V](=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T],=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])((T, U) =&gt; V)(Parsers.this.Input)Parsers.this.ParseResult[V]</span><a id="18010">seq</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18014">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18015">U</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18016">V</a></span>](<span class="typed"><span class="type">=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[T]</span><a id="34020">p</a></span>: =&gt; Input =&gt; ParseResult[T], <span class="typed"><span class="type">=&gt; (Parsers.this.Input) =&gt; Parsers.this.ParseResult[U]</span><a id="34021">q</a></span>: =&gt; Input =&gt; ParseResult[U])
                          (<span class="typed"><span class="type">(T, U) =&gt; V</span><a id="34022">compose</a></span>: (T, U) =&gt; V)
                          (<span class="typed"><span class="type">Parsers.this.Input</span><a id="34023">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>): <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><a href="#17986">ParseResult</a></span>[V] 
    = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="../../../Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34023">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">T</span><a id="34024">x</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="34025">next1</a></span>) =&gt; <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[U]</span><a href="../../../Function1.scala.html#17300">q</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34025">next1</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[V]</span><span class="keyword">match</span></span> {
          <span class="typed"><span class="type">Parsers.this.Success[V]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">U</span><a id="34026">y</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="34027">next2</a></span>) =&gt; <span class="typed"><span class="type">(V,Parsers.this.Input)Parsers.this.Success[V]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">(T,U)V</span><a href="../../../Function2.scala.html#20399">compose</a></span>(<span class="typed"><span class="type">T</span><a href="#34024">x</a></span>, <span class="typed"><span class="type">U</span><a href="#34026">y</a></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34027">next2</a></span>)
          <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="34029">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#34029">ns</a></span>
        }
      <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="34030">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#34030">ns</a></span>
    }
  
  <span class="comment">/** Wrap a parser so that its failures become errors (the | combinator will give up as soon as 
   *  it encounters an error, on failure it simply tries the next alternative) 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a id="18017">commit</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18019">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="33870">p</a></span>: =&gt; Parser[T]) = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="33874">in</a></span> =&gt;
    <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#33874">in</a></span>) <span class="typed"><span class="type">&lt;refinement&gt; extends Product with Parsers.this.ParseResult[T]</span><span class="keyword">match</span></span>{
      <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="33879">s</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#33879">s</a></span>
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="33880">e</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#33880">e</a></span>
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="33881">f</a></span> @ <a id="1">Failure</a>(<span class="typed"><span class="type">String</span><a id="33882">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="33883">next</a></span>) =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Error</span><a href="#33751">Error</a></span>(<span class="typed"><span class="type">String</span><a href="#33882">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#33883">next</a></span>)
    }
  }
  
	<span class="comment">/*trait ElemFun
  case class EFCons(hd: Elem =&gt; ElemFun, tl: ElemFun) extends ElemFun
  case class EFNil(res: Boolean) extends ElemFun*/</span>

   
  <span class="comment">/** A parser matching input elements that satisfy a given predicate
   *
   * &lt;p&gt;elem(kind, p) succeeds if the input starts with an element `e' for which p(e) is true.&lt;/p&gt;
   *
   * @param  kind   The element kind, used for error messages
   * @param  p      A predicate that determines which elements match.
   * @return 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(String,(Parsers.this.Elem) =&gt; Boolean)Parsers.this.Parser[Parsers.this.Elem]</span><a id="18020">elem</a></span>(<span class="typed"><span class="type">String</span><a id="34031">kind</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">(Parsers.this.Elem) =&gt; Boolean</span><a id="34032">p</a></span>: Elem =&gt; Boolean) = <span class="typed"><span class="type">((Parsers.this.Elem) =&gt; Boolean)((Parsers.this.Elem) =&gt; String)Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18029">acceptIf</a></span>(<span class="typed"><span class="type">(Parsers.this.Elem) =&gt; Boolean</span><a href="#34032">p</a></span>)(<span class="typed"><span class="type">Parsers.this.Elem</span><a id="34037">inEl</a></span> =&gt; <span class="typed"><span class="type">String</span><a href="#34031">kind</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; expected&quot;)</span><span class="string">&quot; expected&quot;</span></span>)
   
  <span class="comment">/** A parser that matches only the given element `e'
   *
   * &lt;p&gt;elem(e) succeeds if the input starts with an element `e'&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `Parser' that succeeds if `e' is the next available input (and returns it).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]</span><a id="18021">elem</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a id="34038">e</a></span>: <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#17984">Elem</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18008">Parser</a></span>[Elem] = <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18022">accept</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a href="#34038">e</a></span>)
  
  
  <span class="comment">/** A parser that matches only the given element `e' 
   *&lt;p&gt;
   * The method is implicit so that elements can automatically be lifted to their parsers. 
   * For example, when parsing `Token's, Identifier(&quot;new&quot;) (which is a `Token') can be used directly,
   * instead of first creating a `Parser' using accept(Identifier(&quot;new&quot;)).&lt;/p&gt;
   *
   * @param e the `Elem' that must be the next piece of input for the returned parser to succeed
   * @return a `tParser' that succeeds if `e' is the next available input.
   */</span>
   
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]</span><a id="18022">accept</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a id="33977">e</a></span>: <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#17984">Elem</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18008">Parser</a></span>[Elem] = <span class="typed"><span class="type">((Parsers.this.Elem) =&gt; Boolean)((Parsers.this.Elem) =&gt; String)Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18029">acceptIf</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a href="#34047">_</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#33977">e</a></span>)(<span class="typed"><span class="type">java.lang.String(&quot;`&quot;)</span><span class="string">&quot;`&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">Parsers.this.Elem</span><a href="#33977">e</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;' expected but &quot;)</span><span class="string">&quot;' expected but &quot;</span></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">Parsers.this.Elem</span><a href="#34049">_</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">java.lang.String(&quot; found&quot;)</span><span class="string">&quot; found&quot;</span></span>)
  
  <span class="comment">/** A parser that matches only the given list of element `es'
   *
   * &lt;p&gt;accept(es) succeeds if the input subsequently provides the elements in the list `es'.&lt;/p&gt;
   *
   * @param  es the list of expected elements
   * @return a Parser that recognizes a specified list of elements
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[ES](ES)(implicit (ES) =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]</span><span id="18023"><a id="34044">accept</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18025">ES</a></span> &lt;% List[Elem]](<span class="typed"><span class="type">ES</span><a id="34043">es</a></span>: <span class="typed"><span class="type">ES</span><a href="#18025">ES</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="#18008">Parser</a></span>[List[Elem]] = <span class="typed"><span class="type">(ES)(implicit (ES) =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="#18033">acceptSeq</a></span>(<span class="typed"><span class="type">ES</span><a href="#34043">es</a></span>)

  <span class="comment">/** The parser that matches an element in the domain of the partial function `f'
   *&lt;p&gt;
   * If `f' is defined on the first element in the input, `f' is applied to it to produce 
   * this parser's result.&lt;/p&gt;
   *&lt;p&gt;
   * Example: The parser &lt;code&gt;accept(&quot;name&quot;, {case Identifier(n) =&gt; Name(n)})&lt;/code&gt; 
   *          accepts an &lt;code&gt;Identifier(n)&lt;/code&gt; and returns a &lt;code&gt;Name(n)&lt;/code&gt;.&lt;/p&gt;
   *
   * @param expected a description of the kind of element this parser expects (for error messages)
   * @param f a partial function that determines when this parser is successful and what its output is
   * @return A parser that succeeds if `f' is applicable to the first element of the input, 
   *         applying `f' to it to produce the result.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[U](String,PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]</span><a id="18026">accept</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18028">U</a></span>](<span class="typed"><span class="type">String</span><a id="34040">expected</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a id="34041">f</a></span>: <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[Elem, U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">(String,PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]</span><a href="#18030">acceptMatch</a></span>(<span class="typed"><span class="type">String</span><a href="#34040">expected</a></span>, <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a href="#34041">f</a></span>)


  <span class="keyword">def</span> <span class="typed"><span class="type">((Parsers.this.Elem) =&gt; Boolean)((Parsers.this.Elem) =&gt; String)Parsers.this.Parser[Parsers.this.Elem]</span><a id="18029">acceptIf</a></span>(<span class="typed"><span class="type">(Parsers.this.Elem) =&gt; Boolean</span><a id="34034">p</a></span>: Elem =&gt; Boolean)(<span class="typed"><span class="type">(Parsers.this.Elem) =&gt; String</span><a id="34035">err</a></span>: Elem =&gt; String): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18008">Parser</a></span>[Elem] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[Parsers.this.Elem])Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18002">Parser</a></span> { <span class="typed"><span class="type">Parsers.this.Input</span><a id="34061">in</a></span> =&gt;
    <span class="typed"><span class="type">Parsers.this.ParseResult[Parsers.this.Elem]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(Parsers.this.Elem)Boolean</span><a href="../../../Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34061">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>)) <span class="typed"><span class="type">(Parsers.this.Elem,Parsers.this.Input)Parsers.this.Success[Parsers.this.Elem]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34061">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34061">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>)
    <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">(Parsers.this.Elem)String</span><a href="../../../Function1.scala.html#17300">err</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34061">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34061">in</a></span>)
  }
  
  <span class="keyword">def</span> <span class="typed"><span class="type">[U](String,PartialFunction[Parsers.this.Elem,U])Parsers.this.Parser[U]</span><a id="18030">acceptMatch</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18032">U</a></span>](<span class="typed"><span class="type">String</span><a id="34056">expected</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a id="34057">f</a></span>: <span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a href="../../../PartialFunction.scala.html#1295">PartialFunction</a></span>[Elem, U]): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[U])Parsers.this.Parser[U]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="34065">in</a></span> =&gt; 
    <span class="typed"><span class="type">Parsers.this.ParseResult[U]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">PartialFunction[Parsers.this.Elem,U]</span><a href="#34057">f</a></span>.<span class="typed"><span class="type">(Parsers.this.Elem)Boolean</span><a href="../../../PartialFunction.scala.html#17289">isDefinedAt</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34065">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>)) <span class="typed"><span class="type">(U,Parsers.this.Input)Parsers.this.Success[U]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">(Parsers.this.Elem)U</span><a href="../../../Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34065">in</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Elem</span><a href="../input/Reader.scala.html#23141">first</a></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34065">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Reader[Parsers.this.Elem]</span><a href="../input/Reader.scala.html#23142">rest</a></span>)
    <span class="keyword">else</span> <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">String</span><a href="#34056">expected</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; expected&quot;)</span><span class="string">&quot; expected&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34065">in</a></span>)
  }
  
  <span class="keyword">def</span> <span class="typed"><span class="type">[ES](ES)(implicit (ES) =&gt; Iterable[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]</span><span id="18033"><a id="34051">acceptSeq</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18035">ES</a></span> &lt;% Iterable[Elem]](<span class="typed"><span class="type">ES</span><a id="34050">es</a></span>: <span class="typed"><span class="type">ES</span><a href="#18035">ES</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="#18008">Parser</a></span>[List[Elem]] = <span class="typed"><span class="type">(ES)Iterable[Parsers.this.Elem]</span><a href="../../../Function1.scala.html#17300">es</a></span>.<span class="typed"><span class="type">(Parsers.this.Parser[List[Parsers.this.Elem]])((Parsers.this.Elem, Parsers.this.Parser[List[Parsers.this.Elem]]) =&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="../../../Iterable.scala.html#17339">foldRight</a></span>[<span class="typed"><span class="type">Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="#18008">Parser</a></span>[List[Elem]]](<span class="typed"><span class="type">(object Nil)Parsers.this.Parser[object Nil]</span><a href="#18038">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">Nil</a></span>)){(<span class="typed"><span class="type">Parsers.this.Elem</span><a id="34079">x</a></span>, <span class="typed"><span class="type">Parsers.this.Parser[List[Parsers.this.Elem]]</span><a id="34080">pxs</a></span>) =&gt; <span class="typed"><span class="type">implicit scala.util.parsing.combinator.Parsers.accept : (Parsers.this.Elem)Parsers.this.Parser[Parsers.this.Elem]</span><a href="#18022">accept</a></span>(<span class="typed"><span class="type">Parsers.this.Elem</span><a href="#34079">x</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[Parsers.this.Elem]])Parsers.this.Parser[Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="#34080">pxs</a></span> <span class="typed"><span class="type">((Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]) =&gt; List[Parsers.this.Elem])Parsers.this.Parser[List[Parsers.this.Elem]]</span><a href="#24047">^^</a></span> <span class="typed"><span class="type">(Parsers.this.~[Parsers.this.Elem,List[Parsers.this.Elem]]) =&gt; List[Parsers.this.Elem]</span><a href="#18087">mkList</a></span>}

  <span class="comment">/** A parser that always fails 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(String)Parsers.this.Parser[Nothing]</span><a id="18036">failure</a></span>(<span class="typed"><span class="type">String</span><a id="34116">msg</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>) = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="34120">in</a></span> =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">String</span><a href="#34116">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34120">in</a></span>) }

  <span class="comment">/** A parser that results in an error 
   *
   * @param msg The error message describing the failure. 
   * @return A parser that always fails with the specified error message.
   */</span>  
  <span class="keyword">def</span> <span class="typed"><span class="type">(String)Parsers.this.Parser[Nothing]</span><a id="18037">err</a></span>(<span class="typed"><span class="type">String</span><a id="34121">msg</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>) = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[Nothing])Parsers.this.Parser[Nothing]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="34125">in</a></span> =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Error</span><a href="#33751">Error</a></span>(<span class="typed"><span class="type">String</span><a href="#34121">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34125">in</a></span>) }


  <span class="comment">/** A parser that always succeeds 
   *
   * @param v The result for the parser
   * @return A parser that always succeeds, with the given result `v'
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](T)Parsers.this.Parser[T]</span><a id="18038">success</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18040">T</a></span>](<span class="typed"><span class="type">T</span><a id="34071">v</a></span>: <span class="typed"><span class="type">T</span><a href="#18040">T</a></span>) = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="34075">in</a></span> =&gt; <span class="typed"><span class="type">(T,Parsers.this.Input)Parsers.this.Success[T]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">T</span><a href="#34071">v</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34075">in</a></span>) }

  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])(String)Parsers.this.Parser[T]</span><a id="18041">log</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18043">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34126">p</a></span>: =&gt; Parser[T])(<span class="typed"><span class="type">String</span><a id="34127">name</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="34130">in</a></span> =&gt;
    <span class="typed"><span class="type">(Any)Unit</span><a href="../../../Predef.scala.html#13489">println</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;trying &quot;)</span><span class="string">&quot;trying &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">String</span><a href="#34127">name</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; at &quot;)</span><span class="string">&quot; at &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34130">in</a></span>)
    <span class="keyword">val</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a id="34131">r</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34130">in</a></span>)
    <span class="typed"><span class="type">(Any)Unit</span><a href="../../../Predef.scala.html#13489">println</a></span>(<span class="typed"><span class="type">String</span><a href="#34127">name</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; --&gt; &quot;)</span><span class="string">&quot; --&gt; &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34131">r</a></span>)
    <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34131">r</a></span>
  } 

  
  <span class="comment">/** A parser generator for repetitions.
   *  
   * &lt;p&gt; rep(p)   repeatedly uses `p' to parse the input until `p' fails (the result is a List 
   *  of the consecutive results of `p') &lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="18044">rep</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18046">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="33993">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#18008">Parser</a></span>[List[T]] = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#18050">rep1</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#33993">p</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]</span><a href="#24041">|</a></span> <span class="typed"><span class="type">(List[Nothing])Parsers.this.Parser[List[Nothing]]</span><a href="#18038">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">List</a></span>())

  <span class="comment">/** A parser generator for interleaved repetitions.
   *  
   * &lt;p&gt; repsep(p, q)   repeatedly uses `p' interleaved with `q' to parse the input, until `p' fails.
   *  (The result is a `List' of the results of `p'.) &lt;/p&gt;
   *
   * &lt;p&gt;Example: &lt;code&gt;repsep(term, &quot;,&quot;)&lt;/code&gt; parses a comma-separated list of term's, 
   *          yielding a list of these terms&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `Parser' that parses the elements that separate the elements parsed by `p'
   * @return A parser that returns a list of results produced by repeatedly applying `p' (interleaved
   *         with `q') to the input. 
   *         The results of `p' are collected in a list. The results of `q' are discarded.    
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]</span><a id="18047">repsep</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18049">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34152">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[Any]</span><a id="34153">q</a></span>: =&gt; Parser[Any]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#18008">Parser</a></span>[List[T]] = 
    <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]</span><a href="#18059">rep1sep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34152">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[Any]</span><a href="#34153">q</a></span>) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]</span><a href="#24041">|</a></span> <span class="typed"><span class="type">(List[Nothing])Parsers.this.Parser[List[Nothing]]</span><a href="#18038">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">List</a></span>())
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(p) repeatedly uses `p' to parse the input until `p' fails -- `p' must succeed at least
   *             once (the result is a `List' of the consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches at least once).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="18050">rep1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18052">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34013">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#18008">Parser</a></span>[List[T]] = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#18053">rep1</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34013">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34013">p</a></span>)
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   * &lt;p&gt; rep1(f, p) first uses `f' (which must succeed) and then repeatedly uses `p' to 
   *     parse the input until `p' fails 
   *     (the result is a `List' of the consecutive results of `f' and `p')&lt;/p&gt;
   *
   * @param first a `Parser' that parses the first piece of input
   * @param p a `Parser' that is to be applied successively to the rest of the input (if any)
   * @return A parser that returns a list of results produced by first applying `f' and then 
   *         repeatedly `p' to the input (it only succeeds if `f' matches).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="18053">rep1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18055">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34010">first</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34011">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#18008">Parser</a></span>[List[T]] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[List[T]])Parsers.this.Parser[List[T]]</span><a href="#18002">Parser</a></span>{ <span class="typed"><span class="type">Parsers.this.Input</span><a id="34171">in0</a></span> =&gt;
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[T]</span><a id="34172">xs</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[T]</span><span class="keyword">new</span></span> scala.collection.mutable.<span class="typed"><span class="type">scala.collection.mutable.ListBuffer[T]</span><a href="../../../collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[T]
    <span class="keyword">var</span> <span class="typed"><span class="type">Parsers.this.Input</span><a id="34173">in</a></span> = <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34171">in0</a></span>

    <span class="keyword">var</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a id="34174">res</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">first</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34173">in</a></span>)

    <span class="typed"><span class="type">Unit</span><a href="#34175" class="keyword">while</a></span>(<span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34174">res</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="#24120">successful</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[T]</span><a href="#34172">xs</a></span> <span class="typed"><span class="type">(T)Unit</span><a href="../../../collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34174">res</a></span>.<span class="typed"><span class="type">=&gt; T</span><a href="#24115">get</a></span>
      <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34173">in</a></span> = <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34174">res</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24119">next</a></span>
      <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34174">res</a></span> = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34173">in</a></span>)
    }

    <span class="comment">// assert(res.isInstanceOf[NoSuccess])</span>

    <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34174">res</a></span> <span class="typed"><span class="type">Parsers.this.ParseResult[List[T]]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.Error</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="34184">e</a></span>: <span class="typed"><span class="type">Parsers.this.Error</span><a href="#17999">Error</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.Error</span><a href="#34184">e</a></span>
      <span class="typed"><span class="type">Parsers.this.ParseResult[List[T]]</span><span class="keyword">case</span></span> _  =&gt; 
        <span class="typed"><span class="type">Parsers.this.ParseResult[List[T]]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scala.collection.mutable.ListBuffer[T]</span><a href="#34172">xs</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../../collection/mutable/ListBuffer.scala.html#32075">isEmpty</a></span>) {
          <span class="comment">// the next parser should start parsing where p failed, </span>
          <span class="comment">// since `!p(in).successful', the next input to be consumed is `in'</span>
          <span class="typed"><span class="type">(List[T],Parsers.this.Input)Parsers.this.Success[List[T]]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">scala.collection.mutable.ListBuffer[T]</span><a href="#34172">xs</a></span>.<span class="typed"><span class="type">=&gt; List[T]</span><a href="../../../collection/mutable/ListBuffer.scala.html#32069">toList</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34173">in</a></span>)  <span class="comment">// TODO: I don't think in == res.next holds</span>
        }
        <span class="keyword">else</span> {
          <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><a href="#34174">res</a></span>.<span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span>].<span class="typed"><span class="type">=&gt; String</span><a href="#24167">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34171">in0</a></span>)
        }
    }
  }
  
  <span class="comment">//= first ~ rep(p) ^^ { case ~(x, xs) =&gt; x :: xs }</span>
  

  <span class="comment">/** A parser generator for a specified number of repetitions.
   *  
   * &lt;p&gt; repN(n, p)  uses `p' exactly `n' time to parse the input 
   *       (the result is a `List' of the `n' consecutive results of `p')&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param n the exact number of times `p' must succeed
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *        (and that only succeeds if `p' matches exactly `n' times).
   */</span>  
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](Int,=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a id="18056">repN</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18058">T</a></span>](<span class="typed"><span class="type">Int</span><a id="34189">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34190">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#18008">Parser</a></span>[List[T]] = 
    <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">Int</span><a href="#34189">n</a></span><span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span><span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) <span class="typed"><span class="type">(object Nil)Parsers.this.Parser[object Nil]</span><a href="#18038">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">Nil</a></span>) <span class="keyword">else</span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34190">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[T,List[T]]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">(Int,=&gt; Parsers.this.Parser[T])Parsers.this.Parser[List[T]]</span><a href="#18056">repN</a></span>(<span class="typed"><span class="type">Int</span><a href="#34189">n</a></span><span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span><span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34190">p</a></span>) <span class="typed"><span class="type">((Parsers.this.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]</span><a href="#24047">^^</a></span> <span class="typed"><span class="type">List[T]</span><a href="#34211">{</a></span> <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <a id="1">~</a>(<span class="typed"><span class="type">T</span><a id="34212">x</a></span>, <span class="typed"><span class="type">List[T]</span><a id="34213">xs</a></span>) =&gt; <span class="typed"><span class="type">T</span><a href="#34212">x</a></span> <span class="typed"><span class="type">(T)List[T]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[T]</span><a href="#34213">xs</a></span> }
  
  <span class="comment">/** A parser generator for non-empty repetitions.
   *  
   *  &lt;p&gt;rep1sep(p, q) repeatedly applies `p' interleaved with `q' to parse the input, until `p' fails.
   *                The parser `p' must succeed at least once.&lt;/p&gt;
   *
   * @param p a `Parser' that is to be applied successively to the input
   * @param q a `Parser' that parses the elements that separate the elements parsed by `p' 
   *          (interleaved with `q')   
   * @return A parser that returns a list of results produced by repeatedly applying `p' to the input
   *         (and that only succeeds if `p' matches at least once).
   *         The results of `p' are collected in a list. The results of `q' are discarded.    
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]</span><a id="18059">rep1sep</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18061">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34154">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[Any]</span><a id="34155">q</a></span>: =&gt; Parser[Any]): <span class="typed"><span class="type">Parsers.this.Parser[List[T]]</span><a href="#18008">Parser</a></span>[List[T]] = 
    <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34154">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[T,List[T]]]</span><a href="#24029">~</a></span> (<span class="typed"><span class="type">=&gt; Parsers.this.Parser[Any]</span><a href="#34155">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[Parsers.this.~[Any,List[T]]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[Any])Parsers.this.Parser[List[T]]</span><a href="#18059">rep1sep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34154">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[Any]</span><a href="#34155">q</a></span>) <span class="typed"><span class="type">((Parsers.this.~[Any,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]</span><a href="#24047">^^</a></span> <span class="typed"><span class="type">List[T]</span><a href="#34222">{</a></span> <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Any</span><a id="34223">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[T]</span><a id="34224">y</a></span> =&gt; <span class="typed"><span class="type">List[T]</span><a href="#34224">y</a></span> } <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[T]])Parsers.this.Parser[List[T]]</span><a href="#24041">|</a></span> <span class="typed"><span class="type">(List[Nothing])Parsers.this.Parser[List[Nothing]]</span><a href="#18038">success</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">List</a></span>())) <span class="typed"><span class="type">((Parsers.this.~[T,List[T]]) =&gt; List[T])Parsers.this.Parser[List[T]]</span><a href="#24047">^^</a></span> <span class="typed"><span class="type">List[T]</span><a href="#34231">{</a></span> <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="34232">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[T]</span><a id="34233">y</a></span> =&gt; <span class="typed"><span class="type">T</span><a href="#34232">x</a></span> <span class="typed"><span class="type">(T)List[T]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[T]</span><a href="#34233">y</a></span> }
   
  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * &lt;p&gt; From: J. Fokker. Functional parsers. In J. Jeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, pages 1--23. Springer, 1995.&lt;/p&gt;
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]</span><a id="18062">chainl1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18064">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34003">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, T) =&gt; T]</span><a id="34004">q</a></span>: =&gt; Parser[(T, T) =&gt; T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T]  
    = <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[(T, T) =&gt; T])Parsers.this.Parser[T]</span><a href="#18065">chainl1</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34003">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34003">p</a></span>, <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, T) =&gt; T]</span><a href="#34004">q</a></span>)

  <span class="comment">/** A parser generator that, roughly, generalises the rep1sep generator so that `q', which parses the separator,
   * produces a left-associative function that combines the elements it separates.
   *
   * @param first a parser that parses the first element
   * @param p a parser that parses the subsequent elements
   * @param q a parser that parses the token(s) separating the elements, yielding a left-associative function that 
   *          combines two elements into one 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T, U](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[U],=&gt; Parsers.this.Parser[(T, U) =&gt; T])Parsers.this.Parser[T]</span><a id="18065">chainl1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18068">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18069">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="33998">first</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="33999">p</a></span>: =&gt; Parser[U], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, U) =&gt; T]</span><a id="34000">q</a></span>: =&gt; Parser[(T, U) =&gt; T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] 
    = <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#33998">first</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; T,U]]]</span><a href="#18044">rep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, U) =&gt; T]</span><a href="#34000">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; T,U]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#33999">p</a></span>) <span class="typed"><span class="type">((Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; T,U]]]) =&gt; T)Parsers.this.Parser[T]</span><a href="#24047">^^</a></span> <span class="typed"><span class="type">T</span><a href="#34248">{</a></span>
        <span class="typed"><span class="type">T</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="34249">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[Parsers.this.~[(T, U) =&gt; T,U]]</span><a id="34250">xs</a></span> =&gt; <span class="typed"><span class="type">List[Parsers.this.~[(T, U) =&gt; T,U]]</span><a href="#34250">xs</a></span>.<span class="typed"><span class="type">(T)((T, Parsers.this.~[(T, U) =&gt; T,U]) =&gt; T)T</span><a href="../../../List.scala.html#20919">foldLeft</a></span>(<span class="typed"><span class="type">T</span><a href="#34249">x</a></span>){<span class="typed"><span class="type">(T,Parsers.this.~[(T, U) =&gt; T,U])(T, Parsers.this.~[(T, U) =&gt; T,U])</span><a href="../../../Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">T</span><a href="#34255">_</a></span>, <span class="typed"><span class="type">Parsers.this.~[(T, U) =&gt; T,U]</span><a href="#34256">_</a></span>) <span class="typed"><span class="type">T</span><span class="keyword">match</span></span> {<span class="typed"><span class="type">T</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">T</span><a id="34259">a</a></span>, <span class="typed"><span class="type">(T, U) =&gt; T</span><a id="34260">f</a></span> <a id="1">~</a> <span class="typed"><span class="type">U</span><a id="34261">b</a></span>) =&gt; <span class="typed"><span class="type">(T,U)T</span><a href="../../../Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">T</span><a href="#34259">a</a></span>, <span class="typed"><span class="type">U</span><a href="#34261">b</a></span>)}}
      }
        
  <span class="comment">/** A parser generator that generalises the rep1sep generator so that `q', which parses the separator,
   * produces a right-associative function that combines the elements it separates. Additionally,
   * The right-most (last) element and the left-most combinating function have to be supplied.
   * 
   * rep1sep(p: Parser[T], q) corresponds to chainr1(p, q ^^ cons, cons, Nil) (where val cons = (x: T, y: List[T]) =&gt; x :: y)
   *
   * @param p a parser that parses the elements
   * @param q a parser that parses the token(s) separating the elements, yielding a right-associative function that 
   *          combines two elements into one 
   * @param combine the &quot;last&quot; (left-most) combination function to be applied
   * @param first   the &quot;first&quot; (right-most) element to be combined
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T, U](=&gt; Parsers.this.Parser[T],=&gt; Parsers.this.Parser[(T, U) =&gt; U],(T, U) =&gt; U,U)Parsers.this.Parser[U]</span><a id="18070">chainr1</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18073">T</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18074">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34262">p</a></span>: =&gt; Parser[T], <span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, U) =&gt; U]</span><a id="34263">q</a></span>: =&gt; Parser[(T, U) =&gt; U], <span class="typed"><span class="type">(T, U) =&gt; U</span><a id="34264">combine</a></span>: (T, U) =&gt; U, <span class="typed"><span class="type">U</span><a id="34265">first</a></span>: <span class="typed"><span class="type">U</span><a href="#18074">U</a></span>): <span class="typed"><span class="type">Parsers.this.Parser[U]</span><a href="#18008">Parser</a></span>[U]
    = <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34262">p</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]])Parsers.this.Parser[Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]])Parsers.this.Parser[List[Parsers.this.~[(T, U) =&gt; U,T]]]</span><a href="#18044">rep</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[(T, U) =&gt; U]</span><a href="#34263">q</a></span> <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[T])Parsers.this.Parser[Parsers.this.~[(T, U) =&gt; U,T]]</span><a href="#24029">~</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34262">p</a></span>) <span class="typed"><span class="type">((Parsers.this.~[T,List[Parsers.this.~[(T, U) =&gt; U,T]]]) =&gt; U)Parsers.this.Parser[U]</span><a href="#24047">^^</a></span> <span class="typed"><span class="type">U</span><a href="#34271">{</a></span>
        <span class="typed"><span class="type">U</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="34272">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[Parsers.this.~[(T, U) =&gt; U,T]]</span><a id="34273">xs</a></span> =&gt; (<span class="typed"><span class="type">Parsers.this.~[(T, U) =&gt; U,T]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Parsers.this.~[(T, U) =&gt; U,T]</span><a href="#18090">~</a></span>(<span class="typed"><span class="type">(T, U) =&gt; U</span><a href="#34264">combine</a></span>, <span class="typed"><span class="type">T</span><a href="#34272">x</a></span>) <span class="typed"><span class="type">(Parsers.this.~[(T, U) =&gt; U,T])List[Parsers.this.~[(T, U) =&gt; U,T]]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[Parsers.this.~[(T, U) =&gt; U,T]]</span><a href="#34273">xs</a></span>).
                            <span class="typed"><span class="type">(U)((Parsers.this.~[(T, U) =&gt; U,T], U) =&gt; U)U</span><a href="../../../List.scala.html#20922">foldRight</a></span>(<span class="typed"><span class="type">U</span><a href="#34265">first</a></span>){<span class="typed"><span class="type">(Parsers.this.~[(T, U) =&gt; U,T],U)(Parsers.this.~[(T, U) =&gt; U,T], U)</span><a href="../../../Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">Parsers.this.~[(T, U) =&gt; U,T]</span><a href="#34284">_</a></span>, <span class="typed"><span class="type">U</span><a href="#34285">_</a></span>) <span class="typed"><span class="type">U</span><span class="keyword">match</span></span> {<span class="typed"><span class="type">U</span><span class="keyword">case</span></span> <a id="1">(</a><span class="typed"><span class="type">(T, U) =&gt; U</span><a id="34288">f</a></span> <a id="1">~</a> <span class="typed"><span class="type">T</span><a id="34289">a</a></span>, <span class="typed"><span class="type">U</span><a id="34290">b</a></span>) =&gt; <span class="typed"><span class="type">(T,U)U</span><a href="../../../Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">T</span><a href="#34289">a</a></span>, <span class="typed"><span class="type">U</span><a href="#34290">b</a></span>)}}
      }
    
  <span class="comment">/** A parser generator for optional sub-phrases.
   *  
   *  &lt;p&gt;opt(p) is a parser that returns `Some(x)' if `p' returns `x' and `None' if `p' fails&lt;/p&gt;
   *
   * @param p A `Parser' that is tried on the input
   * @return a `Parser' that always succeeds: either with the result provided by `p' or 
   *         with the empty result
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[Option[T]]</span><a id="18075">opt</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18077">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34018">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[Option[T]]</span><a href="#18008">Parser</a></span>[Option[T]] = 
    <span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a href="#34018">p</a></span> <span class="typed"><span class="type">((T) =&gt; Some[T])Parsers.this.Parser[Some[T]]</span><a href="#24047">^^</a></span> (<span class="typed"><span class="type">T</span><a id="34293">x</a></span> =&gt; <span class="typed"><span class="type">(T)Some[T]</span><a href="../../../Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">T</span><a href="#34293">x</a></span>)) <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[Option[T]])Parsers.this.Parser[Option[T]]</span><a href="#24041">|</a></span> <span class="typed"><span class="type">(object None)Parsers.this.Parser[object None]</span><a href="#18038">success</a></span>(<span class="typed"><span class="type">object None</span><a href="../../../Option.scala.html#534">None</a></span>)

  <span class="comment">/** Wrap a parser so that its failures&amp;errors become success and vice versa -- it never consumes any input 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[Unit]</span><a id="18078">not</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18080">T</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34316">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[Unit]</span><a href="#18008">Parser</a></span>[Unit] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[Unit])Parsers.this.Parser[Unit]</span><a href="#18002">Parser</a></span> { <span class="typed"><span class="type">Parsers.this.Input</span><a id="34319">in</a></span> =&gt;
    <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34319">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[Unit]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.Failure</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="34324">s</a></span> @ <a id="1">Success</a>(_, _) =&gt; <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Expected failure&quot;)</span><span class="string">&quot;Expected failure&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34319">in</a></span>)
      <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Error</span><a id="34325">e</a></span> @ <a id="1">Error</a>(_, _) =&gt; <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34319">in</a></span>)
      <span class="typed"><span class="type">Parsers.this.Success[Unit]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Failure</span><a id="34327">f</a></span> @ <a id="1">Failure</a>(<span class="typed"><span class="type">String</span><a id="34328">msg</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="34329">next</a></span>) =&gt; <span class="typed"><span class="type">(Unit,Parsers.this.Input)Parsers.this.Success[Unit]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">Unit</span><span >(</span></span>), <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34319">in</a></span>)
    }
  }  
  
  
  <span class="comment">/** `positioned' decorates a parser's result with the start position of the input it consumed. 
   * 
   * @param p a `Parser' whose result conforms to `Positional'.
   * @return A parser that has the same behaviour as `p', but which marks its result with the 
   *         start position of the input it consumed, if it didn't already have a position.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T &lt;: scala.util.parsing.input.Positional](=&gt; Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a id="18081">positioned</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: scala.util.parsing.input.Positional</span><a id="18083">T</a></span> &lt;: Positional](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[T]</span><a id="34331">p</a></span>: =&gt; Parser[T]): <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[T])Parsers.this.Parser[T]</span><a href="#18002">Parser</a></span> { <span class="typed"><span class="type">Parsers.this.Input</span><a id="34339">in</a></span> =&gt;
    <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34339">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.Success[T]</span><span class="keyword">case</span></span> <a id="1">Success</a>(<span class="typed"><span class="type">T</span><a id="34344">t</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="34345">in1</a></span>) =&gt; <span class="typed"><span class="type">(T,Parsers.this.Input)Parsers.this.Success[T]</span><a href="#24098">Success</a></span>(<span class="typed"><span class="type">T</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">T</span><a href="#34344">t</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Positional.scala.html#34333">pos</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">object scala.util.parsing.input.NoPosition</span><a href="../input/NoPosition.scala.html#10021">NoPosition</a></span>) <span class="typed"><span class="type">T</span><a href="#34344">t</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)t.type</span><a href="../input/Positional.scala.html#34336">setPos</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34339">in</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">T</span><a href="#34344">t</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34345">in1</a></span>)
      <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a id="34350">ns</a></span>: <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#17995">NoSuccess</a></span> =&gt; <span class="typed"><span class="type">Parsers.this.NoSuccess</span><a href="#34350">ns</a></span>
    }
  }

  <span class="comment">/** &lt;p&gt;
   *    A parser generator delimiting whole phrases (i.e. programs).
   *  &lt;/p&gt;
   *  &lt;p&gt;
   *    &lt;code&gt;phrase(p)&lt;/code&gt; succeeds if &lt;code&gt;p&lt;/code&gt; succeeds and
   *    no input is left over after &lt;code&gt;p&lt;/code&gt;.
   *  &lt;/p&gt;
   *
   *  @param p the parser that must consume all input for the resulting parser
   *           to succeed.
   *  @return  a parser that has the same result as `p', but that only succeeds
   *           if &lt;code&gt;p&lt;/code&gt; consumed all the input.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[T](Parsers.this.Parser[T])Parsers.this.Parser[T]</span><a id="18084">phrase</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18086">T</a></span>](<span class="typed"><span class="type">Parsers.this.Parser[T]</span><a id="34351">p</a></span>: <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T]) = <span class="typed"><span class="type">template $anon extends Parsers.this.Parser[T]</span><a id="34353" class="keyword">new</a></span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] {
    <span class="typed"><span class="type">(Parsers.this.NoSuccess)Unit</span><a href="#17993">lastNoSuccess</a></span> = <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a id="34355">apply</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a id="34357">in</a></span>: <span class="typed"><span class="type">Parsers.this.Input</span><a href="../input/Reader.scala.html#10014">Input</a></span>) = <span class="typed"><span class="type">(Parsers.this.Input)Parsers.this.ParseResult[T]</span><a href="#24019">p</a></span>(<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34357">in</a></span>) <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Parsers.this.Success[T]</span><a id="34362">s</a></span> @ <a id="1">Success</a>(<span class="typed"><span class="type">T</span><a id="34363">out</a></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a id="34364">in1</a></span>) =&gt;
        <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Parsers.this.Input</span><a href="#34364">in1</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../input/Reader.scala.html#23145">atEnd</a></span>) 
          <span class="typed"><span class="type">Parsers.this.Success[T]</span><a href="#34362">s</a></span>
        <span class="keyword">else</span> <span class="typed"><span class="type">Parsers.this.ParseResult[T]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Parsers.this.NoSuccess</span><a href="#17992">lastNoSuccess</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">=&gt; Parsers.this.NoSuccess</span><a href="#17992">lastNoSuccess</a></span>.<span class="typed"><span class="type">=&gt; Parsers.this.Input</span><a href="#24169">next</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span> <span class="typed"><span class="type">(scala.util.parsing.input.Position)Boolean</span><a href="../input/Position.scala.html#23454">&lt;</a></span> <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34364">in1</a></span>.<span class="typed"><span class="type">=&gt; scala.util.parsing.input.Position</span><a href="../input/Reader.scala.html#23144">pos</a></span>)
          <span class="typed"><span class="type">(String,Parsers.this.Input)Parsers.this.Failure</span><a href="#33649">Failure</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;end of input expected&quot;)</span><span class="string">&quot;end of input expected&quot;</span></span>, <span class="typed"><span class="type">Parsers.this.Input</span><a href="#34364">in1</a></span>)
        <span class="keyword">else</span> 
          <span class="typed"><span class="type">=&gt; Parsers.this.NoSuccess</span><a href="#17992">lastNoSuccess</a></span>
      <span class="typed"><span class="type">Parsers.this.NoSuccess</span><span class="keyword">case</span></span> _ =&gt; <span class="typed"><span class="type">=&gt; Parsers.this.NoSuccess</span><a href="#17992">lastNoSuccess</a></span>
    }
  }

  <span class="keyword">def</span> <span class="typed"><span class="type">[T](Parsers.this.~[T,List[T]]) =&gt; List[T]</span><a id="18087">mkList</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18089">T</a></span>] = (<span class="typed"><span class="type">Parsers.this.~[T,List[T]]</span><a href="#34093">_</a></span>: <span class="typed"><span class="type">Parsers.this.~[T,List[T]]</span><a href="#18090">~</a></span>[T, List[T]]) <span class="typed"><span class="type">List[T]</span><span class="keyword">match</span></span> { <span class="typed"><span class="type">List[T]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">T</span><a id="34110">x</a></span> <a id="1">~</a> <span class="typed"><span class="type">List[T]</span><a id="34111">xs</a></span> =&gt; <span class="typed"><span class="type">T</span><a href="#34110">x</a></span> <span class="typed"><span class="type">(T)List[T]</span><a href="../../../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">List[T]</span><a href="#34111">xs</a></span> }
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class ~[+a, +b] extends java.lang.Object with ScalaObject with Product</span><span id="34095"><span id="34384"><span id="34105"><span id="2748"><span id="2749"><span id="34382"><span id="34379"><span id="5792"><span id="34380"><span id="19891"><span id="18093"><span id="3494"><span id="34386"><span id="34381"><span id="34378"><span id="34100"><span id="3499"><span id="34385"><span id="18090"><span id="34383"><a href="../../../runtime/ScalaRunTime.scala.html#19785" id="3498">~</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><span id="18091"><span id="34103"><a id="34098">a</a></span></span></span>, +<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><span id="18092"><span id="34104"><a id="34099">b</a></span></span></span>](<span class="typed"><span class="type">a</span><span id="33834"><span id="33833"><span id="33841"><a id="34408">_1</a></span></span></span></span>: <span class="typed"><span class="type">a</span><a href="#18091">a</a></span>, <span class="typed"><span class="type">b</span><span id="33836"><span id="33835"><span id="33842"><a id="34409">_2</a></span></span></span></span>: <span class="typed"><span class="type">b</span><a href="#18092">b</a></span>) {
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()java.lang.String</span><a id="33838">toString</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;(&quot;)</span><span class="string">&quot;(&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">=&gt; a</span><a href="#33833">_1</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">=&gt; b</span><a href="#33835">_2</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;)&quot;)</span><span class="string">&quot;)&quot;</span></span>
  }

  <span class="comment">/** A parser whose ~ combinator disallows back-tracking.
   */</span>
  <span class="keyword">trait</span> <span class="typed"><span class="type">trait OnceParser[+T] extends Parsers.this.Parser[T] with ScalaObject</span><a id="18095">OnceParser</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="18096">T</a></span>] <span class="keyword">extends</span> <span class="typed"><span class="type">Parsers.this.Parser[T]</span><a href="#18008">Parser</a></span>[T] {
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[U](=&gt; Parsers.this.Parser[U])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a id="33778">~</a></span> [<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="33780">U</a></span>](<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a id="34390">p</a></span>: =&gt; Parser[U]): <span class="typed"><span class="type">Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#18008">Parser</a></span>[~[T, U]]
      = <span class="typed"><span class="type">((Parsers.this.Input) =&gt; Parsers.this.ParseResult[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]] with Parsers.this.OnceParser[Parsers.this.~[T,U]]</span><a href="#18005">OnceParser</a></span>{ (<span class="keyword">for</span>(<span class="typed"><span class="type">((T) =&gt; Parsers.this.Parser[Parsers.this.~[T,U]])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24020" id="34396">a</a></span> &lt;- <span class="typed"><span class="type">OnceParser.this.type</span><a href="#18095" class="keyword">this</a></span>; <span class="typed"><span class="type">((U) =&gt; Parsers.this.~[T,U])Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24023" id="34400">b</a></span> &lt;- <span class="typed"><span class="type">(=&gt; Parsers.this.Parser[U])Parsers.this.Parser[U]</span><a href="#18017">commit</a></span>(<span class="typed"><span class="type">=&gt; Parsers.this.Parser[U]</span><a href="#34390">p</a></span>)) <span class="keyword">yield</span> <span class="typed"><span class="type">Parsers.this.~[T,U]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Parsers.this.~[T,U]</span><a href="#18090">~</a></span>(<span class="typed"><span class="type">T</span><a href="#34396">a</a></span>,<span class="typed"><span class="type">U</span><a href="#34400">b</a></span>)).<span class="typed"><span class="type">(String)Parsers.this.Parser[Parsers.this.~[T,U]]</span><a href="#24017">named</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;~&quot;)</span><span class="string">&quot;~&quot;</span></span>) }
  }
}

        </pre>
    </body>
</html>