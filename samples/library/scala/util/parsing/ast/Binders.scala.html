<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/util/parsing/ast/Binders.scala</title>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="keyword">package</span> scala.util.parsing.ast

<span class="keyword">import</span> scala.collection.mutable.Map

<span class="comment">//DISCLAIMER: this code is highly experimental!</span>

  <span class="comment">// TODO: avoid clashes when substituting</span>
  <span class="comment">// TODO: check binders in the same scope are distinct</span>

<span class="comment">/** &lt;p&gt;
 *    This trait provides the core Scrap-Your-Boilerplate abstractions as
 *    well as implementations for common datatypes.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Based on Ralph Laemmel's &lt;a target=&quot;_top&quot;
 *    href=&quot;http://homepages.cwi.nl/~ralf/publications.html&quot;&gt;SYB papers&lt;/a&gt;.
 *  &lt;/p&gt;
 *
 * @author Adriaan Moors 
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait Mappable extends java.lang.Object with ScalaObject</span><a id="13765">Mappable</a></span> {
  <span class="keyword">trait</span> <span class="typed"><span class="type">trait Mapper extends java.lang.Object</span><span id="68916"><a id="2163">Mapper</a></span></span> { <span class="keyword">def</span> <span class="typed"><span class="type">[T](T)(implicit (T) =&gt; Mappable.this.Mappable[T])T</span><span id="68928"><a id="68933">apply</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="68930">T</a></span> &lt;% Mappable[T]](<span class="typed"><span class="type">T</span><a id="68932">x</a></span>: <span class="typed"><span class="type">T</span><a href="#68930">T</a></span>): <span class="typed"><span class="type">T</span><a href="#68930">T</a></span> } <span class="comment">/* TODO: having type `Forall T. T =&gt; T' is too strict: 
  sometimes we want to allow `Forall T &gt;: precision. T =&gt; T' for some type `precision', so that, 
  beneath a certain threshold, we have some leeway.
  concretely: to use gmap for substitution, we simply require that ast nodes are mapped to ast nodes, 
  we can't require that the type is preserved precisely: a Name may map to e.g., a MethodCall 
  */</span>

  <span class="keyword">trait</span> <span class="typed"><span class="type">trait Mappable[T] extends java.lang.Object with ScalaObject</span><a id="68917">Mappable</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="68918">T</a></span>] {
    <span class="comment">// one-layer traversal</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Mappable.this.Mapper)T</span><a id="68935">gmap</a></span>(<span class="typed"><span class="type">Mappable.this.Mapper</span><a id="68939">f</a></span>: <span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">T</span><a href="#68918">T</a></span>
    <span class="comment">//  everywhere f x = f (gmapT (everywhere f) x)</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Mappable.this.Mapper)(implicit (T) =&gt; Mappable.this.Mappable[T])T</span><a id="68936">everywhere</a></span>(<span class="typed"><span class="type">Mappable.this.Mapper</span><a id="68940">f</a></span>: <span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68916">Mapper</a></span>)(<span class="keyword">implicit</span> <span class="typed"><span class="type">(T) =&gt; Mappable.this.Mappable[T]</span><a id="68941">c</a></span>: T =&gt; Mappable[T]): <span class="typed"><span class="type">T</span><a href="#68918">T</a></span> =
      <span class="typed"><span class="type">(T)(implicit (T) =&gt; Mappable.this.Mappable[T])T</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">(Mappable.this.Mapper)T</span><a href="#68935">gmap</a></span>(<span class="typed"><span class="type">template $anon extends java.lang.Object with Mappable.this.Mapper</span><a id="68943" class="keyword">new</a></span> <span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68916">Mapper</a></span> { <span class="keyword">def</span> <span class="typed"><span class="type">[T](T)(implicit (T) =&gt; Mappable.this.Mappable[T])T</span><span id="68945"><a id="68951">apply</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="68947">T</a></span> &lt;% Mappable[T]](<span class="typed"><span class="type">T</span><a id="68950">x</a></span>: <span class="typed"><span class="type">T</span><a href="#68947">T</a></span>): <span class="typed"><span class="type">T</span><a href="#68947">T</a></span> = <span class="typed"><span class="type">(T)Mappable.this.Mappable[T]</span><a href="../../../Function1.scala.html#17300">x</a></span>.<span class="typed"><span class="type">(Mappable.this.Mapper)(implicit (T) =&gt; Mappable.this.Mappable[T])T</span><a href="#68936">everywhere</a></span>(<span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68940">f</a></span>)}))
  }

  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">implicit scala.util.parsing.ast.Mappable.StringIsMappable : (String)Mappable.this.Mappable[String]</span><a id="68919">StringIsMappable</a></span>(<span class="typed"><span class="type">String</span><a id="68962">s</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">Mappable.this.Mappable[String]</span><a href="#68917">Mappable</a></span>[String] =
    <span class="typed"><span class="type">template $anon extends java.lang.Object with Mappable.this.Mappable[String]</span><a id="68969" class="keyword">new</a></span> <span class="typed"><span class="type">Mappable.this.Mappable[String]</span><a href="#68917">Mappable</a></span>[String] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Mappable.this.Mapper)String</span><a id="68971">gmap</a></span>(<span class="typed"><span class="type">Mappable.this.Mapper</span><a id="68974">f</a></span>: <span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">(String)(implicit (String) =&gt; Mappable.this.Mappable[String])String</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">String</span><a href="#68962">s</a></span>) 
    }

  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[t](List[t])(implicit (t) =&gt; Mappable.this.Mappable[t])Mappable.this.Mappable[List[t]]</span><span id="68920"><a id="68961">ListIsMappable</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="68922">t</a></span> &lt;% Mappable[t]](<span class="typed"><span class="type">List[t]</span><a id="68960">xs</a></span>: <span class="typed"><span class="type">List[t]</span><a href="../../../List.scala.html#524">List</a></span>[t]): <span class="typed"><span class="type">Mappable.this.Mappable[List[t]]</span><a href="#68917">Mappable</a></span>[List[t]] =
    <span class="typed"><span class="type">template $anon extends java.lang.Object with Mappable.this.Mappable[List[t]]</span><a id="68981" class="keyword">new</a></span> <span class="typed"><span class="type">Mappable.this.Mappable[List[t]]</span><a href="#68917">Mappable</a></span>[List[t]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Mappable.this.Mapper)List[t]</span><a id="68983">gmap</a></span>(<span class="typed"><span class="type">Mappable.this.Mapper</span><a id="68986">f</a></span>: <span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">List[t]</span><a href="../../../List.scala.html#524">List</a></span>[t] = (<span class="keyword">for</span> (<span class="typed"><span class="type">((t) =&gt; t)List[t]</span><a href="../../../List.scala.html#20904" id="68989">x</a></span> &lt;- <span class="typed"><span class="type">List[t]</span><a href="#68960">xs</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">(t)(implicit (t) =&gt; Mappable.this.Mappable[t])t</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">t</span><a href="#68989">x</a></span>)).<span class="typed"><span class="type">=&gt; List[t]</span><a href="../../../List.scala.html#20890">toList</a></span>
    }

  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[t](Option[t])(implicit (t) =&gt; Mappable.this.Mappable[t])Mappable.this.Mappable[Option[t]]</span><span id="68923"><a id="68959">OptionIsMappable</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="68925">t</a></span> &lt;% Mappable[t]](<span class="typed"><span class="type">Option[t]</span><a id="68958">xs</a></span>: <span class="typed"><span class="type">Option[t]</span><a href="../../../Option.scala.html#932">Option</a></span>[t]): <span class="typed"><span class="type">Mappable.this.Mappable[Option[t]]</span><a href="#68917">Mappable</a></span>[Option[t]] =
    <span class="typed"><span class="type">template $anon extends java.lang.Object with Mappable.this.Mappable[Option[t]]</span><a id="68996" class="keyword">new</a></span> <span class="typed"><span class="type">Mappable.this.Mappable[Option[t]]</span><a href="#68917">Mappable</a></span>[Option[t]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Mappable.this.Mapper)Option[t]</span><a id="68998">gmap</a></span>(<span class="typed"><span class="type">Mappable.this.Mapper</span><a id="69001">f</a></span>: <span class="typed"><span class="type">Mappable.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">Option[t]</span><a href="../../../Option.scala.html#932">Option</a></span>[t] = (<span class="keyword">for</span> (<span class="typed"><span class="type">((t) =&gt; t)Option[t]</span><a href="../../../Option.scala.html#18277" id="69004">x</a></span> &lt;- <span class="typed"><span class="type">Option[t]</span><a href="#68958">xs</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">(t)(implicit (t) =&gt; Mappable.this.Mappable[t])t</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">t</span><a href="#69004">x</a></span>))
    }
}

<span class="comment">/** &lt;p&gt;
 *    This component provides functionality for enforcing variable binding
 *    during parse-time.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *   When parsing simple languages, like Featherweight Scala, these parser
 *   combinators will fully enforce the binding discipline. When names are
 *   allowed to be left unqualified, these mechanisms would have to be
 *   complemented by an extra phase that resolves names that couldn't be
 *   resolved using the naive binding rules. (Maybe some machinery to
 *   model `implicit' binders (e.g., `this' and imported qualifiers) 
 *   and selection on a binder will suffice?)
 * &lt;/p&gt;
 *
 * @author Adriaan Moors 
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait Binders extends java.lang.Object with scala.util.parsing.ast.AbstractSyntax with scala.util.parsing.ast.Mappable with ScalaObject</span><a id="13729">Binders</a></span> <span class="keyword">extends</span> <span class="typed"><span class="type">scala.util.parsing.ast.AbstractSyntax</span><a href="AbstractSyntax.scala.html#13708">AbstractSyntax</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">scala.util.parsing.ast.Mappable</span><a href="#13765">Mappable</a></span> {
  <span class="comment">/** A `Scope' keeps track of one or more syntactic elements that represent bound names.
   * The elements it contains share the same scope and must all be distinct (wrt. ==)
   *
   * A `NameElement' `n' in the AST that is conceptually bound by a `Scope' `s', is replaced by a 
   * `BoundElement(n, s)'. (For example, in `val x:Int=x+1', the first `x' is modelled by a
   * Scope `s' that contains `x' and the second `x' is represented by a `BoundElement(`x', s)')
   * The term (`x+1') in scope of the Scope becomes an `UnderBinder(s, `x+1').
   *
   * A `NameElement' `n' is bound by a `Scope' `s' if it is wrapped as a `BoundElement(`n', s)', and 
   * `s' has a binder element that is semantically equal (`equals' or `==') to `n'.
   *
   * A `Scope' is represented textually by its list of binder elements, followed by the scope's `id'.
   * For example: `[x, y]!1' represents the scope with `id' `1' and binder elements `x' and `y'.
   * (`id' is solely used for this textual representation.)
   */</span>
  <span class="keyword">class</span> <span class="typed"><span class="type">class Scope[binderType &lt;: Binders.this.NameElement] extends java.lang.Object with Iterable[binderType] with ScalaObject</span><a id="69010">Scope</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69011">binderType</a></span> &lt;: NameElement] <span class="keyword">extends</span> <span class="typed"><span class="type">Iterable[binderType]</span><a href="../../../Iterable.scala.html#401">Iterable</a></span>[binderType]{
    <span class="keyword">private</span> <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.Map[binderType,Binders.this.Element]</span><span id="69060"><a id="69059">substitution</a></span></span>: <span class="typed"><span class="type">scala.collection.mutable.Map[binderType,Binders.this.Element]</span><a href="../../../collection/mutable/Map.scala.html#11125">Map</a></span>[binderType, Element] = 
      <span class="typed"><span class="type">()scala.collection.jcl.LinkedHashMap[binderType,Binders.this.Element]</span><a href="../../../collection/jcl/LinkedHashMap.scala.html#52047" class="keyword">new</a></span> scala.collection.jcl.<span class="typed"><span class="type">scala.collection.jcl.LinkedHashMap[binderType,Binders.this.Element]</span><a href="../../../collection/jcl/LinkedHashMap.scala.html#8830">LinkedHashMap</a></span>[binderType, Element] <span class="comment">// a LinkedHashMap is ordered by insertion order -- important!</span>
    
    <span class="comment">/** Returns a unique number identifying this Scope (only used for representation purposes).
     */</span>
    <span class="keyword">val</span> <span class="typed"><span class="type">Int</span><span id="69062"><a id="69061">id</a></span></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">object Binders.this._Binder</span><a href="#69054">_Binder</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="#69113">genId</a></span>
    
    <span class="comment">/** Returns the binders in this scope.
     * For a typical let-binding, this is just the variable name. For an argument list to a method body,
     * there is one binder per formal argument.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Iterator[binderType]</span><a id="69063">elements</a></span> = <span class="typed"><span class="type">=&gt; scala.collection.mutable.Map[binderType,Binders.this.Element]</span><a href="#69059">substitution</a></span>.<span class="typed"><span class="type">=&gt; Iterator[binderType]</span><a href="../../../collection/Map.scala.html#21394">keys</a></span>    
    
    <span class="comment">/** Return the `i'th binder in this scope.*/</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Int)binderType</span><a id="69064">apply</a></span>(<span class="typed"><span class="type">Int</span><a id="69142">i</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span> = <span class="typed"><span class="type">=&gt; Iterator[binderType]</span><a href="#69063">elements</a></span>.<span class="typed"><span class="type">(Int)binderType</span><a href="../../../List.scala.html#20903">toList</a></span>(<span class="typed"><span class="type">Int</span><a href="#69142">i</a></span>)
    
    <span class="comment">/** Returns true if this container has a binder equal (==) to `b'
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(binderType)Boolean</span><a id="69065">binds</a></span>(<span class="typed"><span class="type">binderType</span><a id="69147">b</a></span>: <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">=&gt; scala.collection.mutable.Map[binderType,Binders.this.Element]</span><a href="#69059">substitution</a></span>.<span class="typed"><span class="type">(binderType)Boolean</span><a href="../../../collection/Map.scala.html#21392">contains</a></span>(<span class="typed"><span class="type">binderType</span><a href="#69147">b</a></span>)
    
    <span class="keyword">def</span> <span class="typed"><span class="type">(binderType)Option[Int]</span><a id="69066">indexFor</a></span>(<span class="typed"><span class="type">binderType</span><a id="69148">b</a></span>: <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span>): <span class="typed"><span class="type">Option[Int]</span><a href="../../../Option.scala.html#932">Option</a></span>[Int] = {
      <span class="keyword">val</span> <span class="typed"><span class="type">&lt;refinement&gt; extends java.lang.Object with CountedIterator[binderType]</span><a id="69149">iter</a></span> = <span class="typed"><span class="type">=&gt; Iterator[binderType]</span><a href="#69063">elements</a></span>.<span class="typed"><span class="type">=&gt; &lt;refinement&gt; extends java.lang.Object with CountedIterator[binderType]</span><a href="../../../Iterator.scala.html#20029">counted</a></span>
      <span class="keyword">for</span> (<span class="typed"><span class="type">((binderType) =&gt; Unit)Unit</span><a href="../../../Iterator.scala.html#20001" id="69152">that</a></span> &lt;- <span class="typed"><span class="type">&lt;refinement&gt; extends java.lang.Object with CountedIterator[binderType]</span><a href="#69149">iter</a></span>) {
        <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">binderType</span><a href="#69152">that</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="AbstractSyntax.scala.html#59141">name</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">binderType</span><a href="#69148">b</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="AbstractSyntax.scala.html#59141">name</a></span>) <span class="comment">// TODO: why do name equals and structural equals differ?</span>
          <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span> <span class="typed"><span class="type">(Int)Some[Int]</span><a href="../../../Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">&lt;refinement&gt; extends java.lang.Object with CountedIterator[binderType]</span><a href="#69149">iter</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="../../../CountedIterator.scala.html#50254">count</a></span>)
        <span class="keyword">else</span>
          <span class="typed"><span class="type">object Console</span><a href="../../../Console.scala.html#438">Console</a></span>.<span class="typed"><span class="type">(Any)Unit</span><a href="../../../Console.scala.html#31300">println</a></span>(<span class="typed"><span class="type">implicit scala.Predef.any2stringadd : (Any)scala.runtime.StringAdd</span><a href="../../../Predef.scala.html#13520">that</a></span><span class="typed"><span class="type">(String)java.lang.String</span><a href="../../../runtime/StringAdd.scala.html#19198">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;!=&quot;)</span><span class="string">&quot;!=&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">binderType</span><a href="#69148">b</a></span>)
      }
      
      <span class="typed"><span class="type">object None</span><a href="../../../Option.scala.html#534">None</a></span>
    }

    <span class="comment">/** Adds a new binder.
     * (e.g. the variable name in a local variable declaration) 
     *
     * @param b a new binder that is distinct from the existing binders in this scope, 
     *           and shares their conceptual scope
     * @pre canAddBinder(b)
     * @post binds(b)
     * @post getElementFor(b) eq b
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(binderType)Unit</span><a id="69067">addBinder</a></span>(<span class="typed"><span class="type">binderType</span><a id="69161">b</a></span>: <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span>) { <span class="typed"><span class="type">=&gt; scala.collection.mutable.Map[binderType,Binders.this.Element]</span><a href="#69059">substitution</a></span> <span class="typed"><span class="type">((binderType, Binders.this.Element))Unit</span><a href="../../../collection/mutable/Map.scala.html#21351">+=</a></span> <span class="typed"><span class="type">(binderType,binderType)(binderType, binderType)</span><a href="../../../Predef.scala.html#27947">Pair</a></span>(<span class="typed"><span class="type">binderType</span><a href="#69161">b</a></span>, <span class="typed"><span class="type">binderType</span><a href="#69161">b</a></span>) }

    <span class="comment">/** `canAddElement' indicates whether `b' may be added to this scope.
     *
     * TODO: strengthen this condition so that no binders may be added after this scope has been 
     *       linked to its `UnderBinder' (i.e., while parsing, BoundElements may be added to the Scope
     *       associated to the UnderBinder, but after that, no changes are allowed, except for substitution)?
     *
     * @returns true if `b' had not been added yet 
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(binderType)Boolean</span><a id="69068">canAddBinder</a></span>(<span class="typed"><span class="type">binderType</span><a id="69166">b</a></span>: <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(binderType)Boolean</span><a href="#69065">binds</a></span>(<span class="typed"><span class="type">binderType</span><a href="#69166">b</a></span>)

    <span class="comment">/** ``Replaces'' the bound occurrences of a contained binder by their new value.
     * The bound occurrences of `b' are not actually replaced; the scope keeps track
     * of a substitution that maps every binder to its current value. Since a `BoundElement' is
     * a proxy for the element it is bound to by its binder, `substitute' may thus be thought of
     * as replacing all the bound occurrences of the given binder `b' by their new value `value'.
     *
     * @param b    the binder whose bound occurrences should be given a new value
     * @param value the new value for the bound occurrences of `b'
     * @pre binds(b)
     * @post getElementFor(b) eq value
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(binderType,Binders.this.Element)Unit</span><a id="69069">substitute</a></span>(<span class="typed"><span class="type">binderType</span><a id="69167">b</a></span>: <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span>, <span class="typed"><span class="type">Binders.this.Element</span><a id="69168">value</a></span>: <span class="typed"><span class="type">Binders.this.Element</span><a href="AbstractSyntax.scala.html#59135">Element</a></span>): <span class="typed"><span class="type">Unit</span><a id="2167">Unit</a></span> = <span class="typed"><span class="type">=&gt; scala.collection.mutable.Map[binderType,Binders.this.Element]</span><a href="#69059">substitution</a></span>(<span class="typed"><span class="type">binderType</span><a href="#69167">b</a></span>) = <span class="typed"><span class="type">Binders.this.Element</span><a href="#69168">value</a></span>
    
    <span class="comment">/** Returns the current value for the bound occurrences of `b'.
     *
     * @param b the contained binder whose current value should be returned
     * @pre binds(b)
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(binderType)Binders.this.Element</span><a id="69070">getElementFor</a></span>(<span class="typed"><span class="type">binderType</span><a id="69169">b</a></span>: <span class="typed"><span class="type">binderType</span><a href="#69011">binderType</a></span>): <span class="typed"><span class="type">Binders.this.Element</span><a href="AbstractSyntax.scala.html#59135">Element</a></span> = <span class="typed"><span class="type">(binderType)Binders.this.Element</span><a href="../../../collection/Map.scala.html#21391">substitution</a></span>(<span class="typed"><span class="type">binderType</span><a href="#69169">b</a></span>)    

    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()String</span><a id="69071">toString</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> =  <span class="typed"><span class="type">=&gt; Iterator[binderType]</span><a href="#69063">elements</a></span>.<span class="typed"><span class="type">=&gt; List[binderType]</span><a href="../../../Iterator.scala.html#20046">toList</a></span>.<span class="typed"><span class="type">(String,String,String)String</span><a href="../../../Iterable.scala.html#17363">mkString</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;[&quot;)</span><span class="string">&quot;[&quot;</span></span>,<span class="typed"><span class="type">java.lang.String(&quot;, &quot;)</span><span class="string">&quot;, &quot;</span></span>,<span class="typed"><span class="type">java.lang.String(&quot;]&quot;)</span><span class="string">&quot;]&quot;</span></span>)<span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;!&quot;)</span><span class="string">&quot;!&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Int</span><a href="#69061">id</a></span> <span class="comment">// TODO show substitution?</span>

    <span class="comment">/** Returns a list of strings that represent the binder elements, each tagged with this scope's id.*/</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[String]</span><a id="69072">bindersToString</a></span>: <span class="typed"><span class="type">List[String]</span><a href="../../../List.scala.html#524">List</a></span>[String] = (<span class="keyword">for</span>(<span class="keyword">val</span> <span class="typed"><span class="type">((binderType) =&gt; java.lang.String)Iterator[java.lang.String]</span><a href="../../../Iterator.scala.html#19980" id="69182">b</a></span> &lt;- <span class="typed"><span class="type">=&gt; Iterator[binderType]</span><a href="#69063">elements</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">implicit scala.Predef.any2stringadd : (Any)scala.runtime.StringAdd</span><a href="../../../Predef.scala.html#13520">b</a></span><span class="typed"><span class="type">(String)java.lang.String</span><a href="../../../runtime/StringAdd.scala.html#19198">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;!&quot;)</span><span class="string">&quot;!&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Int</span><a href="#69061">id</a></span>).<span class="typed"><span class="type">=&gt; List[java.lang.String]</span><a href="../../../Iterator.scala.html#20046">toList</a></span>
    
    <span class="comment">/** Return a new inheriting scope that won't check whether binding is respected until the scope is left (so as to support forward references) **/</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Binders.this.Scope[binderType]</span><a id="69073">allowForwardRef</a></span>: <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69010">Scope</a></span>[binderType] = <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69010" class="keyword">this</a></span> <span class="comment">// TODO</span>

    <span class="comment">/** Return a nested scope -- binders entered into it won't be visible in this scope, but if this scope allows forward references, 
        the binding in the returned scope also does, and thus the check that all variables are bound is deferred until this scope is left  **/</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Binders.this.Scope[binderType]</span><a id="69074">nested</a></span>: <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69010">Scope</a></span>[binderType] = <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69010" class="keyword">this</a></span> <span class="comment">// TODO</span>
    
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Unit</span><a id="69075">onEnter</a></span> <span class="typed"><span class="type">Unit</span><span >{</span></span>}
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Unit</span><a id="69076">onLeft</a></span> <span class="typed"><span class="type">Unit</span><span >{</span></span>}
  }

  
  <span class="keyword">trait</span> <span class="typed"><span class="type">trait BindingSensitive extends java.lang.Object</span><span id="69012"><a id="2163">BindingSensitive</a></span></span> {
    <span class="comment">// would like to specify this as one method:</span>
    <span class="comment">// def alpha_==[t &lt;: NameElement](other: BoundElement[t]): Boolean</span>
    <span class="comment">// def alpha_==[bt &lt;: binderType, st &lt;: elementT](other: UnderBinder[bt, st]): Boolean </span>
  }

  <span class="comment">/** A `BoundElement' is bound in a certain scope `scope', which keeps track of the actual element that 
   * `el' stands for.                                                               
   *
   * A `BoundElement' is represented textually by its bound element, followed by its scope's `id'.
   * For example: `x@1' represents the variable `x' that is bound in the scope with `id' `1'.
   *
   * @invar scope.binds(el)
   */</span>
  <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class BoundElement[boundElement &lt;: Binders.this.NameElement] extends java.lang.Object with Binders.this.NameElement with Proxy with Binders.this.BindingSensitive with ScalaObject with Product</span><span id="19891"><span id="69015"><span id="69221"><span id="69276"><span id="69222"><span id="69223"><span id="69282"><span id="69013"><span id="69279"><span id="69220"><a id="3498">BoundElement</a></span></span></span></span></span></span></span></span></span></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><span id="69014"><span id="69281"><a id="69278">boundElement</a></span></span></span> &lt;: NameElement](<span class="typed"><span class="type">boundElement</span><span id="69195"><span id="69194"><span id="69208"><a id="69359">el</a></span></span></span></span>: <span class="typed"><span class="type">boundElement</span><a href="#69014">boundElement</a></span>, <span class="typed"><span class="type">Binders.this.Scope[boundElement]</span><span id="69197"><span id="69196"><span id="69209"><a id="69360">scope</a></span></span></span></span>: <span class="typed"><span class="type">Binders.this.Scope[boundElement]</span><a href="#69010">Scope</a></span>[boundElement]) <span class="keyword">extends</span> <span class="typed"><span class="type">Binders.this.NameElement</span><a href="AbstractSyntax.scala.html#59136">NameElement</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">Proxy</span><a href="../../../Proxy.scala.html#191">Proxy</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">Binders.this.BindingSensitive</span><a href="#69012">BindingSensitive</a></span> { 
    <span class="comment">/** Returns the element this `BoundElement' stands for. 
     * The `Proxy' trait ensures `equals', `hashCode' and `toString' are forwarded to 
     * the result of this method.
     */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Binders.this.Element</span><a id="69199">self</a></span>: <span class="typed"><span class="type">Binders.this.Element</span><a href="AbstractSyntax.scala.html#59135">Element</a></span> = <span class="typed"><span class="type">=&gt; Binders.this.Scope[boundElement]</span><a href="#69196">scope</a></span>.<span class="typed"><span class="type">(boundElement)Binders.this.Element</span><a href="#69070">getElementFor</a></span>(<span class="typed"><span class="type">=&gt; boundElement</span><a href="#69194">el</a></span>)
    
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="69200">name</a></span> = <span class="typed"><span class="type">=&gt; Binders.this.Element</span><a href="#69199">self</a></span>.<span class="typed"><span class="type">Binders.this.NameElement</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">Binders.this.NameElement</span><a href="AbstractSyntax.scala.html#59136">NameElement</a></span>].<span class="typed"><span class="type">=&gt; String</span><a href="AbstractSyntax.scala.html#59141">name</a></span> <span class="comment">// TODO: this is only safe when substituted to a NameElement, which certainly isn't required -- I want dynamic inheritance! :)</span>

    <span class="comment">// decorate element's representation with the id of the scope it's bound in</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()String</span><a id="69201">toString</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> =  <span class="keyword">super</span>.<span class="typed"><span class="type">()String</span><a href="../../../Proxy.scala.html#19225">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;@&quot;)</span><span class="string">&quot;@&quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; Binders.this.Scope[boundElement]</span><a href="#69196">scope</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="#69061">id</a></span>
    
    <span class="keyword">def</span> <span class="typed"><span class="type">[t &lt;: Binders.this.NameElement](Binders.this.BoundElement[t])Boolean</span><a id="69202">alpha_==</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69204">t</a></span> &lt;: NameElement](<span class="typed"><span class="type">Binders.this.BoundElement[t]</span><a id="69215">other</a></span>: <span class="typed"><span class="type">Binders.this.BoundElement[t]</span><a href="#69013">BoundElement</a></span>[t]): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">=&gt; Binders.this.Scope[boundElement]</span><a href="#69196">scope</a></span>.<span class="typed"><span class="type">(boundElement)Option[Int]</span><a href="#69066">indexFor</a></span>(<span class="typed"><span class="type">=&gt; boundElement</span><a href="#69194">el</a></span>) <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">Binders.this.BoundElement[t]</span><a href="#69215">other</a></span>.<span class="typed"><span class="type">=&gt; Binders.this.Scope[t]</span><a href="#69196">scope</a></span>.<span class="typed"><span class="type">(t)Option[Int]</span><a href="#69066">indexFor</a></span>(<span class="typed"><span class="type">Binders.this.BoundElement[t]</span><a href="#69215">other</a></span>.<span class="typed"><span class="type">=&gt; t</span><a href="#69194">el</a></span>)
  }  
  
  <span class="comment">/** A variable that escaped its scope (i.e., a free variable) -- we don't deal very well with these yet
   */</span>
  <span class="keyword">class</span> <span class="typed"><span class="type">class UnboundElement[N &lt;: Binders.this.NameElement] extends java.lang.Object with Binders.this.NameElement with ScalaObject</span><a id="69017">UnboundElement</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69018">N</a></span> &lt;: NameElement](<span class="keyword">private</span> <span class="keyword">val</span> <span class="typed"><span class="type">N</span><span id="69227"><span id="69226"><a id="69232">el</a></span></span></span>: <span class="typed"><span class="type">N</span><a href="#69018">N</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Binders.this.NameElement</span><a href="AbstractSyntax.scala.html#59136">NameElement</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; java.lang.String</span><a id="69229">name</a></span> = <span class="typed"><span class="type">=&gt; N</span><a href="#69226">el</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="AbstractSyntax.scala.html#59141">name</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot;@??&quot;)</span><span class="string">&quot;@??&quot;</span></span>
  }
  
  <span class="comment">// this is useless, as Element is a supertype of BoundElement --&gt; the coercion will never be inferred</span>
  <span class="comment">// if we knew a more specific type for the element that the bound element represents, this could make sense</span>
  <span class="comment">// implicit def BoundElementProxy[t &lt;: NameElement](e: BoundElement[t]): Element = e.self</span>
                                                                     
  <span class="comment">/** Represents an element with variables that are bound in a certain scope. 
   */</span>
  <span class="keyword">class</span> <span class="typed"><span class="type">class UnderBinder[binderType &lt;: Binders.this.NameElement, elementT] extends java.lang.Object with Binders.this.Element with Binders.this.BindingSensitive with ScalaObject</span><span id="69019"><span id="69093"><a id="69241">UnderBinder</a></span></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69020">binderType</a></span>  &lt;: NameElement, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69021">elementT</a></span> &lt;% Mappable[elementT]](<span class="keyword">val</span> <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><span id="69090"><span id="69089"><a id="69239">scope</a></span></span></span>: <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69010">Scope</a></span>[binderType], <span class="keyword">private</span>[Binders] <span class="keyword">val</span> <span class="typed"><span class="type">elementT</span><span id="69092"><span id="69091"><a id="69240">element</a></span></span></span>: <span class="typed"><span class="type">elementT</span><a href="#69021">elementT</a></span>) <span class="keyword">extends</span> <span class="typed"><span class="type">Binders.this.Element</span><a href="AbstractSyntax.scala.html#59135">Element</a></span> <span class="keyword">with</span> <span class="typed"><span class="type">Binders.this.BindingSensitive</span><a href="#69012">BindingSensitive</a></span> {
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()String</span><a id="69095">toString</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;(&quot;)</span><span class="string">&quot;(&quot;</span></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">=&gt; Binders.this.Scope[binderType]</span><a href="#69089">scope</a></span>.<span class="typed"><span class="type">()String</span><a href="#69071">toString</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">java.lang.String(&quot;) in { &quot;)</span><span class="string">&quot;) in { &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">=&gt; elementT</span><a href="#69091">element</a></span>.<span class="typed"><span class="type">()java.lang.String</span><a id="3498">toString</a></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span><span class="typed"><span class="type">java.lang.String(&quot; }&quot;)</span><span class="string">&quot; }&quot;</span></span>
      
    <span class="comment">/** Alpha-equivalence -- TODO
     * Returns true if the `element' of the `other' `UnderBinder' is equal to this `element' up to alpha-conversion.
     *
     * That is, regular equality is used for all elements but `BoundElement's: such an element is 
     * equal to a `BoundElement' in `other' if their binders are equal. Binders are equal if they
     * are at the same index in their respective scope. 
     *
     * Example: UnderBinder([x, y]!1, x@1) alpha_== UnderBinder([a, b]!2, a@2)
     *          ! (UnderBinder([x, y]!1, y@1) alpha_== UnderBinder([a, b]!2, a@2))
     */</span>
    <span class="comment">/*def alpha_==[bt &lt;: binderType, st &lt;: elementT](other: UnderBinder[bt, st]): Boolean = {
       var result = true
       
       // TODO: generic zip or gmap2
       element.gmap2(other.element, new Mapper2 {
         def apply[s  &lt;% Mappable[s], t  &lt;% Mappable[t]](x :{s, t}): {s, t} = x match {
           case {be1: BoundElement[_], be2: BoundElement[_]} =&gt; result == result &amp;&amp; be1.alpha_==(be2) // monadic gmap (cheating using state directly)
           case {ub1: UnderBinder[_, _], ub2: UnderBinder[_, _]} =&gt; result == result &amp;&amp; be1.alpha_==(be2)        
           case {a, b} =&gt; result == result &amp;&amp; a.equals(b)
         }; x
       })
    }*/</span>
    
    <span class="keyword">def</span> <span class="typed"><span class="type">(scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement])elementT</span><a id="69096">cloneElementWithSubst</a></span>(<span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a id="69243">subst</a></span>: scala.collection.immutable.<span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a href="../../../collection/immutable/Map.scala.html#9188">Map</a></span>[NameElement, NameElement]) = <span class="typed"><span class="type">(elementT)Binders.this.Mappable[elementT]</span><a href="../../../Function1.scala.html#17300">element</a></span>.<span class="typed"><span class="type">(Binders.this.Mapper)elementT</span><a href="#68935">gmap</a></span>(<span class="typed"><span class="type">template $anon extends java.lang.Object with Binders.this.Mapper</span><a id="69249" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.Mapper</span><a href="#68916">Mapper</a></span> { <span class="keyword">def</span> <span class="typed"><span class="type">[t](t)(implicit (t) =&gt; Binders.this.Mappable[t])t</span><span id="69251"><a id="69257">apply</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69253">t</a></span> &lt;% Mappable[t]](<span class="typed"><span class="type">t</span><a id="69256">x</a></span> :<span class="typed"><span class="type">t</span><a href="#69253">t</a></span>): <span class="typed"><span class="type">t</span><a href="#69253">t</a></span> = <span class="typed"><span class="type">t</span><a href="#69256">x</a></span> <span class="typed"><span class="type">t</span><span class="keyword">match</span></span>{
      <span class="typed"><span class="type">t</span><span class="keyword">case</span></span> <span class="typed"><span class="type">Binders.this.NameElement</span><a id="69258">substable</a></span>: <span class="typed"><span class="type">Binders.this.NameElement</span><a href="AbstractSyntax.scala.html#59136">NameElement</a></span> <span class="keyword">if</span> <span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a href="#69243">subst</a></span>.<span class="typed"><span class="type">(Binders.this.NameElement)Boolean</span><a href="../../../collection/Map.scala.html#21392">contains</a></span>(<span class="typed"><span class="type">Binders.this.NameElement</span><a href="#69258">substable</a></span>) =&gt; <span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a href="#69243">subst</a></span>.<span class="typed"><span class="type">(Binders.this.NameElement)Option[Binders.this.NameElement]</span><a href="../../../collection/Map.scala.html#21386">get</a></span>(<span class="typed"><span class="type">Binders.this.NameElement</span><a href="#69258">substable</a></span>).<span class="typed"><span class="type">t</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">t</span><a href="#69253">t</a></span>] <span class="comment">// TODO: wrong... substitution is not (necessarily) the identity function	</span>
         <span class="comment">//Console.println(&quot;substed: &quot;+substable+&quot;-&gt; &quot;+subst.get(substable)+&quot;)&quot;);</span>
      <span class="typed"><span class="type">t</span><span class="keyword">case</span></span> <span class="typed"><span class="type">t</span><a id="69259">x</a></span> =&gt; <span class="typed"><span class="type">t</span><a href="#69259">x</a></span> <span class="comment">// Console.println(&quot;subst: &quot;+x+&quot;(keys: &quot;+subst.keys+&quot;)&quot;);x</span>
    }})
    
    <span class="comment">// TODO</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; elementT</span><a id="69097">cloneElementNoBoundElements</a></span> = <span class="typed"><span class="type">(elementT)Binders.this.Mappable[elementT]</span><a href="../../../Function1.scala.html#17300">element</a></span>.<span class="typed"><span class="type">(Binders.this.Mapper)elementT</span><a href="#68935">gmap</a></span>(<span class="typed"><span class="type">template $anon extends java.lang.Object with Binders.this.Mapper</span><a id="69266" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.Mapper</span><a href="#68916">Mapper</a></span> { <span class="keyword">def</span> <span class="typed"><span class="type">[t](t)(implicit (t) =&gt; Binders.this.Mappable[t])t</span><span id="69268"><a id="69274">apply</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69270">t</a></span> &lt;% Mappable[t]](<span class="typed"><span class="type">t</span><a id="69273">x</a></span> :<span class="typed"><span class="type">t</span><a href="#69270">t</a></span>): <span class="typed"><span class="type">t</span><a href="#69270">t</a></span> = <span class="typed"><span class="type">t</span><a href="#69273">x</a></span> <span class="typed"><span class="type">t</span><span class="keyword">match</span></span>{ 
      <span class="typed"><span class="type">t</span><span class="keyword">case</span></span> <a id="1">BoundElement</a>(<span class="typed"><span class="type">Binders.this.NameElement</span><a id="69287">el</a></span>, _) =&gt; <span class="typed"><span class="type">Binders.this.UnboundElement[Binders.this.NameElement]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Binders.this.UnboundElement[Binders.this.NameElement]</span><a href="#69017">UnboundElement</a></span>(<span class="typed"><span class="type">Binders.this.NameElement</span><a href="#69287">el</a></span>).<span class="typed"><span class="type">t</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">t</span><a href="#69270">t</a></span>] <span class="comment">// TODO: precision stuff</span>
      <span class="typed"><span class="type">t</span><span class="keyword">case</span></span> <span class="typed"><span class="type">t</span><a id="69289">x</a></span> =&gt; <span class="typed"><span class="type">t</span><a href="#69289">x</a></span>
    }})

    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; elementT</span><a id="69098">extract</a></span>: <span class="typed"><span class="type">elementT</span><a href="#69021">elementT</a></span> = <span class="typed"><span class="type">=&gt; elementT</span><a href="#69097">cloneElementNoBoundElements</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement])elementT</span><a id="69099">extract</a></span>(<span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a id="69291">subst</a></span>: scala.collection.immutable.<span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a href="../../../collection/immutable/Map.scala.html#9188">Map</a></span>[NameElement, NameElement]): <span class="typed"><span class="type">elementT</span><a href="#69021">elementT</a></span> = <span class="typed"><span class="type">(scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement])elementT</span><a href="#69096">cloneElementWithSubst</a></span>(<span class="typed"><span class="type">scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]</span><a href="#69291">subst</a></span>)
    
    <span class="comment">/** Get a string representation of element, normally we don't allow direct access to element, but just getting a string representation is ok*/</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="69100">elementToString</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">=&gt; elementT</span><a href="#69091">element</a></span>.<span class="typed"><span class="type">()java.lang.String</span><a id="3498">toString</a></span>
  }
  
  <span class="comment">//SYB type class instances</span>
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[bt &lt;: Binders.this.NameElement, st](Binders.this.UnderBinder[bt,st])(implicit (bt) =&gt; Binders.this.Mappable[bt],(st) =&gt; Binders.this.Mappable[st])Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]</span><span id="69022"><span id="69084"><a id="69085">UnderBinderIsMappable</a></span></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69025">bt</a></span> &lt;: NameElement &lt;% Mappable[bt], <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69026">st</a></span> &lt;% Mappable[st]](<span class="typed"><span class="type">Binders.this.UnderBinder[bt,st]</span><a id="69083">ub</a></span>: <span class="typed"><span class="type">Binders.this.UnderBinder[bt,st]</span><a href="#69019">UnderBinder</a></span>[bt, st]): <span class="typed"><span class="type">Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]</span><a href="#68917">Mappable</a></span>[UnderBinder[bt, st]] = 
    <span class="typed"><span class="type">template $anon extends java.lang.Object with Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]</span><a id="69293" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]</span><a href="#68917">Mappable</a></span>[UnderBinder[bt, st]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Binders.this.Mapper)Binders.this.UnderBinder[bt,st]</span><a id="69295">gmap</a></span>(<span class="typed"><span class="type">Binders.this.Mapper</span><a id="69298">f</a></span>: <span class="typed"><span class="type">Binders.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">Binders.this.UnderBinder[bt,st]</span><a href="#69019">UnderBinder</a></span>[bt, st] = <span class="typed"><span class="type">(Binders.this.Scope[bt],st)(implicit (st) =&gt; Binders.this.Mappable[st])Binders.this.UnderBinder[bt,st]</span><a href="#69300">UnderBinder</a></span>(<span class="typed"><span class="type">(Binders.this.Scope[bt])(implicit (Binders.this.Scope[bt]) =&gt; Binders.this.Mappable[Binders.this.Scope[bt]])Binders.this.Scope[bt]</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">Binders.this.UnderBinder[bt,st]</span><a href="#69083">ub</a></span>.<span class="typed"><span class="type">=&gt; Binders.this.Scope[bt]</span><a href="#69089">scope</a></span>), <span class="typed"><span class="type">(st)(implicit (st) =&gt; Binders.this.Mappable[st])st</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">Binders.this.UnderBinder[bt,st]</span><a href="#69083">ub</a></span>.<span class="typed"><span class="type">=&gt; st</span><a href="#69091">element</a></span>))
    }  
  
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">[bt &lt;: Binders.this.NameElement](Binders.this.Scope[bt])(implicit (bt) =&gt; Binders.this.Mappable[bt])Binders.this.Mappable[Binders.this.Scope[bt]]</span><span id="69027"><a id="69082">ScopeIsMappable</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69029">bt</a></span> &lt;: NameElement &lt;% Mappable[bt]](<span class="typed"><span class="type">Binders.this.Scope[bt]</span><a id="69081">scope</a></span>: <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69010">Scope</a></span>[bt]): <span class="typed"><span class="type">Binders.this.Mappable[Binders.this.Scope[bt]]</span><a href="#68917">Mappable</a></span>[Scope[bt]] = 
    <span class="typed"><span class="type">template $anon extends java.lang.Object with Binders.this.Mappable[Binders.this.Scope[bt]]</span><a id="69338" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.Mappable[Binders.this.Scope[bt]]</span><a href="#68917">Mappable</a></span>[Scope[bt]] {
      <span class="keyword">def</span> <span class="typed"><span class="type">(Binders.this.Mapper)Binders.this.Scope[bt]</span><a id="69340">gmap</a></span>(<span class="typed"><span class="type">Binders.this.Mapper</span><a id="69343">f</a></span>: <span class="typed"><span class="type">Binders.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69010">Scope</a></span>[bt] = { <span class="keyword">val</span> <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a id="69344">newScope</a></span> = <span class="typed"><span class="type">Binders.this.Scope[bt]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69010">Scope</a></span>[bt]()
        <span class="keyword">for</span>(<span class="keyword">val</span> <span class="typed"><span class="type">((bt) =&gt; Unit)Unit</span><a href="../../../Iterable.scala.html#17328" id="69346">b</a></span> &lt;- <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69081">scope</a></span>) <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69344">newScope</a></span>.<span class="typed"><span class="type">(bt)Unit</span><a href="#69067">addBinder</a></span>(<span class="typed"><span class="type">(bt)(implicit (bt) =&gt; Binders.this.Mappable[bt])bt</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">bt</span><a href="#69346">b</a></span>))
        <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69344">newScope</a></span>
      }
    }  
  
  <span class="keyword">implicit</span> <span class="keyword">def</span> <span class="typed"><span class="type">implicit scala.util.parsing.ast.Binders.NameElementIsMappable : (Binders.this.NameElement)Binders.this.Mappable[Binders.this.NameElement]</span><a id="69030">NameElementIsMappable</a></span>(<span class="typed"><span class="type">Binders.this.NameElement</span><a id="69080">self</a></span>: <span class="typed"><span class="type">Binders.this.NameElement</span><a href="AbstractSyntax.scala.html#59136">NameElement</a></span>): <span class="typed"><span class="type">Binders.this.Mappable[Binders.this.NameElement]</span><a href="#68917">Mappable</a></span>[NameElement] = <span class="typed"><span class="type">template $anon extends java.lang.Object with Binders.this.Mappable[Binders.this.NameElement]</span><a id="69351" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.Mappable[Binders.this.NameElement]</span><a href="#68917">Mappable</a></span>[NameElement] {
    <span class="keyword">def</span> <span class="typed"><span class="type">(Binders.this.Mapper)Binders.this.NameElement</span><a id="69353">gmap</a></span>(<span class="typed"><span class="type">Binders.this.Mapper</span><a id="69356">f</a></span>: <span class="typed"><span class="type">Binders.this.Mapper</span><a href="#68916">Mapper</a></span>): <span class="typed"><span class="type">Binders.this.NameElement</span><a href="AbstractSyntax.scala.html#59136">NameElement</a></span> = <span class="typed"><span class="type">Binders.this.NameElement</span><a href="#69080">self</a></span> <span class="typed"><span class="type">Binders.this.NameElement</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Binders.this.BoundElement[Binders.this.NameElement]</span><span class="keyword">case</span></span> <a id="1">BoundElement</a>(<span class="typed"><span class="type">Binders.this.NameElement</span><a id="69357">el</a></span>, <span class="typed"><span class="type">Binders.this.Scope[Binders.this.NameElement]</span><a id="69358">scope</a></span>) =&gt; <span class="typed"><span class="type">(Binders.this.NameElement,Binders.this.Scope[Binders.this.NameElement])Binders.this.BoundElement[Binders.this.NameElement]</span><a href="#69276">BoundElement</a></span>(<span class="typed"><span class="type">(Binders.this.NameElement)(implicit (Binders.this.NameElement) =&gt; Binders.this.Mappable[Binders.this.NameElement])Binders.this.NameElement</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">Binders.this.NameElement</span><a href="#69357">el</a></span>), <span class="typed"><span class="type">(Binders.this.Scope[Binders.this.NameElement])(implicit (Binders.this.Scope[Binders.this.NameElement]) =&gt; Binders.this.Mappable[Binders.this.Scope[Binders.this.NameElement]])Binders.this.Scope[Binders.this.NameElement]</span><a href="#68928">f</a></span>(<span class="typed"><span class="type">Binders.this.Scope[Binders.this.NameElement]</span><a href="#69358">scope</a></span>))
      <span class="typed"><span class="type">Binders.this.NameElement</span><span class="keyword">case</span></span> _ =&gt; <span class="typed"><span class="type">(Binders.this.NameElement)Binders.this.Mappable[Binders.this.NameElement]</span><a href="#69031">UserNameElementIsMappable</a></span>(<span class="typed"><span class="type">Binders.this.NameElement</span><a href="#69080">self</a></span>).<span class="typed"><span class="type">(Binders.this.Mapper)Binders.this.NameElement</span><a href="#68935">gmap</a></span>(<span class="typed"><span class="type">Binders.this.Mapper</span><a href="#69356">f</a></span>)
    }
  }
  
  <span class="keyword">def</span> <span class="typed"><span class="type">[t &lt;: Binders.this.NameElement](t)Binders.this.Mappable[t]</span><a id="69031">UserNameElementIsMappable</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69033">t</a></span> &lt;: NameElement](<span class="typed"><span class="type">t</span><a id="69380">self</a></span>: <span class="typed"><span class="type">t</span><a href="#69033">t</a></span>): <span class="typed"><span class="type">Binders.this.Mappable[t]</span><a href="#68917">Mappable</a></span>[t]  

  <span class="keyword">object</span> <span class="typed"><span class="type">object Binders.this.UnderBinder</span><a id="69034">UnderBinder</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">[binderType &lt;: Binders.this.NameElement, elementT](Binders.this.Scope[binderType],elementT)(implicit (elementT) =&gt; Binders.this.Mappable[elementT])Binders.this.UnderBinder[binderType,elementT]</span><span id="69300"><a id="69312">apply</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69303">binderType</a></span> &lt;: NameElement, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69304">elementT</a></span> &lt;% Mappable[elementT]](<span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a id="69310">scope</a></span>: <span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69010">Scope</a></span>[binderType], <span class="typed"><span class="type">elementT</span><a id="69311">element</a></span>: <span class="typed"><span class="type">elementT</span><a href="#69304">elementT</a></span>) = <span class="typed"><span class="type">Binders.this.UnderBinder[binderType,elementT]</span><a href="#69312" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.UnderBinder[binderType,elementT]</span><a href="#69019">UnderBinder</a></span>(<span class="typed"><span class="type">Binders.this.Scope[binderType]</span><a href="#69310">scope</a></span>, <span class="typed"><span class="type">elementT</span><a href="#69311">element</a></span>) 
    <span class="keyword">def</span> <span class="typed"><span class="type">[bt &lt;: Binders.this.NameElement, elementT](elementT)(implicit (elementT) =&gt; Binders.this.Mappable[elementT])Binders.this.UnderBinder[bt,elementT]</span><span id="69305"><a id="69384">unit</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69308">bt</a></span> &lt;: NameElement, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69309">elementT</a></span> &lt;% Mappable[elementT]](<span class="typed"><span class="type">elementT</span><a id="69383">x</a></span>: <span class="typed"><span class="type">elementT</span><a href="#69309">elementT</a></span>) = <span class="typed"><span class="type">(Binders.this.Scope[bt],elementT)(implicit (elementT) =&gt; Binders.this.Mappable[elementT])Binders.this.UnderBinder[bt,elementT]</span><a href="#69300">UnderBinder</a></span>(<span class="typed"><span class="type">Binders.this.Scope[bt]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">Binders.this.Scope[bt]</span><a href="#69010">Scope</a></span>[bt](), <span class="typed"><span class="type">elementT</span><a href="#69383">x</a></span>)
  }
  
  <span class="comment">/** If a list of `UnderBinder's all have the same scope, they can be turned in to an UnderBinder 
   * containing a list of the elements in the original `UnderBinder'.
   *
   * The name `sequence' comes from the fact that this method's type is equal to the type of monadic sequence.
   *
   * @pre !orig.isEmpty implies orig.forall(ub =&gt; ub.scope eq orig(0).scope)
   * 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[bt &lt;: Binders.this.NameElement, st](List[Binders.this.UnderBinder[bt,st]])(implicit (st) =&gt; Binders.this.Mappable[st])Binders.this.UnderBinder[bt,List[st]]</span><span id="69036"><a id="69392">sequence</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69039">bt</a></span> &lt;: NameElement, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69040">st</a></span> &lt;% Mappable[st]](<span class="typed"><span class="type">List[Binders.this.UnderBinder[bt,st]]</span><a id="69391">orig</a></span>: <span class="typed"><span class="type">List[Binders.this.UnderBinder[bt,st]]</span><a href="../../../List.scala.html#524">List</a></span>[UnderBinder[bt, st]]): <span class="typed"><span class="type">Binders.this.UnderBinder[bt,List[st]]</span><a href="#69019">UnderBinder</a></span>[bt, List[st]] = 
    <span class="typed"><span class="type">Binders.this.UnderBinder[bt,List[st]]</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">List[Binders.this.UnderBinder[bt,st]]</span><a href="#69391">orig</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../../Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">object Binders.this.UnderBinder</span><a href="#69034">UnderBinder</a></span>.<span class="typed"><span class="type">(List[st])(implicit (List[st]) =&gt; Binders.this.Mappable[List[st]])Binders.this.UnderBinder[bt,List[st]]</span><a href="#69305">unit</a></span>(<span class="typed"><span class="type">object Nil</span><a href="../../../List.scala.html#333">Nil</a></span>) 
    <span class="keyword">else</span> <span class="typed"><span class="type">(Binders.this.Scope[bt],List[st])(implicit (List[st]) =&gt; Binders.this.Mappable[List[st]])Binders.this.UnderBinder[bt,List[st]]</span><a href="#69300">UnderBinder</a></span>(<span class="typed"><span class="type">(Int)Binders.this.UnderBinder[bt,st]</span><a href="../../../List.scala.html#20903">orig</a></span>(<span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>).<span class="typed"><span class="type">=&gt; Binders.this.Scope[bt]</span><a href="#69089">scope</a></span>, <span class="typed"><span class="type">List[Binders.this.UnderBinder[bt,st]]</span><a href="#69391">orig</a></span>.<span class="typed"><span class="type">((Binders.this.UnderBinder[bt,st]) =&gt; st)List[st]</span><a href="../../../List.scala.html#20904">map</a></span>(<span class="typed"><span class="type">Binders.this.UnderBinder[bt,st]</span><a href="#69411">_</a></span>.<span class="typed"><span class="type">=&gt; st</span><a href="#69091">element</a></span>))

  <span class="comment">// couldn't come up with a better name...</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[bt &lt;: Binders.this.NameElement, st](Binders.this.UnderBinder[bt,List[st]])(implicit (st) =&gt; Binders.this.Mappable[st])List[Binders.this.UnderBinder[bt,st]]</span><span id="69041"><a id="69422">unsequence</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69044">bt</a></span> &lt;: NameElement, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69045">st</a></span> &lt;% Mappable[st]](<span class="typed"><span class="type">Binders.this.UnderBinder[bt,List[st]]</span><a id="69421">orig</a></span>: <span class="typed"><span class="type">Binders.this.UnderBinder[bt,List[st]]</span><a href="#69019">UnderBinder</a></span>[bt, List[st]]): <span class="typed"><span class="type">List[Binders.this.UnderBinder[bt,st]]</span><a href="../../../List.scala.html#524">List</a></span>[UnderBinder[bt, st]] = 
    <span class="typed"><span class="type">Binders.this.UnderBinder[bt,List[st]]</span><a href="#69421">orig</a></span>.<span class="typed"><span class="type">=&gt; List[st]</span><a href="#69091">element</a></span>.<span class="typed"><span class="type">((st) =&gt; Binders.this.UnderBinder[bt,st])List[Binders.this.UnderBinder[bt,st]]</span><a href="../../../List.scala.html#20904">map</a></span>(<span class="typed"><span class="type">st</span><a id="69425">sc</a></span> =&gt; <span class="typed"><span class="type">(Binders.this.Scope[bt],st)(implicit (st) =&gt; Binders.this.Mappable[st])Binders.this.UnderBinder[bt,st]</span><a href="#69300">UnderBinder</a></span>(<span class="typed"><span class="type">Binders.this.UnderBinder[bt,List[st]]</span><a href="#69421">orig</a></span>.<span class="typed"><span class="type">=&gt; Binders.this.Scope[bt]</span><a href="#69089">scope</a></span>, <span class="typed"><span class="type">st</span><a href="#69425">sc</a></span>))

  <span class="comment">/** An environment that maps a `NameElement' to the scope in which it is bound.
   * This can be used to model scoping during parsing.
   *
   * (This class is similar to Burak's ECOOP paper on pattern matching, except that we use `=='
   *  instead of `eq', thus types can't be unified in general)
   *
   * TODO: more documentation
   */</span>
  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class BinderEnv extends java.lang.Object with ScalaObject</span><a id="69046">BinderEnv</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">[A &lt;: Binders.this.NameElement](A)Option[Binders.this.Scope[A]]</span><a id="69432">apply</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69434">A</a></span> &lt;: NameElement](<span class="typed"><span class="type">A</span><a id="69439">v</a></span>: <span class="typed"><span class="type">A</span><a href="#69434">A</a></span>): <span class="typed"><span class="type">Option[Binders.this.Scope[A]]</span><a href="../../../Option.scala.html#932">Option</a></span>[Scope[A]]
    <span class="keyword">def</span> <span class="typed"><span class="type">[a &lt;: Binders.this.NameElement](a,Binders.this.Scope[a])Binders.this.BinderEnv</span><a id="69435">extend</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69437">a</a></span> &lt;: NameElement](<span class="typed"><span class="type">a</span><a id="69440">v</a></span> : <span class="typed"><span class="type">a</span><a href="#69437">a</a></span>, <span class="typed"><span class="type">Binders.this.Scope[a]</span><a id="69441">x</a></span> : <span class="typed"><span class="type">Binders.this.Scope[a]</span><a href="#69010">Scope</a></span>[a]) = <span class="typed"><span class="type">template $anon extends Binders.this.BinderEnv</span><a id="69443" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.BinderEnv</span><a href="#69046">BinderEnv</a></span> { 
      <span class="keyword">def</span> <span class="typed"><span class="type">[b &lt;: Binders.this.NameElement](b)Option[Binders.this.Scope[b]]</span><a id="69445">apply</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69447">b</a></span> &lt;: NameElement](<span class="typed"><span class="type">b</span><a id="69449">w</a></span> : <span class="typed"><span class="type">b</span><a href="#69447">b</a></span>): <span class="typed"><span class="type">Option[Binders.this.Scope[b]]</span><a href="../../../Option.scala.html#932">Option</a></span>[Scope[b]] =  
        <span class="typed"><span class="type">Option[Binders.this.Scope[b]]</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">b</span><a href="#69449">w</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">a</span><a href="#69440">v</a></span>) <span class="typed"><span class="type">(Binders.this.Scope[b])Some[Binders.this.Scope[b]]</span><a href="../../../Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">Binders.this.Scope[a]</span><a href="#69441">x</a></span>.<span class="typed"><span class="type">Binders.this.Scope[b]</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">Binders.this.Scope[b]</span><a href="#69010">Scope</a></span>[b]]) 
        <span class="keyword">else</span> <span class="typed"><span class="type">BinderEnv.this.type</span><a href="#69046">BinderEnv</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">(b)Option[Binders.this.Scope[b]]</span><a href="#69432">apply</a></span>(<span class="typed"><span class="type">b</span><a href="#69449">w</a></span>) 
    }
  }

  <span class="keyword">object</span> <span class="typed"><span class="type">object Binders.this.EmptyBinderEnv</span><a id="69047">EmptyBinderEnv</a></span> <span class="keyword">extends</span> <span class="typed"><span class="type">Binders.this.BinderEnv</span><a href="#69046">BinderEnv</a></span> {
    <span class="keyword">def</span> <span class="typed"><span class="type">[A &lt;: Binders.this.NameElement](A)Option[Binders.this.Scope[A]]</span><a id="69461">apply</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Binders.this.NameElement</span><a id="69463">A</a></span> &lt;: NameElement](<span class="typed"><span class="type">A</span><a id="69465">v</a></span>: <span class="typed"><span class="type">A</span><a href="#69463">A</a></span>): <span class="typed"><span class="type">Option[Binders.this.Scope[A]]</span><a href="../../../Option.scala.html#932">Option</a></span>[Scope[A]] = <span class="typed"><span class="type">object None</span><a href="../../../Option.scala.html#534">None</a></span>
  }

  <span class="comment">/** Returns a given result, but executes the supplied closure before returning.
   * (The effect of this closure does not influence the returned value.)
   *
   * TODO: move this to some utility object higher in the scala hierarchy?
   *
   * @param result the result to be returned
   * @param block  code to be executed, purely for its side-effects
   */</span>
  <span class="keyword">trait</span> <span class="typed"><span class="type">trait ReturnAndDo[T] extends java.lang.Object</span><span id="69049"><a id="2163">ReturnAndDo</a></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69050">T</a></span>]{
    <span class="keyword">def</span> <span class="typed"><span class="type">(=&gt; Unit)T</span><a id="69118">andDo</a></span>(<span class="typed"><span class="type">=&gt; Unit</span><a id="69119">block</a></span>: =&gt; Unit): <span class="typed"><span class="type">T</span><a href="#69050">T</a></span>
  } <span class="comment">// gotta love Smalltalk syntax :-)</span>

  <span class="keyword">def</span> <span class="typed"><span class="type">[T](T)Binders.this.ReturnAndDo[T]</span><a id="69051">return_</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="69053">T</a></span>](<span class="typed"><span class="type">T</span><a id="69116">result</a></span>: <span class="typed"><span class="type">T</span><a href="#69053">T</a></span>): <span class="typed"><span class="type">Binders.this.ReturnAndDo[T]</span><a href="#69049">ReturnAndDo</a></span>[T] =
    <span class="typed"><span class="type">template $anon extends java.lang.Object with Binders.this.ReturnAndDo[T]</span><a id="69467" class="keyword">new</a></span> <span class="typed"><span class="type">Binders.this.ReturnAndDo[T]</span><a href="#69049">ReturnAndDo</a></span>[T] {
      <span class="keyword">val</span> <span class="typed"><span class="type">T</span><span id="69470"><a id="69469">r</a></span></span> = <span class="typed"><span class="type">T</span><a href="#69116">result</a></span>
      <span class="keyword">def</span> <span class="typed"><span class="type">(=&gt; Unit)T</span><a id="69471">andDo</a></span>(<span class="typed"><span class="type">=&gt; Unit</span><a id="69474">block</a></span>: =&gt; Unit): <span class="typed"><span class="type">T</span><a href="#69053">T</a></span> = {<span class="typed"><span class="type">=&gt; Unit</span><a href="#69474">block</a></span>; <span class="typed"><span class="type">=&gt; T</span><a href="#69469">r</a></span>}
    }

  <span class="keyword">private</span> <span class="keyword">object</span> <span class="typed"><span class="type">object Binders.this._Binder</span><a id="69054">_Binder</a></span> {
    <span class="keyword">private</span> <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><span id="69112"><span id="69110"><span id="69111"><a id="69476">currentId</a></span></span></span></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">private</span>[Binders] <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="69113">genId</a></span> = <span class="typed"><span class="type">(Int)Binders.this.ReturnAndDo[Int]</span><a href="#69051">return_</a></span>(<span class="typed"><span class="type">=&gt; Int</span><a href="#69110">currentId</a></span>) <span class="typed"><span class="type">(=&gt; Unit)Int</span><a href="#69118">andDo</a></span> {<span class="typed"><span class="type">(Int)Unit</span><a href="#69111">currentId</a></span>=<span class="typed"><span class="type">=&gt; Int</span><a href="#69110">currentId</a></span><span class="typed"><span class="type">(Int)Int</span><a id="3145">+</a></span><span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>}
  }
}

        </pre>
    </body>
</html>