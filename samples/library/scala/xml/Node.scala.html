<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/xml/Node.scala</title>
        <script type="text/javascript" src="../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: Node.scala 16893 2009-01-13 13:09:22Z cunei $</span>


<span class="keyword">package</span> scala.xml

<span class="comment">/**
 * This object provides methods ...
 *
 * @author  Burak Emir
 * @version 1.0
 */</span>
<span class="keyword">object</span> <span class="typed"><span class="type">object scala.xml.Node</span><a id="7175">Node</a></span> {

  <span class="comment">/** the constant empty attribute sequence */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a id="25451">NoAttributes</a></span>: <span class="typed"><span class="type">scala.xml.MetaData</span><a href="MetaData.scala.html#7378">MetaData</a></span> = <span class="typed"><span class="type">object scala.xml.Null</span><a href="Null.scala.html#7298">Null</a></span>

  <span class="comment">/** the empty namespace */</span>
  <span class="keyword">val</span> <span class="typed"><span class="type">java.lang.String</span><span id="25453"><a id="25452">EmptyNamespace</a></span></span> = <span class="typed"><span class="type">java.lang.String(&quot;&quot;)</span><span class="string">&quot;&quot;</span></span>

  <span class="keyword">def</span> <span class="typed"><span class="type">(scala.xml.Node)Some[(String, scala.xml.MetaData, Seq[scala.xml.Node])]</span><a id="25454">unapplySeq</a></span>(<span class="typed"><span class="type">scala.xml.Node</span><a id="97346">n</a></span>: <span class="typed"><span class="type">scala.xml.Node</span><a href="#7174">Node</a></span>) = <span class="typed"><span class="type">((String, scala.xml.MetaData, Seq[scala.xml.Node]))Some[(String, scala.xml.MetaData, Seq[scala.xml.Node])]</span><a href="../Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">(String,scala.xml.MetaData,Seq[scala.xml.Node])(String, scala.xml.MetaData, Seq[scala.xml.Node])</span><a href="../Tuple3.scala.html#21271">Tuple3</a></span>(<span class="typed"><span class="type">scala.xml.Node</span><a href="#97346">n</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="#19944">label</a></span>, <span class="typed"><span class="type">scala.xml.Node</span><a href="#97346">n</a></span>.<span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a href="#19951">attributes</a></span>, <span class="typed"><span class="type">scala.xml.Node</span><a href="#97346">n</a></span>.<span class="typed"><span class="type">=&gt; Seq[scala.xml.Node]</span><a href="#19952">child</a></span>))

}

<span class="comment">/**
 * An abstract class representing XML with nodes of a labelled tree.
 * This class contains an implementation of a subset of XPath for navigation.
 *
 * @author  Burak Emir and others
 * @version 1.1
 */</span>
<span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class Node extends scala.xml.NodeSeq with ScalaObject</span><a id="7174">Node</a></span> <span class="keyword">extends</span> <span class="typed"><span class="type">scala.xml.NodeSeq</span><a href="NodeSeq.scala.html#7291">NodeSeq</a></span> {

  <span class="comment">/** prefix of this node */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="19943">prefix</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>

  <span class="comment">/** label of this node. I.e. &quot;foo&quot; for &amp;lt;foo/&amp;gt;) */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="19944">label</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>

  <span class="comment">/** used internally. Atom/Molecule = -1 PI = -2 Comment = -3 EntityRef = -5
   */</span> 
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="19945">typeTag$</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>

  <span class="comment">/**
   *  method returning the namespace bindings of this node. by default, this
   *  is TopScope, which means there are no namespace bindings except the
   *  predefined one for &quot;xml&quot;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scala.xml.NamespaceBinding</span><a id="19946">scope</a></span>: <span class="typed"><span class="type">scala.xml.NamespaceBinding</span><a href="NamespaceBinding.scala.html#7324">NamespaceBinding</a></span> = <span class="typed"><span class="type">object scala.xml.TopScope</span><a href="TopScope.scala.html#7361">TopScope</a></span>

  <span class="comment">/**
   *  convenience, same as &lt;code&gt;getNamespace(this.prefix)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="19947">namespace</a></span> = <span class="typed"><span class="type">(String)String</span><a href="#19948">getNamespace</a></span>(<span class="typed"><span class="type">Node.this.type</span><a href="#7174" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="#19943">prefix</a></span>)

  <span class="comment">/**
   * Convenience method, same as &lt;code&gt;scope.getURI(pre)&lt;/code&gt; but additionally
   * checks if scope is &lt;code&gt;null&lt;/code&gt;.
   *
   * @param pre the prefix whose namespace name we would like to obtain
   * @return    the namespace if &lt;code&gt;scope != null&lt;/code&gt; and prefix was
   *            found, else &lt;code&gt;null&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(String)String</span><a id="19948">getNamespace</a></span>(<span class="typed"><span class="type">String</span><a id="59332">pre</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">String</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; scala.xml.NamespaceBinding</span><a href="#19946">scope</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5792">eq</a></span> <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>) <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span> <span class="keyword">else</span> <span class="typed"><span class="type">=&gt; scala.xml.NamespaceBinding</span><a href="#19946">scope</a></span>.<span class="typed"><span class="type">(String)String</span><a href="NamespaceBinding.scala.html#42707">getURI</a></span>(<span class="typed"><span class="type">String</span><a href="#59332">pre</a></span>)

  <span class="comment">/**
   * Convenience method, looks up an unprefixed attribute in attributes of this node.
   * Same as &lt;code&gt;attributes.getValue(key)&lt;/code&gt;
   *
   * @param  key of queried attribute.
   * @return value of &lt;code&gt;UnprefixedAttribute&lt;/code&gt; with given key
   *         in attributes, if it exists, otherwise &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <span class="typed"><span class="type">(String)Option[Seq[scala.xml.Node]]</span><a id="19949">attribute</a></span>(<span class="typed"><span class="type">String</span><a id="48033">key</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">Option[Seq[scala.xml.Node]]</span><a href="../Option.scala.html#932">Option</a></span>[Seq[Node]] = <span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a href="#19951">attributes</a></span>.<span class="typed"><span class="type">(String)Option[Seq[scala.xml.Node]]</span><a href="MetaData.scala.html#25478">get</a></span>(<span class="typed"><span class="type">String</span><a href="#48033">key</a></span>)

  <span class="comment">/**
   * Convenience method, looks up a prefixed attribute in attributes of this node.
   * Same as &lt;code&gt;attributes.getValue(uri, this, key)&lt;/code&gt;
   *
   * @param  uri namespace of queried attribute (may not be null).
   * @param  key of queried attribute.
   * @return value of &lt;code&gt;PrefixedAttribute&lt;/code&gt; with given namespace
   *         and given key, otherwise &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">final</span> <span class="keyword">def</span> <span class="typed"><span class="type">(String,String)Option[Seq[scala.xml.Node]]</span><a id="19950">attribute</a></span>(<span class="typed"><span class="type">String</span><a id="48031">uri</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">String</span><a id="48032">key</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">Option[Seq[scala.xml.Node]]</span><a href="../Option.scala.html#932">Option</a></span>[Seq[Node]] =
    <span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a href="#19951">attributes</a></span>.<span class="typed"><span class="type">(String,scala.xml.Node,String)Option[Seq[scala.xml.Node]]</span><a href="MetaData.scala.html#25479">get</a></span>(<span class="typed"><span class="type">String</span><a href="#48031">uri</a></span>, <span class="typed"><span class="type">scala.xml.Node</span><a href="#7174" class="keyword">this</a></span>, <span class="typed"><span class="type">String</span><a href="#48032">key</a></span>)

  <span class="comment">/**
   * Returns attribute meaning all attributes of this node, prefixed and
   * unprefixed, in no particular order. In class &lt;code&gt;Node&lt;/code&gt;, this
   * defaults to &lt;code&gt;Null&lt;/code&gt; (the empty attribute list).
   *
   * @return all attributes of this node
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a id="19951">attributes</a></span>: <span class="typed"><span class="type">scala.xml.MetaData</span><a href="MetaData.scala.html#7378">MetaData</a></span> = <span class="typed"><span class="type">object scala.xml.Null</span><a href="Null.scala.html#7298">Null</a></span>

  <span class="comment">/**
   * Returns child axis i.e. all children of this node.
   *
   * @return all children of this node
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Seq[scala.xml.Node]</span><a id="19952">child</a></span>: <span class="typed"><span class="type">Seq[scala.xml.Node]</span><a href="../Seq.scala.html#761">Seq</a></span>[Node]

  <span class="comment">/**
   * Descendant axis (all descendants of this node, not including node itself) 
   * includes all text nodes, element nodes, comments and processing instructions.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[scala.xml.Node]</span><a id="19953">descendant</a></span>: <span class="typed"><span class="type">List[scala.xml.Node]</span><a href="../List.scala.html#524">List</a></span>[Node] =
    <span class="typed"><span class="type">=&gt; Seq[scala.xml.Node]</span><a href="#19952">child</a></span>.<span class="typed"><span class="type">=&gt; List[scala.xml.Node]</span><a href="../Iterable.scala.html#17360">toList</a></span>.<span class="typed"><span class="type">((scala.xml.Node) =&gt; Iterable[scala.xml.Node])List[scala.xml.Node]</span><a href="../List.scala.html#20931">flatMap</a></span> { <span class="typed"><span class="type">scala.xml.Node</span><a id="97373">x</a></span> =&gt; <span class="typed"><span class="type">scala.xml.Node</span><a href="#97373">x</a></span><span class="typed"><span class="type">(scala.xml.Node)List[scala.xml.Node]</span><a href="../List.scala.html#20872">::</a></span><span class="typed"><span class="type">scala.xml.Node</span><a href="#97373">x</a></span>.<span class="typed"><span class="type">=&gt; List[scala.xml.Node]</span><a href="#19953">descendant</a></span> }

  <span class="comment">/**
   * Descendant axis (all descendants of this node, including thisa node) 
   * includes all text nodes, element nodes, comments and processing instructions.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[scala.xml.Node]</span><a id="19954">descendant_or_self</a></span>: <span class="typed"><span class="type">List[scala.xml.Node]</span><a href="../List.scala.html#524">List</a></span>[Node] = <span class="typed"><span class="type">scala.xml.Node</span><a href="#7174" class="keyword">this</a></span> <span class="typed"><span class="type">(scala.xml.Node)List[scala.xml.Node]</span><a href="../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">=&gt; List[scala.xml.Node]</span><a href="#19953">descendant</a></span>

  <span class="comment">/**
   * Returns true if x is structurally equal to this node. Compares prefix,
   * label, attributes and children.
   *
   * @param x ...
   * @return  &lt;code&gt;true&lt;/code&gt; if ..
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(Any)Boolean</span><a id="19955">equals</a></span>(<span class="typed"><span class="type">Any</span><a id="39882">x</a></span>: <span class="typed"><span class="type">Any</span><a id="49">Any</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">Any</span><a href="#39882">x</a></span> <span class="typed"><span class="type">Boolean</span><span class="keyword">match</span></span> {
    <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">case</span></span> <span class="typed"><span class="type">scala.xml.Group</span><a id="97380">g</a></span>:<span class="typed"><span class="type">scala.xml.Group</span><a href="Group.scala.html#7168">Group</a></span> =&gt; <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
    <span class="typed"><span class="type">Boolean</span><span class="keyword">case</span></span> <span class="typed"><span class="type">scala.xml.Node</span><a id="97381">that</a></span>: <span class="typed"><span class="type">scala.xml.Node</span><a href="#7174">Node</a></span> =&gt;
      ((<span class="typed"><span class="type">scala.xml.Node</span><a href="#97381">that</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="#19943">prefix</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">Node.this.type</span><a href="#7174" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="#19943">prefix</a></span> )
       <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span>(<span class="typed"><span class="type">scala.xml.Node</span><a href="#97381">that</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="#19944">label</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span> <span class="typed"><span class="type">Node.this.type</span><a href="#7174" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; String</span><a href="#19944">label</a></span> )
       <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span>(<span class="typed"><span class="type">scala.xml.Node</span><a href="#97381">that</a></span>.<span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a href="#19951">attributes</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="3507">==</a></span>  <span class="typed"><span class="type">Node.this.type</span><a href="#7174" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; scala.xml.MetaData</span><a href="#19951">attributes</a></span>)
       <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scala.xml.Node</span><a href="#97381">that</a></span>.<span class="typed"><span class="type">=&gt; Seq[scala.xml.Node]</span><a href="#19952">child</a></span>.<span class="typed"><span class="type">(Iterable[scala.xml.Node])Boolean</span><a href="../Iterable.scala.html#17357">sameElements</a></span>(<span class="typed"><span class="type">Node.this.type</span><a href="#7174" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; Seq[scala.xml.Node]</span><a href="#19952">child</a></span>)) <span class="comment">// sameElements</span>
    <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">case</span></span> _ =&gt; <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
  }

  <span class="comment">/** &lt;p&gt;
   *    Returns a hashcode. The default implementation here calls only
   *    super.hashcode (which is the same as for objects). A more useful
   *    implementation can be invoked by calling 
   *  &lt;code&gt;Utility.hashCode(pre, label, attributes.hashCode(), child)&lt;/code&gt;.
   *  &lt;/p&gt;
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()Int</span><a id="19956">hashCode</a></span>(): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="keyword">super</span>.<span class="typed"><span class="type">()Int</span><a id="5780">hashCode</a></span>

  <span class="comment">// implementations of NodeSeq methods</span>

  <span class="comment">/**
   *  returns a sequence consisting of only this node
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Seq[scala.xml.Node]</span><a id="19957">theSeq</a></span>: <span class="typed"><span class="type">Seq[scala.xml.Node]</span><a href="../Seq.scala.html#761">Seq</a></span>[Node] = <span class="typed"><span class="type">scala.xml.Node</span><a href="#7174" class="keyword">this</a></span> <span class="typed"><span class="type">(scala.xml.Node)List[scala.xml.Node]</span><a href="../List.scala.html#20872">::</a></span> <span class="typed"><span class="type">object Nil</span><a href="../List.scala.html#333">Nil</a></span>

  <span class="comment">/**
   * String representation of this node
   *
   * @param stripComment if true, strips comment nodes from result
   * @return ...
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Boolean)String</span><a id="19958">toString</a></span>(<span class="typed"><span class="type">Boolean</span><a id="39903">stripComment</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span>): <span class="typed"><span class="type">String</span><a id="1859">String</a></span> =
    <span class="typed"><span class="type">object scala.xml.Utility</span><a href="Utility.scala.html#7277">Utility</a></span>.<span class="typed"><span class="type">(scala.xml.Node,Boolean)String</span><a href="Utility.scala.html#25380">toXML</a></span>(<span class="typed"><span class="type">scala.xml.Node</span><a href="#7174" class="keyword">this</a></span>, <span class="typed"><span class="type">Boolean</span><a href="#39903">stripComment</a></span>)

  <span class="comment">/**
   * Same as &lt;code&gt;toString(false)&lt;/code&gt;.
   *
   * @see &lt;code&gt;&lt;a href=&quot;#toString&quot;&gt;toString(Boolean)&lt;/a&gt;&lt;/code&gt;
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()String</span><a id="19959">toString</a></span>(): <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">(Boolean)String</span><a href="#19958">toString</a></span>(<span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>)

  <span class="comment">/**
   * Appends qualified name of this node to &lt;code&gt;StringBuilder&lt;/code&gt;.
   *
   * @param sb ...
   * @return   ...
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(StringBuilder)StringBuilder</span><a id="19960">nameToString</a></span>(<span class="typed"><span class="type">StringBuilder</span><a id="47914">sb</a></span>: <span class="typed"><span class="type">StringBuilder</span><a href="../StringBuilder.scala.html#1433">StringBuilder</a></span>): <span class="typed"><span class="type">StringBuilder</span><a href="../StringBuilder.scala.html#1433">StringBuilder</a></span> = {
    <span class="typed"><span class="type">Any</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5791">!=</a></span> <span class="typed"><span class="type">=&gt; String</span><a href="#19943">prefix</a></span>) {
      <span class="typed"><span class="type">StringBuilder</span><a href="#47914">sb</a></span>.<span class="typed"><span class="type">(String)StringBuilder</span><a href="../StringBuilder.scala.html#19639">append</a></span>(<span class="typed"><span class="type">=&gt; String</span><a href="#19943">prefix</a></span>)
      <span class="typed"><span class="type">StringBuilder</span><a href="#47914">sb</a></span>.<span class="typed"><span class="type">(Char)StringBuilder</span><a href="../StringBuilder.scala.html#19646">append</a></span>(<span class="typed"><span class="type">Char(':')</span><span class="char">':'</span></span>)
    }
    <span class="typed"><span class="type">StringBuilder</span><a href="#47914">sb</a></span>.<span class="typed"><span class="type">(String)StringBuilder</span><a href="../StringBuilder.scala.html#19639">append</a></span>(<span class="typed"><span class="type">=&gt; String</span><a href="#19944">label</a></span>)
  }

  <span class="comment">/**
   * Returns a type symbol (e.g. DTD, XSD), default &lt;code&gt;null&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">()scala.xml.TypeSymbol</span><a id="19961">xmlType</a></span>(): <span class="typed"><span class="type">scala.xml.TypeSymbol</span><a href="TypeSymbol.scala.html#7336">TypeSymbol</a></span> = <span class="typed"><span class="type">Null(null)</span><span class="keyword">null</span></span>

  <span class="comment">/**
   * Returns a text representation of this node. Note that this is not equivalent to
   * the XPath node-test called text(), it is rather an implementation of the
   * XPath function string()
   *  Martin to Burak: to do: if you make this method abstract, the compiler will now
   *  complain if there's no implementation in a subclass. Is this what we want? Note that
   *  this would break doc/DocGenator and doc/ModelToXML, with an error message like:
doc\DocGenerator.scala:1219: error: object creation impossible, since there is a deferred declaration of method text in class Node of type =&gt; String which is not implemented in a subclass
    new SpecialNode {
    ^
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="19962">text</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="keyword">super</span>.<span class="typed"><span class="type">=&gt; String</span><a href="NodeSeq.scala.html#19941">text</a></span>
}

        </pre>
    </body>
</html>