<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/xml/pull/XMLEventReader.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style">
    </head>
    <body>
        <pre>
/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */

// $Id: XMLEventReader.scala 18387 2009-07-24 15:28:37Z odersky $

<span class="keyword">package</span> scala.xml
<span class="keyword">package</span> pull

<span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue
<span class="keyword">import</span> java.nio.channels.ClosedChannelException

<span class="keyword">import</span> scala.io.Source
<span class="keyword">import</span> scala.xml.parsing.{ ExternalSources, MarkupHandler, MarkupParser }

/** &lt;p&gt;
 *   A pull parser that offers to view an XML document as a series of events.
 *   Example usage:
 *  &lt;/p&gt;&lt;pre&gt;
 *  &lt;b&gt;import&lt;/b&gt; scala.xml.pull._
 *  &lt;b&gt;import&lt;/b&gt; scala.io.Source
 *
 *  &lt;b&gt;object&lt;/b&gt; reader {
 *    &lt;b&gt;val&lt;/b&gt; src = Source.fromString(&quot;&lt;hello&gt;&lt;world/&gt;&lt;/hello&gt;&quot;)
 *    &lt;b&gt;val&lt;/b&gt; er = new XMLEventReader(src)
 * 
 *    &lt;b&gt;def&lt;/b&gt; main(args: Array[String]) {
 *      while (er.hasNext)
 *        Console.println(er.next)
 *    }
 *  }
 *  &lt;/pre&gt;
 *
 *  @author Burak Emir
 *  @author Paul Phillips
 */

<span class="keyword">class</span> <a title="class XMLEventReader extends java.lang.Object with scala.xml.pull.ProducerConsumerIterator[scala.xml.pull.XMLEvent] with ScalaObject" id="14735">XMLEventReader</a><a href="../../ScalaObject.scala.html#969" title="ScalaObject">(</a><a title="scala.io.Source" id="158083">src</a>: <a href="../../io/Source.scala.html#9903" title="scala.io.Source">Source</a>) <span class="keyword">extends</span> <a href="#14711" title="scala.xml.pull.ProducerConsumerIterator[scala.xml.pull.XMLEvent]">ProducerConsumerIterator</a>[XMLEvent]
{
  // We implement a pull parser as an iterator, but since we may be operating on
  // a stream (e.g. XML over a network) there may be arbitrarily long periods when
  // the queue is empty.  Fortunately the ProducerConsumerIterator is ideally
  // suited to this task, possibly because it was written for use by this class.
    
  // to override as necessary
  <span class="keyword">val</span> <a title="Boolean" id="158068">preserveWS</a> = <span title="Boolean(true)" class="keyword">true</span>
  
  <span class="keyword">override</span> <span class="keyword">val</span> <a title="Int" id="158070">MaxQueueSize</a> = <span title="Int(1000)" class="int">1000</span>
  <span class="keyword">protected</span> case <span class="keyword">object</span> <a href="#158093" title="object XMLEventReader.this.POISON" id="158104">POISON</a> <a href="../../ScalaObject.scala.html#969" title="ScalaObject" class="keyword">extends</a> <a href="XMLEvent.scala.html#14744" title="scala.xml.pull.XMLEvent">XMLEvent</a>
  <span class="keyword">val</span> <a title="object XMLEventReader.this.POISON" id="158074">EndOfStream</a> = <a href="#158104" title="object XMLEventReader.this.POISON">POISON</a>
  
  // thread machinery
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> <a title="XMLEventReader.this.Parser" id="158076">parser</a> = <span title="XMLEventReader.this.Parser" class="keyword">new</span> <a href="#158079" title="XMLEventReader.this.Parser">Parser</a>(<a href="#158083" title="scala.io.Source">src</a>)
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> <a title="java.lang.Thread" id="158077">parserThread</a> = <a title="(x$1: java.lang.Runnable,x$2: java.lang.String)java.lang.Thread" id="37345" class="keyword">new</a> <a title="java.lang.Thread" id="1840">Thread</a>(<a href="#158076" title="XMLEventReader.this.Parser">parser</a>, <span title="java.lang.String(&quot;XMLEventReader&quot;)" class="string">&quot;XMLEventReader&quot;</span>)
  <a href="#158077" title="java.lang.Thread">parserThread</a>.<a title="()Unit" id="37357">start</a>
  // enqueueing the poison object is the reliable way to cause the
  // iterator to terminate; hasNext will return false once it sees it.
  // Calling interrupt() on the parserThread is the only way we can get
  // it to stop producing tokens since it's lost deep in document() -
  // we cross our fingers the interrupt() gets to its target, but if it
  // fails for whatever reason the iterator correctness is not impacted,
  // only performance (because it will finish the entire XML document,
  // or at least as much as it can fit in the queue.)
  <span class="keyword">def</span> <a title="=&gt; Unit" id="158078">stop</a> = {
    <a href="#158060" title="(x: scala.xml.pull.XMLEvent)Unit">produce</a>(<a href="#158104" title="object XMLEventReader.this.POISON">POISON</a>)
    <a href="#158077" title="java.lang.Thread">parserThread</a>.<span title="()Unit">interrupt</span>()
  }
  
  <span class="keyword">private</span> <span class="keyword">class</span> <a title="class Parser extends scala.xml.parsing.MarkupHandler with scala.xml.parsing.MarkupParser with scala.xml.parsing.ExternalSources with Runnable with ScalaObject" id="158079">Parser</a><a href="../../ScalaObject.scala.html#969" title="ScalaObject">(</a><span class="keyword">val</span> <a title="scala.io.Source" id="158120">input</a>: <a href="../../io/Source.scala.html#9903" title="scala.io.Source">Source</a>) <span class="keyword">extends</span> <a href="../parsing/MarkupHandler.scala.html#12220" title="scala.xml.parsing.MarkupHandler">MarkupHandler</a> <span class="keyword">with</span> <a href="../parsing/MarkupParser.scala.html#12169" title="scala.xml.parsing.MarkupParser">MarkupParser</a> <span class="keyword">with</span> <a href="../parsing/ExternalSources.scala.html#12223" title="scala.xml.parsing.ExternalSources">ExternalSources</a> <span class="keyword">with</span> <a title="Runnable" id="1822">Runnable</a> {
    <span class="keyword">val</span> <a title="Boolean" id="158109">preserveWS</a> = <a href="#14735" title="XMLEventReader.this.type">XMLEventReader</a>.<span class="keyword">this</span>.<a href="#158068" title="=&gt; Boolean">preserveWS</a>

    // this is Parser's way to add to the queue - the odd return type
    // is to conform to MarkupHandler's interface
    <span class="keyword">def</span> <a title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq" id="158111">setEvent</a>(<a title="scala.xml.pull.XMLEvent*" id="158163">es</a>: <a title="scala.xml.pull.XMLEvent*" id="4191">XMLEvent</a>*): <a href="../NodeSeq.scala.html#8591" title="scala.xml.NodeSeq">NodeSeq</a> = {
      <a href="../../collection/generic/IterableTemplate.scala.html#17394" title="(f: (scala.xml.pull.XMLEvent) =&gt; Unit)Unit">es</a> foreach <a href="#158060" title="(x: scala.xml.pull.XMLEvent)Unit">produce</a>        
      <a href="../NodeSeq.scala.html#8592" title="object scala.xml.NodeSeq">NodeSeq</a>.<a href="../NodeSeq.scala.html#26631" title="=&gt; scala.xml.NodeSeq">Empty</a>
    }

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(pos: Int,pre: String,label: String,attrs: scala.xml.MetaData,scope: scala.xml.NamespaceBinding)Unit" id="158112">elemStart</a>(<a title="Int" id="158183">pos</a>: <span title="Int">Int</span>, <a title="String" id="158184">pre</a>: <span title="String">String</span>, <a title="String" id="158185">label</a>: <span title="String">String</span>, <a title="scala.xml.MetaData" id="158186">attrs</a>: <a href="../MetaData.scala.html#8654" title="scala.xml.MetaData">MetaData</a>, <a title="scala.xml.NamespaceBinding" id="158187">scope</a>: <a href="../NamespaceBinding.scala.html#8828" title="scala.xml.NamespaceBinding">NamespaceBinding</a>) {
      <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a><span title="Unit">(</span><a href="XMLEvent.scala.html#158190" title="(pre: String,label: String,attrs: scala.xml.MetaData,scope: scala.xml.NamespaceBinding)scala.xml.pull.EvElemStart">EvElemStart</a>(<a href="#158184" title="String">pre</a>, <a href="#158185" title="String">label</a>, <a href="#158186" title="scala.xml.MetaData">attrs</a>, <a href="#158187" title="scala.xml.NamespaceBinding">scope</a>))
    }
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="(pos: Int,pre: String,label: String)Unit" id="158113">elemEnd</a>(<a title="Int" id="158235">pos</a>: <span title="Int">Int</span>, <a title="String" id="158236">pre</a>: <span title="String">String</span>, <a title="String" id="158237">label</a>: <span title="String">String</span>) { 
      <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a><span title="Unit">(</span><a href="XMLEvent.scala.html#158240" title="(pre: String,label: String)scala.xml.pull.EvElemEnd">EvElemEnd</a>(<a href="#158236" title="String">pre</a>, <a href="#158237" title="String">label</a>))
    }

    // this is a dummy to satisfy MarkupHandler's API
    <span class="keyword">final</span> <span class="keyword">def</span> <a title="(pos: Int,pre: String,label: String,attrs: scala.xml.MetaData,pscope: scala.xml.NamespaceBinding,nodes: scala.xml.NodeSeq)scala.xml.NodeSeq" id="158114">elem</a>(<a title="Int" id="158267">pos</a>: <span title="Int">Int</span>, <a title="String" id="158268">pre</a>: <span title="String">String</span>, <a title="String" id="158269">label</a>: <span title="String">String</span>, <a title="scala.xml.MetaData" id="158270">attrs</a>: <a href="../MetaData.scala.html#8654" title="scala.xml.MetaData">MetaData</a>, <a title="scala.xml.NamespaceBinding" id="158271">pscope</a>: <a href="../NamespaceBinding.scala.html#8828" title="scala.xml.NamespaceBinding">NamespaceBinding</a>, <a title="scala.xml.NodeSeq" id="158272">nodes</a>: <a href="../NodeSeq.scala.html#8591" title="scala.xml.NodeSeq">NodeSeq</a>): <a href="../NodeSeq.scala.html#8591" title="scala.xml.NodeSeq">NodeSeq</a> = &lt;<a href="../Elem.scala.html#8633" title="scala.xml.Elem">ignore</a>/&gt;

    <span class="keyword">def</span> <a title="(pos: Int,target: String,txt: String)scala.xml.NodeSeq" id="158115">procInstr</a>(<a title="Int" id="158276">pos</a>: <span title="Int">Int</span>, <a title="String" id="158277">target</a>: <span title="String">String</span>, <a title="String" id="158278">txt</a>: <span title="String">String</span>)  = <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a>(<a href="XMLEvent.scala.html#158282" title="(target: String,text: String)scala.xml.pull.EvProcInstr">EvProcInstr</a>(<a href="#158277" title="String">target</a>, <a href="#158278" title="String">txt</a>))
    <span class="keyword">def</span> <a title="(pos: Int,txt: String)scala.xml.NodeSeq" id="158116">comment</a>(<a title="Int" id="158309">pos</a>: <span title="Int">Int</span>, <a title="String" id="158310">txt</a>: <span title="String">String</span>)                    = <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a>(<a href="XMLEvent.scala.html#158314" title="(text: String)scala.xml.pull.EvComment">EvComment</a>(<a href="#158310" title="String">txt</a>))
    <span class="keyword">def</span> <a title="(pos: Int,n: String)scala.xml.NodeSeq" id="158117">entityRef</a>(<a title="Int" id="158332">pos</a>: <span title="Int">Int</span>, <a title="String" id="158333">n</a>: <span title="String">String</span>)                    = <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a>(<a href="XMLEvent.scala.html#158337" title="(entity: String)scala.xml.pull.EvEntityRef">EvEntityRef</a>(<a href="#158333" title="String">n</a>))
    <span class="keyword">def</span> <a title="(pos: Int,txt: String)scala.xml.NodeSeq" id="158118">text</a>(<a title="Int" id="158355">pos</a>: <span title="Int">Int</span>, <a title="String" id="158356">txt</a>:<span title="String">String</span>)                        = <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a>(<a href="XMLEvent.scala.html#158360" title="(text: String)scala.xml.pull.EvText">EvText</a>(<a href="#158356" title="String">txt</a>))

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()Unit" id="158119">run</a>() {
      <a href="../parsing/MarkupParser.scala.html#83883" title="(x$1: scala.io.Source)Unit">curInput</a> = <a href="#158120" title="=&gt; scala.io.Source">input</a>
      <a href="#158051" title="(body: =&gt; scala.xml.Document)Option[scala.xml.Document]">interruptibly</a> { <a href="#158079" title="Parser.this.type" class="keyword">this</a>.<a href="../parsing/MarkupParser.scala.html#83918" title="=&gt; Unit">nextch</a> ; <a href="#158079" title="Parser.this.type" class="keyword">this</a>.<a href="../parsing/MarkupParser.scala.html#83916" title="()scala.xml.Document">document</a>() }
      <a href="#158111" title="(es: scala.xml.pull.XMLEvent*)scala.xml.NodeSeq">setEvent</a><span title="Unit">(</span><a href="#158104" title="object XMLEventReader.this.POISON">POISON</a>)
    }
  }
}

// An iterator designed for one or more producers to generate
// elements, and a single consumer to iterate.  Iteration will continue
// until closeIterator() is called, after which point producers
// calling produce() will receive interruptions.
//
// Since hasNext may block indefinitely if nobody is producing,
// there is also an available() method which will return true if
// the next call hasNext is guaranteed not to block.
//
// This is not thread-safe for multiple consumers!
<span class="keyword">trait</span> <a title="trait ProducerConsumerIterator[T &gt;: Null] extends java.lang.Object with Iterator[T] with ScalaObject" id="14711">ProducerConsumerIterator</a>[<a title="&gt;: Null &lt;: Any" id="14775">T</a> &gt;: Null] <a href="../../ScalaObject.scala.html#969" title="ScalaObject" class="keyword">extends</a> <a href="../../collection/Iterator.scala.html#4301" title="Iterator[T]">Iterator</a>[T]
{
  // abstract - iterator-specific distinguished object for marking eos
  <span class="keyword">val</span> <a title="=&gt; T" id="158048">EndOfStream</a>: <a href="#14775" title="T">T</a>
  
  // defaults to unbounded - override to positive Int if desired
  <span class="keyword">val</span> <a title="Int" id="158049">MaxQueueSize</a> = <span title="Int(-1)">-</span><span class="int">1</span>
  
  <span class="keyword">def</span> <a title="[T](body: =&gt; T)Option[T]" id="158051">interruptibly</a>[<a title="&gt;: Nothing &lt;: Any" id="158053">T</a>](<a title="=&gt; T" id="158381">body</a>: =&gt; T): <a href="../../Option.scala.html#789" title="Option[T]">Option</a>[T] = <span class="keyword">try</span> <a href="../../Option.scala.html#19907" title="(x: T)Some[T]">Some</a>(<a href="#158381" title="=&gt; T">body</a>) <span class="keyword">catch</span> {
    <span title="None.type" class="keyword">case</span> _: <a title="java.lang.InterruptedException" id="1522">InterruptedException</a>    =&gt; <a title="object java.lang.Thread" id="1841">Thread</a>.<a title="()java.lang.Thread" id="37327">currentThread</a>.<span title="()Unit">interrupt</span>() ; <a href="../../Option.scala.html#472" title="object None">None</a>
    <span title="None.type" class="keyword">case</span> _: <a title="java.nio.channels.ClosedChannelException" id="24182">ClosedChannelException</a>  =&gt; <a href="../../Option.scala.html#472" title="object None">None</a>
  }    
  
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">lazy</span> <span class="keyword">val</span> <a title="java.util.concurrent.LinkedBlockingQueue[T]" id="158055">queue</a> =
    <span title="java.util.concurrent.LinkedBlockingQueue[T]" class="keyword">if</span> (<a href="#158049" title="(x$1: Int)Boolean" id="2969">MaxQueueSize</a> &lt; <span title="Int(0)" class="int">0</span>) <span title="java.util.concurrent.LinkedBlockingQueue[T]" class="keyword">new</span> <span title="java.util.concurrent.LinkedBlockingQueue[T]">LinkedBlockingQueue</span>[T]()
    <span class="keyword">else</span> <a title="(x$1: Int)java.util.concurrent.LinkedBlockingQueue[T]" id="75501" class="keyword">new</a> <span title="java.util.concurrent.LinkedBlockingQueue[T]">LinkedBlockingQueue</span>[T](<a href="#158049" title="=&gt; Int">MaxQueueSize</a>)
  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> <a title="T" id="158056">buffer</a>: <a href="#14775" title="T">T</a> = _
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="158057">fillBuffer</a>() = {
    <a href="#158056" title="T">buffer</a> = <a href="#158051" title="(body: =&gt; T)Option[T]">interruptibly</a><a href="../../Option.scala.html#19870" title="(default: =&gt; T)T">(</a><a href="#158054" title="=&gt; java.util.concurrent.LinkedBlockingQueue[T]">queue</a>.<a title="()T" id="75523">take</a>) getOrElse <a href="#158048" title="=&gt; T">EndOfStream</a>
    <a href="#158058" title="(x: T)Boolean">isElement</a>(<a href="#158056" title="T">buffer</a>)
  }
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="(x: T)Boolean" id="158058">isElement</a>(<a title="T" id="158461">x</a>: <a href="#14775" title="T">T</a>) = <a href="#158461" title="(x$1: Any)Boolean">x</a> <span title="(x$1: Boolean)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> &amp;&amp; <a href="#158461" title="(x$1: Any)Boolean">x</a> != <a href="#158048" title="=&gt; T">EndOfStream</a>  
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()Boolean" id="158059">eos</a>() = <a href="#158056" title="(x$1: Any)Boolean">buffer</a> == <a href="#158048" title="=&gt; T">EndOfStream</a>
  
  // public producer interface - this is the only method producers call, so
  // LinkedBlockingQueue's synchronization is all we need.
  <span class="keyword">def</span> <a title="(x: T)Unit" id="158060">produce</a>(<a title="T" id="158152">x</a>: <a href="#14775" title="T">T</a>): <a title="Unit" id="1963">Unit</a> = <span title="Unit" class="keyword">if</span> (<span title="=&gt; Boolean">!</span><a href="#158059" title="()Boolean">eos</a>) <a href="#158051" title="(body: =&gt; Unit)Option[Unit]">interruptibly</a><span title="Unit">(</span><a href="#158054" title="(x$1: T)Unit" id="75510">queue</a> put <a href="#158152" title="T">x</a>)

  // consumer/iterator interface - we need not synchronize access to buffer
  // because we required there to be only one consumer.
  <span class="keyword">def</span> <a title="()Boolean" id="158061">hasNext</a>() = <span title="(x$1: Boolean)Boolean">!</span><a href="#158059" title="()Boolean">eos</a> &amp;&amp; (<a href="#158056" title="(x$1: Any)Boolean">buffer</a> <span title="(x$1: Boolean)Boolean">!=</span> <span title="Null(null)" class="keyword">null</span> || <a href="#158057" title="()Boolean">fillBuffer</a>)
  <span class="keyword">def</span> <a title="()T" id="158062">next</a>() = {
    <span title="Unit" class="keyword">if</span> (<a href="#158059" title="()Boolean">eos</a>) <span title="Nothing" class="keyword">throw</span> <a title="(x$1: java.lang.String)java.util.NoSuchElementException" id="19773" class="keyword">new</a> <a href="../../Predef.scala.html#16276" title="java.util.NoSuchElementException">NoSuchElementException</a>(<span title="java.lang.String(&quot;ProducerConsumerIterator&quot;)" class="string">&quot;ProducerConsumerIterator&quot;</span>)
    <span title="AnyVal with NotNull" class="keyword">if</span> (<a href="#158056" title="(x$1: Any)Boolean">buffer</a> == <span title="Null(null)" class="keyword">null</span>) <a href="#158057" title="()Boolean">fillBuffer</a>
    
    <a href="#158064" title="()T">drainBuffer</a>
  }
  <span class="keyword">def</span> <a title="()Boolean" id="158063">available</a>() = <a href="#158058" title="(x: T)Boolean">isElement</a><span title="(x$1: Boolean)Boolean">(</span><a href="#158056" title="T">buffer</a>) || <a href="#158058" title="(x: T)Boolean">isElement</a>(<a href="#158054" title="=&gt; java.util.concurrent.LinkedBlockingQueue[T]">queue</a>.<a title="()T" id="75530">peek</a>)
  
  <span class="keyword">private</span> <span class="keyword">def</span> <a title="()T" id="158064">drainBuffer</a>() = {
    <a href="../../Predef.scala.html#16318" title="(assertion: Boolean)Unit">assert</a>(<span title="=&gt; Boolean">!</span><a href="#158059" title="()Boolean">eos</a>)
    <span class="keyword">val</span> <a title="T" id="158520">res</a> = <a href="#158056" title="T">buffer</a>
    <a href="#158056" title="T">buffer</a> = <span title="Null(null)" class="keyword">null</span>
    <a href="#158520" title="T">res</a>
  }
}

        </pre>
    </body>
</html>