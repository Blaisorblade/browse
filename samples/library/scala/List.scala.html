<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scala/List.scala</title>
        <script type="text/javascript" src="../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: List.scala 17340 2009-03-20 13:41:07Z michelou $</span>


<span class="keyword">package</span> scala

<span class="keyword">import</span> scala.collection.mutable.{ListBuffer, LinkedHashMap}
<span class="keyword">import</span> annotation.tailrec
<span class="keyword">import</span> Predef._

<span class="comment">/** This object provides methods for creating specialized lists, and for
 *  transforming special kinds of lists (e.g. lists of lists).
 *
 *  @author  Martin Odersky and others
 *  @version 1.0, 15/07/2003
 */</span>
<span class="keyword">object</span> <span class="typed"><span class="type">object List</span><a id="525">List</a></span> {

  <span class="comment">/** Create a list with given elements.
   *
   *  @param xs the elements to put in the list
   *  @return the list containing elements xs.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](A*)List[A]</span><a id="16977">apply</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16979">A</a></span>](<span class="typed"><span class="type">A*</span><a id="21299">xs</a></span>: <span class="typed"><span class="type">A*</span><a id="2739">A</a></span>*): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">A*</span><a href="#21299">xs</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="Iterable.scala.html#17360">toList</a></span>

  <span class="comment">/** for unapply matching
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](List[A])Some[List[A]]</span><a id="16980">unapplySeq</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16982">A</a></span>](<span class="typed"><span class="type">List[A]</span><a id="60622">x</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">Some[List[A]]</span><a href="Option.scala.html#305">Some</a></span>[List[A]] = <span class="typed"><span class="type">(List[A])Some[List[A]]</span><a href="Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#60622">x</a></span>)

  <span class="comment">/** Create a sorted list of all integers in a range.
   *
   *  @param from the start value of the list
   *  @param end the end value of the list
   *  @return the sorted list of all integers in range [from;end).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int,Int)List[Int]</span><a id="16983">range</a></span>(<span class="typed"><span class="type">Int</span><a id="67120">start</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="67121">end</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[Int]</span><a href="#524">List</a></span>[Int] =
    <span class="typed"><span class="type">(Int,Int,Int)List[Int]</span><a href="#16984">range</a></span>(<span class="typed"><span class="type">Int</span><a href="#67120">start</a></span>, <span class="typed"><span class="type">Int</span><a href="#67121">end</a></span>, <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)

  <span class="comment">/** Create a list with element values
   * &lt;code&gt;v&lt;sub&gt;n+1&lt;/sub&gt; = v&lt;sub&gt;n&lt;/sub&gt; + step&lt;/code&gt;
   * where &lt;code&gt;v&lt;sub&gt;0&lt;/sub&gt; = start&lt;/code&gt;
   * and elements are in the range between &lt;code&gt;start&lt;/code&gt; (inclusive)
   * and &lt;code&gt;end&lt;/code&gt; (exclusive)
   *
   *  @param start the start value of the list
   *  @param end  the end value of the list
   *  @param step the increment value of the list
   *  @return     the sorted list of all integers in range [start;end).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int,Int,Int)List[Int]</span><a id="16984">range</a></span>(<span class="typed"><span class="type">Int</span><a id="67117">start</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="67118">end</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="67119">step</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[Int]</span><a href="#524">List</a></span>[Int] = {
    <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#67119">step</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)
      <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.lang.IllegalArgumentException</span><a id="21630" class="keyword">new</a></span> <span class="typed"><span class="type">java.lang.IllegalArgumentException</span><a href="Predef.scala.html#13341">IllegalArgumentException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;step is zero&quot;)</span><span class="string">&quot;step is zero&quot;</span></span>)
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a id="118568">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[Int]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118569">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#67117">start</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118570" class="keyword">while</a></span> ((<span class="typed"><span class="type">Int</span><a href="#67119">step</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3142">&lt;=</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">Int</span><a href="#118569">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#67118">end</a></span>) <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> (<span class="typed"><span class="type">Int</span><a href="#67119">step</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3144">&gt;=</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">Int</span><a href="#118569">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int</span><a href="#67118">end</a></span>)) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="#118568">b</a></span> <span class="typed"><span class="type">(Int)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">Int</span><a href="#118569">i</a></span>
      <span class="typed"><span class="type">Int</span><a href="#118569">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int</span><a href="#67119">step</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="#118568">b</a></span>.<span class="typed"><span class="type">=&gt; List[Int]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Create a sorted list with element values
   * &lt;code&gt;v&lt;sub&gt;n+1&lt;/sub&gt; = step(v&lt;sub&gt;n&lt;/sub&gt;)&lt;/code&gt;
   * where &lt;code&gt;v&lt;sub&gt;0&lt;/sub&gt; = start&lt;/code&gt;
   * and elements are in the range between &lt;code&gt;start&lt;/code&gt; (inclusive)
   * and &lt;code&gt;end&lt;/code&gt; (exclusive)
   *
   *  @param start the start value of the list
   *  @param end  the end value of the list
   *  @param step the increment function of the list, which given &lt;code&gt;v&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt;,
   *              computes &lt;code&gt;v&lt;sub&gt;n+1&lt;/sub&gt;&lt;/code&gt;. Must be monotonically increasing
   *              or decreasing.
   *  @return     the sorted list of all integers in range [start;end).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int,Int,(Int) =&gt; Int)List[Int]</span><a id="16985">range</a></span>(<span class="typed"><span class="type">Int</span><a id="67114">start</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="67115">end</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">(Int) =&gt; Int</span><a id="67116">step</a></span>: Int =&gt; Int): <span class="typed"><span class="type">List[Int]</span><a href="#524">List</a></span>[Int] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">Boolean</span><a id="118601">up</a></span> = <span class="typed"><span class="type">(Int)Int</span><a href="Function1.scala.html#17300">step</a></span>(<span class="typed"><span class="type">Int</span><a href="#67114">start</a></span>) <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int</span><a href="#67114">start</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">Boolean</span><a id="118602">down</a></span> = <span class="typed"><span class="type">(Int)Int</span><a href="Function1.scala.html#17300">step</a></span>(<span class="typed"><span class="type">Int</span><a href="#67114">start</a></span>) <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#67114">start</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a id="118603">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[Int]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118604">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#67114">start</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118605" class="keyword">while</a></span> ((<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">Boolean</span><a href="#118601">up</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">Int</span><a href="#118604">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#67115">end</a></span>) <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">Boolean</span><a href="#118602">down</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">Int</span><a href="#118604">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int</span><a href="#67115">end</a></span>)) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="#118603">b</a></span> <span class="typed"><span class="type">(Int)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">Int</span><a href="#118604">i</a></span>
      <span class="keyword">val</span> <span class="typed"><span class="type">Int</span><a id="118610">next</a></span> = <span class="typed"><span class="type">(Int)Int</span><a href="Function1.scala.html#17300">step</a></span>(<span class="typed"><span class="type">Int</span><a href="#118604">i</a></span>)
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#118604">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span> <span class="typed"><span class="type">Int</span><a href="#118610">next</a></span>)
        <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.lang.IllegalArgumentException</span><a id="21630" class="keyword">new</a></span> <span class="typed"><span class="type">java.lang.IllegalArgumentException</span><a href="Predef.scala.html#13341">IllegalArgumentException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;the step function did not make any progress on &quot;)</span><span class="string">&quot;the step function did not make any progress on &quot;</span></span><span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">Int</span><a href="#118604">i</a></span>)
      <span class="typed"><span class="type">Int</span><a href="#118604">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#118610">next</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="#118603">b</a></span>.<span class="typed"><span class="type">=&gt; List[Int]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Create a list containing several copies of an element.
   *
   *  @param n    the length of the resulting list
   *  @param elem the element composing the resulting list
   *  @return     a list composed of n elements all equal to elem
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](Int,A)List[A]</span><a id="16986">make</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16988">A</a></span>](<span class="typed"><span class="type">Int</span><a id="118615">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">A</span><a id="118616">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#16988">A</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="118617">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118618">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="typed"><span class="type">Unit</span><a href="#118619" class="keyword">while</a></span> (<span class="typed"><span class="type">Int</span><a href="#118618">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#118615">n</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118617">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">A</span><a href="#118616">elem</a></span>
      <span class="typed"><span class="type">Int</span><a href="#118618">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118617">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Create a list by applying a function to successive integers.
   *
   *  @param n     the length of the resulting list
   *  @param maker the procedure which, given an integer &lt;code&gt;n&lt;/code&gt;,
   *               returns the nth element of the resulting list, where
   *               &lt;code&gt;n&lt;/code&gt; is in interval &lt;code&gt;[0;n)&lt;/code&gt;.
   *  @return      the list obtained by applying the maker function to
   *               successive integers from 0 to n (exclusive).
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](Int,(Int) =&gt; A)List[A]</span><a id="16989">tabulate</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16991">A</a></span>](<span class="typed"><span class="type">Int</span><a id="118643">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">(Int) =&gt; A</span><a id="118644">maker</a></span>: Int =&gt; A): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="118645">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118646">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="typed"><span class="type">Unit</span><a href="#118647" class="keyword">while</a></span> (<span class="typed"><span class="type">Int</span><a href="#118646">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#118643">n</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118645">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">(Int)A</span><a href="Function1.scala.html#17300">maker</a></span>(<span class="typed"><span class="type">Int</span><a href="#118646">i</a></span>)
      <span class="typed"><span class="type">Int</span><a href="#118646">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118645">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Concatenate all the elements of a given list of lists.
   *
   *  @param xss the list of lists that are to be concatenated
   *  @return    the concatenation of all the lists
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](List[List[A]])List[A]</span><a id="16992">flatten</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16994">A</a></span>](<span class="typed"><span class="type">List[List[A]]</span><a id="118671">xss</a></span>: <span class="typed"><span class="type">List[List[A]]</span><a href="#524">List</a></span>[List[A]]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">(List[A]*)List[A]</span><a href="#16995">concat</a></span>(<span class="typed"><span class="type">List[List[A]]</span><a href="#118671">xss</a></span>: _*)

  <span class="comment">/** Concatenate all the argument lists into a single list.
   *
   *  @param xss the lists that are to be concatenated
   *  @return the concatenation of all the lists
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](List[A]*)List[A]</span><a id="16995">concat</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16997">A</a></span>](<span class="typed"><span class="type">List[A]*</span><a id="118672">xss</a></span>: <span class="typed"><span class="type">List[A]*</span><a id="2739">List</a></span>[A]*): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = { 
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="118674">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A] 
    <span class="keyword">for</span> (<span class="typed"><span class="type">((List[A]) =&gt; Unit)Unit</span><a href="Iterable.scala.html#17328" id="118676">xs</a></span> &lt;- <span class="typed"><span class="type">List[A]*</span><a href="#118672">xss</a></span>) {
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118677">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118676">xs</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#118678" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#118677">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118674">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118677">xc</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
        <span class="typed"><span class="type">List[A]</span><a href="#118677">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118677">xc</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      }
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118674">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Transforms a list of pairs into a pair of lists.
   *
   *  @param xs the list of pairs to unzip
   *  @return a pair of lists.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](List[(A, B)])(List[A], List[B])</span><a id="16998">unzip</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17001">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17002">B</a></span>](<span class="typed"><span class="type">List[(A, B)]</span><a id="118680">xs</a></span>: <span class="typed"><span class="type">List[(A, B)]</span><a href="#524">List</a></span>[(A,B)]): <span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[B]) = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="118681">b1</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="118682">b2</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[(A, B)]</span><a id="118683">xc</a></span> = <span class="typed"><span class="type">List[(A, B)]</span><a href="#118680">xs</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118684" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[(A, B)]</span><a href="#118683">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118681">b1</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[(A, B)]</span><a href="#118683">xc</a></span>.<span class="typed"><span class="type">=&gt; (A, B)</span><a href="#20869">head</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="Tuple2.scala.html#19161">_1</a></span>
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118682">b2</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[(A, B)]</span><a href="#118683">xc</a></span>.<span class="typed"><span class="type">=&gt; (A, B)</span><a href="#20869">head</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="Tuple2.scala.html#19163">_2</a></span>
      <span class="typed"><span class="type">List[(A, B)]</span><a href="#118683">xc</a></span> = <span class="typed"><span class="type">List[(A, B)]</span><a href="#118683">xc</a></span>.<span class="typed"><span class="type">=&gt; List[(A, B)]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">(List[A],List[B])(List[A], List[B])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118681">b1</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>, <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118682">b2</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>)
  }

  <span class="comment">/** Transforms an iterable of pairs into a pair of lists.
   *
   *  @param xs the iterable of pairs to unzip
   *  @return a pair of lists.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](Iterable[(A, B)])(List[A], List[B])</span><a id="17003">unzip</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17006">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17007">B</a></span>](<span class="typed"><span class="type">Iterable[(A, B)]</span><a id="118690">xs</a></span>: <span class="typed"><span class="type">Iterable[(A, B)]</span><a href="Iterable.scala.html#401">Iterable</a></span>[(A,B)]): <span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[B]) = 
      <span class="typed"><span class="type">Iterable[(A, B)]</span><a href="#118690">xs</a></span>.<span class="typed"><span class="type">((List[A], List[B]))(((A, B), (List[A], List[B])) =&gt; (List[A], List[B]))(List[A], List[B])</span><a href="Iterable.scala.html#17339">foldRight</a></span>[<span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[B])](<span class="typed"><span class="type">(object Nil,object Nil)(object Nil, object Nil)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>, <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>)) <span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#20366">{</a></span>
        <span class="typed"><span class="type">(List[A], List[B])</span><span class="keyword">case</span></span> <a id="1">(</a><a id="1">(</a><span class="typed"><span class="type">A</span><a id="118698">x</a></span>, <span class="typed"><span class="type">B</span><a id="118699">y</a></span>), <a id="1">(</a><span class="typed"><span class="type">List[A]</span><a id="118700">xs</a></span>, <span class="typed"><span class="type">List[B]</span><a id="118701">ys</a></span>)) =&gt; <span class="typed"><span class="type">(List[A],List[B])(List[A], List[B])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">A</span><a href="#118698">x</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118700">xs</a></span>, <span class="typed"><span class="type">B</span><a href="#118699">y</a></span> <span class="typed"><span class="type">(B)List[B]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[B]</span><a href="#118701">ys</a></span>)
      }

  <span class="comment">/** 
   * Returns the &lt;code&gt;Left&lt;/code&gt; values in the given &lt;code&gt;Iterable&lt;/code&gt; of &lt;code&gt;Either&lt;/code&gt;s.
   */</span> 
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](Iterable[Either[A,B]])List[A]</span><a id="17008">lefts</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17011">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17012">B</a></span>](<span class="typed"><span class="type">Iterable[Either[A,B]]</span><a id="118710">es</a></span>: <span class="typed"><span class="type">Iterable[Either[A,B]]</span><a href="Iterable.scala.html#401">Iterable</a></span>[Either[A, B]]) = 
    <span class="typed"><span class="type">Iterable[Either[A,B]]</span><a href="#118710">es</a></span>.<span class="typed"><span class="type">(List[A])((Either[A,B], List[A]) =&gt; List[A])List[A]</span><a href="Iterable.scala.html#17339">foldRight</a></span>[<span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]](<span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>)((<span class="typed"><span class="type">Either[A,B]</span><a id="118713">e</a></span>, <span class="typed"><span class="type">List[A]</span><a id="118714">as</a></span>) =&gt; <span class="typed"><span class="type">Either[A,B]</span><a href="#118713">e</a></span> <span class="typed"><span class="type">List[A]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <a id="1">Left</a>(<span class="typed"><span class="type">A</span><a id="118715">a</a></span>) =&gt; <span class="typed"><span class="type">A</span><a href="#118715">a</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118714">as</a></span>
      <span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <a id="1">Right</a>(_) =&gt; <span class="typed"><span class="type">List[A]</span><a href="#118714">as</a></span>
    })     
 
  <span class="comment">/** 
   * Returns the &lt;code&gt;Right&lt;/code&gt; values in the given&lt;code&gt;Iterable&lt;/code&gt; of  &lt;code&gt;Either&lt;/code&gt;s.
   */</span>      
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](Iterable[Either[A,B]])List[B]</span><a id="17013">rights</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17016">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17017">B</a></span>](<span class="typed"><span class="type">Iterable[Either[A,B]]</span><a id="118719">es</a></span>: <span class="typed"><span class="type">Iterable[Either[A,B]]</span><a href="Iterable.scala.html#401">Iterable</a></span>[Either[A, B]]) = 
    <span class="typed"><span class="type">Iterable[Either[A,B]]</span><a href="#118719">es</a></span>.<span class="typed"><span class="type">(List[B])((Either[A,B], List[B]) =&gt; List[B])List[B]</span><a href="Iterable.scala.html#17339">foldRight</a></span>[<span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]](<span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>)((<span class="typed"><span class="type">Either[A,B]</span><a id="118722">e</a></span>, <span class="typed"><span class="type">List[B]</span><a id="118723">bs</a></span>) =&gt; <span class="typed"><span class="type">Either[A,B]</span><a href="#118722">e</a></span> <span class="typed"><span class="type">List[B]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">List[B]</span><span class="keyword">case</span></span> <a id="1">Left</a>(_) =&gt; <span class="typed"><span class="type">List[B]</span><a href="#118723">bs</a></span>
      <span class="typed"><span class="type">List[B]</span><span class="keyword">case</span></span> <a id="1">Right</a>(<span class="typed"><span class="type">B</span><a id="118724">b</a></span>) =&gt; <span class="typed"><span class="type">B</span><a href="#118724">b</a></span> <span class="typed"><span class="type">(B)List[B]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[B]</span><a href="#118723">bs</a></span>
    })

  <span class="comment">/** Transforms an Iterable of Eithers into a pair of lists.
   *
   *  @param xs the iterable of Eithers to separate
   *  @return a pair of lists.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](Iterable[Either[A,B]])(List[A], List[B])</span><a id="17018">separate</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17021">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17022">B</a></span>](<span class="typed"><span class="type">Iterable[Either[A,B]]</span><a id="118728">es</a></span>: <span class="typed"><span class="type">Iterable[Either[A,B]]</span><a href="Iterable.scala.html#401">Iterable</a></span>[Either[A,B]]): <span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[B]) =
      <span class="typed"><span class="type">Iterable[Either[A,B]]</span><a href="#118728">es</a></span>.<span class="typed"><span class="type">((List[A], List[B]))((Either[A,B], (List[A], List[B])) =&gt; (List[A], List[B]))(List[A], List[B])</span><a href="Iterable.scala.html#17339">foldRight</a></span>[<span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[B])](<span class="typed"><span class="type">(object Nil,object Nil)(object Nil, object Nil)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>, <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>)) <span class="typed"><span class="type">(List[A], List[B])</span><a href="Tuple2.scala.html#20366">{</a></span>
      <span class="typed"><span class="type">(List[A], List[B])</span><span class="keyword">case</span></span> <a id="1">(</a><a id="1">Left</a>(<span class="typed"><span class="type">A</span><a id="118736">a</a></span>), <a id="1">(</a><span class="typed"><span class="type">List[A]</span><a id="118737">lefts</a></span>, <span class="typed"><span class="type">List[B]</span><a id="118738">rights</a></span>)) =&gt; <span class="typed"><span class="type">(List[A],List[B])(List[A], List[B])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">A</span><a href="#118736">a</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118737">lefts</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#118738">rights</a></span>)
      <span class="typed"><span class="type">(List[A], List[B])</span><span class="keyword">case</span></span> <a id="1">(</a><a id="1">Right</a>(<span class="typed"><span class="type">B</span><a id="118744">b</a></span>), <a id="1">(</a><span class="typed"><span class="type">List[A]</span><a id="118745">lefts</a></span>, <span class="typed"><span class="type">List[B]</span><a id="118746">rights</a></span>)) =&gt; <span class="typed"><span class="type">(List[A],List[B])(List[A], List[B])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">List[A]</span><a href="#118745">lefts</a></span>, <span class="typed"><span class="type">B</span><a href="#118744">b</a></span> <span class="typed"><span class="type">(B)List[B]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[B]</span><a href="#118746">rights</a></span>)
    }

  <span class="comment">/** Converts an iterator to a list.
   *
   *  @param it the iterator to convert
   *  @return   a list that contains the elements returned by successive
   *            calls to &lt;code&gt;it.next&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](Iterator[A])List[A]</span><a id="17023">fromIterator</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17025">A</a></span>](<span class="typed"><span class="type">Iterator[A]</span><a id="118752">it</a></span>: <span class="typed"><span class="type">Iterator[A]</span><a href="Iterator.scala.html#1337">Iterator</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">Iterator[A]</span><a href="#118752">it</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="Iterator.scala.html#20046">toList</a></span>

  <span class="comment">/** Converts an array into a list.
   *
   *  @param arr the array to convert
   *  @return    a list that contains the same elements than &lt;code&gt;arr&lt;/code&gt;
   *             in the same order
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](Array[A])List[A]</span><a id="17026">fromArray</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17028">A</a></span>](<span class="typed"><span class="type">Array[A]</span><a id="118753">arr</a></span>: <span class="typed"><span class="type">Array[A]</span><a href="Array.scala.html#1070">Array</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">(Array[A],Int,Int)List[A]</span><a href="#17029">fromArray</a></span>(<span class="typed"><span class="type">Array[A]</span><a href="#118753">arr</a></span>, <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>, <span class="typed"><span class="type">Array[A]</span><a href="#118753">arr</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="Array.scala.html#17252">length</a></span>)

  <span class="comment">/** Converts a range of an array into a list.
   *
   *  @param arr   the array to convert
   *  @param start the first index to consider
   *  @param len   the lenght of the range to convert
   *  @return      a list that contains the same elements than &lt;code&gt;arr&lt;/code&gt;
   *               in the same order
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](Array[A],Int,Int)List[A]</span><a id="17029">fromArray</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17031">A</a></span>](<span class="typed"><span class="type">Array[A]</span><a id="118755">arr</a></span>: <span class="typed"><span class="type">Array[A]</span><a href="Array.scala.html#1070">Array</a></span>[A], <span class="typed"><span class="type">Int</span><a id="118756">start</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="118757">len</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118773">res</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118774">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#118756">start</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+</a></span> <span class="typed"><span class="type">Int</span><a href="#118757">len</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118775" class="keyword">while</a></span> (<span class="typed"><span class="type">Int</span><a href="#118774">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int</span><a href="#118756">start</a></span>) {
      <span class="typed"><span class="type">Int</span><a href="#118774">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#118773">res</a></span> = <span class="typed"><span class="type">(Int)A</span><a href="Array.scala.html#17253">arr</a></span>(<span class="typed"><span class="type">Int</span><a href="#118774">i</a></span>) <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118773">res</a></span>
    }
    <span class="typed"><span class="type">List[A]</span><a href="#118773">res</a></span>
  }

  <span class="comment">/** Parses a string which contains substrings separated by a
   *  separator character and returns a list of all substrings.
   *
   *  @param str       the string to parse
   *  @param separator the separator character
   *  @return          the list of substrings
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(String,Char)List[String]</span><a id="17032">fromString</a></span>(<span class="typed"><span class="type">String</span><a id="42632">str</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>, <span class="typed"><span class="type">Char</span><a id="42633">separator</a></span>: <span class="typed"><span class="type">Char</span><a id="2387">Char</a></span>): <span class="typed"><span class="type">List[String]</span><a href="#524">List</a></span>[String] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[String]</span><a id="118802">words</a></span>: <span class="typed"><span class="type">List[String]</span><a href="#524">List</a></span>[String] = <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118803">pos</a></span> = <span class="typed"><span class="type">String</span><a href="#42632">str</a></span>.<span class="typed"><span class="type">()Int</span><a id="5819">length</a></span>()
    <span class="typed"><span class="type">Unit</span><a href="#118804" class="keyword">while</a></span> (<span class="typed"><span class="type">Int</span><a href="#118803">pos</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) {
      <span class="keyword">val</span> <span class="typed"><span class="type">Int</span><a id="118806">pos1</a></span> = <span class="typed"><span class="type">String</span><a href="#42632">str</a></span>.<span class="typed"><span class="type">(Int,Int)Int</span><a id="5845">lastIndexOf</a></span>(<span class="typed"><span class="type">implicit scala.Predef.char2int : (Char)Int</span><a href="Predef.scala.html#13631">separator</a></span>, <span class="typed"><span class="type">Int</span><a href="#118803">pos</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#118806">pos1</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#118803">pos</a></span>)
        <span class="typed"><span class="type">List[String]</span><a href="#118802">words</a></span> = <span class="typed"><span class="type">String</span><a href="#42632">str</a></span>.<span class="typed"><span class="type">(Int,Int)java.lang.String</span><a id="5853">substring</a></span>(<span class="typed"><span class="type">Int</span><a href="#118806">pos1</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>, <span class="typed"><span class="type">Int</span><a href="#118803">pos</a></span>) <span class="typed"><span class="type">(String)List[String]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[String]</span><a href="#118802">words</a></span>
      <span class="typed"><span class="type">Int</span><a href="#118803">pos</a></span> = <span class="typed"><span class="type">Int</span><a href="#118806">pos1</a></span>
    }
    <span class="typed"><span class="type">List[String]</span><a href="#118802">words</a></span>
  }

  <span class="comment">/** Returns the given string as a list of characters.
   *
   *  @param str the string to convert.
   *  @return    the string as a list of characters.
   *  @deprecated use &lt;code&gt;str.toList&lt;/code&gt; instead
   */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">(String)List[Char]</span><a id="17033">fromString</a></span>(<span class="typed"><span class="type">String</span><a id="42631">str</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">List[Char]</span><a href="#524">List</a></span>[Char] =
    <span class="typed"><span class="type">implicit scala.Predef.stringWrapper : (String)scala.runtime.RichString</span><a href="Predef.scala.html#13518">str</a></span>.<span class="typed"><span class="type">=&gt; List[Char]</span><a href="Iterable.scala.html#17360">toList</a></span>

  <span class="comment">/** Returns the given list of characters as a string.
   *
   *  @param xs the list to convert.
   *  @return   the list in form of a string.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(List[Char])String</span><a id="17034">toString</a></span>(<span class="typed"><span class="type">List[Char]</span><a id="72383">xs</a></span>: <span class="typed"><span class="type">List[Char]</span><a href="#524">List</a></span>[Char]): <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = {
    <span class="keyword">val</span> <span class="typed"><span class="type">StringBuilder</span><a id="118860">sb</a></span> = <span class="typed"><span class="type">()StringBuilder</span><a href="StringBuilder.scala.html#19620" class="keyword">new</a></span> <span class="typed"><span class="type">StringBuilder</span><a href="StringBuilder.scala.html#1433">StringBuilder</a></span>()
    <span class="keyword">var</span> <span class="typed"><span class="type">List[Char]</span><a id="118861">xc</a></span> = <span class="typed"><span class="type">List[Char]</span><a href="#72383">xs</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118862" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[Char]</span><a href="#118861">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">StringBuilder</span><a href="#118860">sb</a></span>.<span class="typed"><span class="type">(Char)StringBuilder</span><a href="StringBuilder.scala.html#19646">append</a></span>(<span class="typed"><span class="type">List[Char]</span><a href="#118861">xc</a></span>.<span class="typed"><span class="type">=&gt; Char</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[Char]</span><a href="#118861">xc</a></span> = <span class="typed"><span class="type">List[Char]</span><a href="#118861">xc</a></span>.<span class="typed"><span class="type">=&gt; List[Char]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">StringBuilder</span><a href="#118860">sb</a></span>.<span class="typed"><span class="type">()String</span><a href="StringBuilder.scala.html#19672">toString</a></span>()
  }

  <span class="comment">/** Like xs map f, but returns &lt;code&gt;xs&lt;/code&gt; unchanged if function
   *  &lt;code&gt;f&lt;/code&gt; maps all elements to themselves.
   *
   *  @param xs ...
   *  @param f  ...
   *  @return   ...
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A &lt;: AnyRef](List[A])((A) =&gt; A)List[A]</span><a id="17035">mapConserve</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: AnyRef</span><a id="17037">A</a></span> &lt;: AnyRef](<span class="typed"><span class="type">List[A]</span><a id="118869">xs</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A])(<span class="typed"><span class="type">(A) =&gt; A</span><a id="118870">f</a></span>: A =&gt; A): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A])List[A]</span><a id="118871">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a id="118872">ys</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] =
      <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[A]</span><a href="#118872">ys</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">List[A]</span><a href="#118869">xs</a></span>
      <span class="keyword">else</span> {
        <span class="keyword">val</span> <span class="typed"><span class="type">A</span><a id="118873">head0</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118872">ys</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
        <span class="keyword">val</span> <span class="typed"><span class="type">A</span><a id="118874">head1</a></span> = <span class="typed"><span class="type">(A)A</span><a href="Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">A</span><a href="#118873">head0</a></span>)
        <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">A</span><a href="#118874">head1</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5792">eq</a></span> <span class="typed"><span class="type">A</span><a href="#118873">head0</a></span>) {
          <span class="typed"><span class="type">(List[A])List[A]</span><a href="#118871">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118872">ys</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>)
        } <span class="keyword">else</span> {
          <span class="keyword">val</span> <span class="typed"><span class="type">List[A]</span><a id="118875">ys1</a></span> = <span class="typed"><span class="type">A</span><a href="#118874">head1</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">(List[A])((A) =&gt; A)List[A]</span><a href="#17035">mapConserve</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118872">ys</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>)(<span class="typed"><span class="type">(A) =&gt; A</span><a href="#118870">f</a></span>)
          <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[A]</span><a href="#118869">xs</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5792">eq</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118872">ys</a></span>) <span class="typed"><span class="type">List[A]</span><a href="#118875">ys1</a></span>
          <span class="keyword">else</span> {
            <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="118880">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
            <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118881">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118869">xs</a></span>
            <span class="typed"><span class="type">Unit</span><a href="#118882" class="keyword">while</a></span> (<span class="typed"><span class="type">List[A]</span><a href="#118881">xc</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5793">ne</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118872">ys</a></span>) {
              <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118880">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#118881">xc</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
              <span class="typed"><span class="type">List[A]</span><a href="#118881">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118881">xc</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
            }
            <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#118880">b</a></span>.<span class="typed"><span class="type">(List[A])List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32071">prependToList</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118875">ys1</a></span>)
          }
        }
      }
    <span class="typed"><span class="type">(List[A])List[A]</span><a href="#118871">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118869">xs</a></span>)
  }

  <span class="comment">/** Returns the list resulting from applying the given function &lt;code&gt;f&lt;/code&gt;
   *  to corresponding elements of the argument lists.
   *
   *  @param f function to apply to each pair of elements.
   *  @return &lt;code&gt;[f(a0,b0), ..., f(an,bn)]&lt;/code&gt; if the lists are 
   *          &lt;code&gt;[a0, ..., ak]&lt;/code&gt;, &lt;code&gt;[b0, ..., bl]&lt;/code&gt; and
   *          &lt;code&gt;n = min(k,l)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B, C](List[A],List[B])((A, B) =&gt; C)List[C]</span><a id="17038">map2</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17042">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17043">B</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17044">C</a></span>](<span class="typed"><span class="type">List[A]</span><a id="94722">xs</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[B]</span><a id="94723">ys</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B])(<span class="typed"><span class="type">(A, B) =&gt; C</span><a id="94724">f</a></span>: (A, B) =&gt; C): <span class="typed"><span class="type">List[C]</span><a href="#524">List</a></span>[C] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[C]</span><a id="118884">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[C]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[C]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[C]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118885">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#94722">xs</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118886">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#94723">ys</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118887" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#118885">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#118886">yc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[C]</span><a href="#118884">b</a></span> <span class="typed"><span class="type">(C)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">(A,B)C</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118885">xc</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#118886">yc</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[A]</span><a href="#118885">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118885">xc</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#118886">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118886">yc</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[C]</span><a href="#118884">b</a></span>.<span class="typed"><span class="type">=&gt; List[C]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Returns the list resulting from applying the given function
   *  &lt;code&gt;f&lt;/code&gt; to corresponding elements of the argument lists.
   *
   *  @param f function to apply to each pair of elements.
   *  @return  &lt;code&gt;[f(a&lt;sub&gt;0&lt;/sub&gt;,b&lt;sub&gt;0&lt;/sub&gt;,c&lt;sub&gt;0&lt;/sub&gt;),
   *           ..., f(a&lt;sub&gt;n&lt;/sub&gt;,b&lt;sub&gt;n&lt;/sub&gt;,c&lt;sub&gt;n&lt;/sub&gt;)]&lt;/code&gt;
   *           if the lists are &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, ..., a&lt;sub&gt;k&lt;/sub&gt;]&lt;/code&gt;,
   *           &lt;code&gt;[b&lt;sub&gt;0&lt;/sub&gt;, ..., b&lt;sub&gt;l&lt;/sub&gt;]&lt;/code&gt;,
   *           &lt;code&gt;[c&lt;sub&gt;0&lt;/sub&gt;, ..., c&lt;sub&gt;m&lt;/sub&gt;]&lt;/code&gt; and
   *           &lt;code&gt;n = min(k,l,m)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B, C, D](List[A],List[B],List[C])((A, B, C) =&gt; D)List[D]</span><a id="17045">map3</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17050">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17051">B</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17052">C</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17053">D</a></span>](<span class="typed"><span class="type">List[A]</span><a id="118890">xs</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[B]</span><a id="118891">ys</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B], <span class="typed"><span class="type">List[C]</span><a id="118892">zs</a></span>: <span class="typed"><span class="type">List[C]</span><a href="#524">List</a></span>[C])(<span class="typed"><span class="type">(A, B, C) =&gt; D</span><a id="118893">f</a></span>: (A, B, C) =&gt; D): <span class="typed"><span class="type">List[D]</span><a href="#524">List</a></span>[D] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[D]</span><a id="118894">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[D]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[D]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[D]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118895">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118890">xs</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118896">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118891">ys</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[C]</span><a id="118897">zc</a></span> = <span class="typed"><span class="type">List[C]</span><a href="#118892">zs</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118898" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#118895">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#118896">yc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[C]</span><a href="#118897">zc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[D]</span><a href="#118894">b</a></span> <span class="typed"><span class="type">(D)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">(A,B,C)D</span><a href="Function3.scala.html#23948">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118895">xc</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#118896">yc</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[C]</span><a href="#118897">zc</a></span>.<span class="typed"><span class="type">=&gt; C</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[A]</span><a href="#118895">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118895">xc</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#118896">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118896">yc</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[C]</span><a href="#118897">zc</a></span> = <span class="typed"><span class="type">List[C]</span><a href="#118897">zc</a></span>.<span class="typed"><span class="type">=&gt; List[C]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[D]</span><a href="#118894">b</a></span>.<span class="typed"><span class="type">=&gt; List[D]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Tests whether the given predicate &lt;code&gt;p&lt;/code&gt; holds 
   *  for all corresponding elements of the argument lists.
   *
   *  @param p function to apply to each pair of elements.
   *  @return  &lt;code&gt;(p(a&lt;sub&gt;0&lt;/sub&gt;,b&lt;sub&gt;0&lt;/sub&gt;) &amp;amp;&amp;amp;
   *           ... &amp;amp;&amp;amp; p(a&lt;sub&gt;n&lt;/sub&gt;,b&lt;sub&gt;n&lt;/sub&gt;))]&lt;/code&gt;
   *           if the lists are &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, ..., a&lt;sub&gt;k&lt;/sub&gt;]&lt;/code&gt;;
   *           &lt;code&gt;[b&lt;sub&gt;0&lt;/sub&gt;, ..., b&lt;sub&gt;l&lt;/sub&gt;]&lt;/code&gt;
   *           and &lt;code&gt;n = min(k,l)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](List[A],List[B])((A, B) =&gt; Boolean)Boolean</span><a id="17054">forall2</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17057">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17058">B</a></span>](<span class="typed"><span class="type">List[A]</span><a id="118902">xs</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[B]</span><a id="118903">ys</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B])(<span class="typed"><span class="type">(A, B) =&gt; Boolean</span><a id="118904">f</a></span>: (A, B) =&gt; Boolean): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118905">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118902">xs</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118906">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118903">ys</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118907" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#118905">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#118906">yc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A,B)Boolean</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118905">xc</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#118906">yc</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span> <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#118905">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118905">xc</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#118906">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118906">yc</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
  }

  <span class="comment">/** Tests whether the given predicate &lt;code&gt;p&lt;/code&gt; holds
   *  for some corresponding elements of the argument lists.
   *
   *  @param p function to apply to each pair of elements.
   *  @return  &lt;code&gt;n != 0 &amp;amp;&amp;amp; (p(a&lt;sub&gt;0&lt;/sub&gt;,b&lt;sub&gt;0&lt;/sub&gt;) ||
   *           ... || p(a&lt;sub&gt;n&lt;/sub&gt;,b&lt;sub&gt;n&lt;/sub&gt;))]&lt;/code&gt; if the lists are
   *           &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, ..., a&lt;sub&gt;k&lt;/sub&gt;]&lt;/code&gt;,
   *           &lt;code&gt;[b&lt;sub&gt;0&lt;/sub&gt;, ..., b&lt;sub&gt;l&lt;/sub&gt;]&lt;/code&gt; and
   *           &lt;code&gt;n = min(k,l)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A, B](List[A],List[B])((A, B) =&gt; Boolean)Boolean</span><a id="17059">exists2</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17062">A</a></span>,<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17063">B</a></span>](<span class="typed"><span class="type">List[A]</span><a id="118910">xs</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[B]</span><a id="118911">ys</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B])(<span class="typed"><span class="type">(A, B) =&gt; Boolean</span><a id="118912">f</a></span>: (A, B) =&gt; Boolean): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118913">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118910">xs</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118914">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118911">ys</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118915" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#118913">xc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#118914">yc</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A,B)Boolean</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#118913">xc</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#118914">yc</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span> <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#118913">xc</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118913">xc</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#118914">yc</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118914">yc</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
  }

  <span class="comment">/** Transposes a list of lists.
   *  pre: All element lists have the same length.
   *
   *  @param xss the list of lists
   *  @return    the transposed list of lists
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[A](List[List[A]])List[List[A]]</span><a id="17064">transpose</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="17066">A</a></span>](<span class="typed"><span class="type">List[List[A]]</span><a id="118918">xss</a></span>: <span class="typed"><span class="type">List[List[A]]</span><a href="#524">List</a></span>[List[A]]): <span class="typed"><span class="type">List[List[A]]</span><a href="#524">List</a></span>[List[A]] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[List[A]]</span><a id="118919">buf</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[List[A]]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[List[A]]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[List[A]]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[List[A]]</span><a id="118920">yss</a></span> = <span class="typed"><span class="type">List[List[A]]</span><a href="#118918">xss</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118921" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[List[A]]</span><a href="#118920">yss</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20869">head</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[List[A]]</span><a href="#118919">buf</a></span> <span class="typed"><span class="type">(List[A])Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> (<span class="typed"><span class="type">List[List[A]]</span><a href="#118920">yss</a></span> <span class="typed"><span class="type">((List[A]) =&gt; A)List[A]</span><a href="#20904">map</a></span> (<span class="typed"><span class="type">List[A]</span><a href="#118926">_</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>))
      <span class="typed"><span class="type">List[List[A]]</span><a href="#118920">yss</a></span> = (<span class="typed"><span class="type">List[List[A]]</span><a href="#118920">yss</a></span> <span class="typed"><span class="type">((List[A]) =&gt; List[A])List[List[A]]</span><a href="#20904">map</a></span> (<span class="typed"><span class="type">List[A]</span><a href="#118930">_</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>))
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[List[A]]</span><a href="#118919">buf</a></span>.<span class="typed"><span class="type">=&gt; List[List[A]]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Lists with ordered elements are ordered
  implicit def list2ordered[a &lt;% Ordered[a]](x: List[a]): Ordered[List[a]] = new Ordered[List[a]] {
    def compare [b &gt;: List[a] &lt;% Ordered[b]](y: b): Int = y match {
      case y1: List[a] =&gt; compareLists(x, y1);
      case _ =&gt; -(y compare x)
    }
    private def compareLists(xs: List[a], ys: List[a]): Int = {
      if (xs.isEmpty &amp;&amp; ys.isEmpty) 0
      else if (xs.isEmpty) -1
      else if (ys.isEmpty) 1
      else {
        val s = xs.head compare ys.head;
        if (s != 0) s
        else compareLists(xs.tail, ys.tail)
      }
    }
  }
   */</span>
}

<span class="comment">/** A class representing an ordered collection of elements of type
 *  &lt;code&gt;a&lt;/code&gt;. This class comes with two implementing case
 *  classes &lt;code&gt;scala.Nil&lt;/code&gt; and &lt;code&gt;scala.::&lt;/code&gt; that
 *  implement the abstract members &lt;code&gt;isEmpty&lt;/code&gt;,
 *  &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt;.
 *
 *  @author  Martin Odersky and others
 *  @version 1.0, 16/07/2003
 */</span>
<span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="typed"><span class="type">class List[+A] extends java.lang.Object with Seq[A] with Product with ScalaObject</span><a id="524">List</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="16627">A</a></span>] <span class="keyword">extends</span> <span class="typed"><span class="type">Seq[A]</span><a href="Seq.scala.html#761">Seq</a></span>[A] <span class="keyword">with</span> <span class="typed"><span class="type">Product</span><a href="Product.scala.html#800">Product</a></span> {

  <span class="comment">/** Returns true if the list does not contain any elements.
   *  @return &lt;code&gt;true&lt;/code&gt;, iff the list is empty.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="20868">isEmpty</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span>

  <span class="comment">/** Returns this first element of the list.
   *
   *  @return the first element of this list.
   *  @throws Predef.NoSuchElementException if the list is empty.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; A</span><a id="20869">head</a></span>: <span class="typed"><span class="type">A</span><a href="#16627">A</a></span>

  <span class="comment">/** Result of comparing &lt;code&gt;length&lt;/code&gt; with operand &lt;code&gt;l&lt;/code&gt;.
   *  returns &lt;code&gt;x&lt;/code&gt; where
   *  &lt;code&gt;x &amp;lt; 0&lt;/code&gt;    iff    &lt;code&gt;this.length &amp;lt; l&lt;/code&gt;
   *  &lt;code&gt;x == 0&lt;/code&gt;   iff    &lt;code&gt;this.length == l&lt;/code&gt;
   *  &lt;code&gt;x &amp;gt; 0&lt;/code&gt;    iff    &lt;code&gt;this.length &amp;gt; that&lt;/code&gt;.
   *
   *  This method is used by matching streams against right-ignoring (...,_*) patterns.
   *  
   *  This method does not call &lt;code&gt;List.length&lt;/code&gt;, it works for &lt;code&gt;O(l)&lt;/code&gt;,
   *  not for &lt;code&gt;O(length)&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(Int)Int</span><a id="20870">lengthCompare</a></span>(<span class="typed"><span class="type">Int</span><a id="118932">l</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>) = {
    <span class="typed"><span class="type">Int</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int</span><a href="#118932">l</a></span>
    <span class="keyword">else</span> <span class="typed"><span class="type">Int</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#118932">l</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3142">&lt;=</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    <span class="keyword">else</span> <span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>.<span class="typed"><span class="type">(Int)Int</span><a href="#20870">lengthCompare</a></span>(<span class="typed"><span class="type">Int</span><a href="#118932">l</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)
  }

  <span class="comment">/** Returns this list without its first element.
   *
   *  @return this list without its first element.
   *  @throws Predef.NoSuchElementException if the list is empty.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="20871">tail</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]

  <span class="comment">/** &lt;p&gt;
   *    Add an element &lt;code&gt;x&lt;/code&gt; at the beginning of this list.
   *  &lt;/p&gt;
   *
   *  @param x the element to prepend.
   *  @return  the list with &lt;code&gt;x&lt;/code&gt; added at the beginning.
   *  @ex &lt;code&gt;1 :: List(2, 3) = List(2, 3).::(1) = List(1, 2, 3)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B)List[B]</span><a id="20872">::</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20874">B</a></span> &gt;: A] (<span class="typed"><span class="type">B</span><a id="21307">x</a></span>: <span class="typed"><span class="type">B</span><a href="#20874">B</a></span>): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] =
    <span class="typed"><span class="type">::[B]</span><span class="keyword">new</span></span> scala.<span class="typed"><span class="type">::[B]</span><a href="#242">::</a></span>(<span class="typed"><span class="type">B</span><a href="#21307">x</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>)

  <span class="comment">/** &lt;p&gt;
   *    Add an element &lt;code&gt;x&lt;/code&gt; at the end of this list.
   *  &lt;/p&gt;
   *
   *  @deprecated Replace uses of &lt;code&gt;l + e&lt;/code&gt; with &lt;code&gt;l ::: List(e)&lt;/code&gt;.
   * 
   *  @param x the element to append.
   *  @return  the list with &lt;code&gt;x&lt;/code&gt; added at the end.
   */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B)List[B]</span><a id="20875">+</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20877">B</a></span> &gt;: A](<span class="typed"><span class="type">B</span><a id="118965">x</a></span>: <span class="typed"><span class="type">B</span><a href="#20877">B</a></span>): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] =
    <span class="typed"><span class="type">List[B]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">(B*)List[B]</span><a href="#16977">List</a></span>(<span class="typed"><span class="type">B</span><a href="#118965">x</a></span>)
    <span class="keyword">else</span> {
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="118967">buf</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
      <span class="typed"><span class="type">List.this.type</span><a href="#524" class="keyword">this</a></span> <span class="typed"><span class="type">(scala.collection.mutable.Buffer[B])Unit</span><a href="Iterable.scala.html#17354">copyToBuffer</a></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118967">buf</a></span>
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118967">buf</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">B</span><a href="#118965">x</a></span>
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118967">buf</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
    }

  <span class="comment">/** &lt;p&gt;
   *    Returns a list resulting from the concatenation of the given
   *    list &lt;code&gt;prefix&lt;/code&gt; and this list. 
   *  &lt;/p&gt;
   *
   *  @param prefix the list to concatenate at the beginning of this list.
   *  @return the concatenation of the two lists.
   *  @ex &lt;code&gt;List(1, 2) ::: List(3, 4) = List(3, 4).:::(List(1, 2)) = List(1, 2, 3, 4)&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](List[B])List[B]</span><a id="20878">:::</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20880">B</a></span> &gt;: A](<span class="typed"><span class="type">List[B]</span><a id="21301">prefix</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] =
    <span class="typed"><span class="type">List[B]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">List[B]</span><a href="#21301">prefix</a></span>
    <span class="keyword">else</span> {
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="118970">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
      <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118971">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#21301">prefix</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#118972" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#118971">those</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118970">b</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[B]</span><a href="#118971">those</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>
        <span class="typed"><span class="type">List[B]</span><a href="#118971">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118971">those</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
      }
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#118970">b</a></span>.<span class="typed"><span class="type">(List[B])List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32071">prependToList</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>)
    }

  <span class="comment">/** Appends two list objects.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](Iterable[B])List[B]</span><a id="20881">++</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20883">B</a></span> &gt;: A](<span class="typed"><span class="type">Iterable[B]</span><a id="118974">that</a></span>: <span class="typed"><span class="type">Iterable[B]</span><a href="Iterable.scala.html#401">Iterable</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] =
    <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span> <span class="typed"><span class="type">(List[B])List[B]</span><a href="#20878">:::</a></span> <span class="typed"><span class="type">Iterable[B]</span><a href="#118974">that</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="Iterable.scala.html#17360">toList</a></span>

  <span class="comment">/** Reverse the given prefix and append the current list to that.
   *  This function is equivalent to an application of &lt;code&gt;reverse&lt;/code&gt;
   *  on the prefix followed by a call to &lt;code&gt;:::&lt;/code&gt;, but more
   *  efficient.
   *
   *  @param prefix the prefix to reverse and then prepend
   *  @return       the concatenation of the reversed prefix and the current list.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](List[B])List[B]</span><a id="20884">reverse_:::</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20886">B</a></span> &gt;: A](<span class="typed"><span class="type">List[B]</span><a id="118978">prefix</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118979">these</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="118980">pres</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118978">prefix</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#118981" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#118980">pres</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">List[B]</span><a href="#118979">these</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118980">pres</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span> <span class="typed"><span class="type">(B)List[B]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[B]</span><a href="#118979">these</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#118980">pres</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#118980">pres</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">List[B]</span><a href="#118979">these</a></span>
  }

  <span class="comment">/** Returns the number of elements in the list.
   *
   *  @return the number of elements in the list.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="20887">length</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="118986">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="118987">len</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="typed"><span class="type">Unit</span><a href="#118988" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#118986">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Int</span><a href="#118987">len</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#118986">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#118986">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Int</span><a href="#118987">len</a></span>
  }

  <span class="comment">/** Creates a list with all indices in the list. This is
   *  equivalent to a call to &lt;code&gt;List.range(0, xs.length)&lt;/code&gt;.
   *
   *  @return a list of all indices in the list.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[Int]</span><a id="20888">indices</a></span>: <span class="typed"><span class="type">List[Int]</span><a href="#524">List</a></span>[Int] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a id="119013">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[Int]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="119014">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119015">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119016" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119015">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="#119013">b</a></span> <span class="typed"><span class="type">(Int)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">Int</span><a href="#119014">i</a></span>
      <span class="typed"><span class="type">Int</span><a href="#119014">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119015">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119015">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[Int]</span><a href="#119013">b</a></span>.<span class="typed"><span class="type">=&gt; List[Int]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }
 
  <span class="comment">/** Returns the elements in the list as an iterator
   *
   *  @return an iterator on the list elements.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Iterator[A]</span><a id="20889">elements</a></span>: <span class="typed"><span class="type">Iterator[A]</span><a href="Iterator.scala.html#1337">Iterator</a></span>[A] = <span class="typed"><span class="type">template $anon extends java.lang.Object with Iterator[A]</span><a id="119040" class="keyword">new</a></span> <span class="typed"><span class="type">Iterator[A]</span><a href="Iterator.scala.html#1337">Iterator</a></span>[A] {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><span id="119044"><span id="119042"><span id="119043"><a id="119050">these</a></span></span></span></span> = <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>.<span class="keyword">this</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="119045">hasNext</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">=&gt; List[A]</span><a href="#119042">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">()A</span><a id="119046">next</a></span>: <span class="typed"><span class="type">A</span><a href="#16627">A</a></span> =
      <span class="typed"><span class="type">A</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">=&gt; Boolean</span><a href="#119045">hasNext</a></span>)
        <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.util.NoSuchElementException</span><a id="25317" class="keyword">new</a></span> <span class="typed"><span class="type">java.util.NoSuchElementException</span><a href="Predef.scala.html#13342">NoSuchElementException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;next on empty Iterator&quot;)</span><span class="string">&quot;next on empty Iterator&quot;</span></span>)
      <span class="keyword">else</span> {
        <span class="keyword">val</span> <span class="typed"><span class="type">A</span><a id="119055">result</a></span> = <span class="typed"><span class="type">=&gt; List[A]</span><a href="#119042">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>; <span class="typed"><span class="type">(List[A])Unit</span><a href="#119043">these</a></span> = <span class="typed"><span class="type">=&gt; List[A]</span><a href="#119042">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>; <span class="typed"><span class="type">A</span><a href="#119055">result</a></span>
      }
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="119047">toList</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">=&gt; List[A]</span><a href="#119042">these</a></span>
  }

  <span class="comment">/** Overrides the method in Iterable for efficiency.
   *
   *  @return  the list itself
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="20890">toList</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>

  <span class="comment">/** Returns the list without its last element.
   *
   *  @return the list without its last element.
   *  @throws Predef.UnsupportedOperationException if the list is empty.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="20891">init</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] =
    <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.lang.UnsupportedOperationException</span><a id="30111" class="keyword">new</a></span> <span class="typed"><span class="type">java.lang.UnsupportedOperationException</span><a href="Predef.scala.html#13340">UnsupportedOperationException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Nil.init&quot;)</span><span class="string">&quot;Nil.init&quot;</span></span>)
    <span class="keyword">else</span> {
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119060">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
      <span class="keyword">var</span> <span class="typed"><span class="type">A</span><a id="119061">elem</a></span> = <span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119062">next</a></span> = <span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#119063" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119062">next</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119060">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">A</span><a href="#119061">elem</a></span>
        <span class="typed"><span class="type">A</span><a href="#119061">elem</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119062">next</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
        <span class="typed"><span class="type">List[A]</span><a href="#119062">next</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119062">next</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      }
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119060">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
    }

  <span class="comment">/** Returns the last element of this list.
   *
   *  @return the last element of the list.
   *  @throws Predef.NoSuchElementException if the list is empty.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; A</span><a id="20892">last</a></span>: <span class="typed"><span class="type">A</span><a href="#16627">A</a></span> =
    <span class="typed"><span class="type">A</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.util.NoSuchElementException</span><a id="25317" class="keyword">new</a></span> <span class="typed"><span class="type">object Predef</span><a href="Predef.scala.html#819">Predef</a></span>.<span class="typed"><span class="type">java.util.NoSuchElementException</span><a href="Predef.scala.html#13342">NoSuchElementException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Nil.last&quot;)</span><span class="string">&quot;Nil.last&quot;</span></span>)
    <span class="keyword">else</span> {
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119066">cur</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119067">next</a></span> = <span class="typed"><span class="type">List.this.type</span><a href="#524" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#119068" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119067">next</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">List[A]</span><a href="#119066">cur</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119067">next</a></span>
        <span class="typed"><span class="type">List[A]</span><a href="#119067">next</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119067">next</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      }
      <span class="typed"><span class="type">List[A]</span><a href="#119066">cur</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
    }

  <span class="comment">/** Returns the &lt;code&gt;n&lt;/code&gt; first elements of this list, or else the whole 
   *  list, if it has less than &lt;code&gt;n&lt;/code&gt; elements.
   *
   *  @param n the number of elements to take.
   *  @return the &lt;code&gt;n&lt;/code&gt; first elements of this list.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(Int)List[A]</span><a id="20893">take</a></span>(<span class="typed"><span class="type">Int</span><a id="119070">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119071">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="119072">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119073">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119074" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119073">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">Int</span><a href="#119072">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#119070">n</a></span>) {
      <span class="typed"><span class="type">Int</span><a href="#119072">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119071">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119073">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119073">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119073">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[A]</span><a href="#119073">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">else</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119071">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Returns the list with elements belonging to the given index range.
   *
   *  @param start the start position of the list slice.
   *  @param end   the end position (exclusive) of the list slice.
   *  @return the list with elements belonging to the given index range.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(Int,Int)List[A]</span><a id="20894">slice</a></span>(<span class="typed"><span class="type">Int</span><a id="119100">start</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="119101">end</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">Int</span><a id="119102">s</a></span> = <span class="typed"><span class="type">implicit scala.Predef.intWrapper : (Int)scala.runtime.RichInt</span><a href="Predef.scala.html#13511">start</a></span> <span class="typed"><span class="type">(Int)Int</span><a href="runtime/RichInt.scala.html#19406">max</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">Int</span><a id="119103">e</a></span> = <span class="typed"><span class="type">implicit scala.Predef.intWrapper : (Int)scala.runtime.RichInt</span><a href="Predef.scala.html#13511">end</a></span> <span class="typed"><span class="type">(Int)Int</span><a href="runtime/RichInt.scala.html#19405">min</a></span> <span class="typed"><span class="type">List.this.type</span><a href="#524" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="#20887">length</a></span>
    <span class="typed"><span class="type">(Int)List[A]</span><a href="#20895">drop</a></span>(<span class="typed"><span class="type">Int</span><a href="#119102">s</a></span>) <span class="typed"><span class="type">(Int)List[A]</span><a href="#20893">take</a></span> (<span class="typed"><span class="type">Int</span><a href="#119103">e</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int</span><a href="#119102">s</a></span>)
  }

  <span class="comment">/** Returns the list without its &lt;code&gt;n&lt;/code&gt; first elements.
   *  If this list has less than &lt;code&gt;n&lt;/code&gt; elements, the empty list is returned.
   *
   *  @param n the number of elements to drop.
   *  @return the list without its &lt;code&gt;n&lt;/code&gt; first elements.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(Int)List[A]</span><a id="20895">drop</a></span>(<span class="typed"><span class="type">Int</span><a id="119112">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119128">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="119129">count</a></span> = <span class="typed"><span class="type">Int</span><a href="#119112">n</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119130" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119128">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">Int</span><a href="#119129">count</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) {
      <span class="typed"><span class="type">List[A]</span><a href="#119128">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119128">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">Int</span><a href="#119129">count</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    }
    <span class="typed"><span class="type">List[A]</span><a href="#119128">these</a></span>
  }

  <span class="comment">/** Returns the rightmost &lt;code&gt;n&lt;/code&gt; elements from this list.
   *
   *  @param n the number of elements to take
   *  @return the suffix of length &lt;code&gt;n&lt;/code&gt; of the list
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int)List[A]</span><a id="20896">takeRight</a></span>(<span class="typed"><span class="type">Int</span><a id="119151">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    @<span class="typed"><span class="type">scala.annotation.tailrec</span><a href="annotation/tailrec.scala.html#12234">tailrec</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a id="119152">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119153">lead</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[A]</span><a id="119154">lag</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">List[A]</span><a href="#119153">lead</a></span> <span class="typed"><span class="type">List[A]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">List[A]</span><a href="#119154">lag</a></span>
      <span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> _ <a id="1">::</a> <span class="typed"><span class="type">List[A]</span><a id="119155">tail</a></span> =&gt; <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a href="#119152">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119155">tail</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119154">lag</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>)
    }
    <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a href="#119152">loop</a></span>(<span class="typed"><span class="type">(Int)List[A]</span><a href="#20895">drop</a></span>(<span class="typed"><span class="type">Int</span><a href="#119151">n</a></span>), <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>)
  }

  <span class="comment">/** Returns the list wihout its rightmost &lt;code&gt;n&lt;/code&gt; elements.
   *
   *  @param n the number of elements to take
   *  @return the list without its rightmost &lt;code&gt;n&lt;/code&gt; elements
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int)List[A]</span><a id="20897">dropRight</a></span>(<span class="typed"><span class="type">Int</span><a id="119156">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a id="119157">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119158">lead</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[A]</span><a id="119159">lag</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">List[A]</span><a href="#119158">lead</a></span> <span class="typed"><span class="type">List[A]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Nil.type</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>
      <span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> _ <a id="1">::</a> <span class="typed"><span class="type">List[A]</span><a id="119160">tail</a></span> =&gt; <span class="typed"><span class="type">List[A]</span><a href="#119159">lag</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a href="#119157">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119160">tail</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119159">lag</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>)
    }
    <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a href="#119157">loop</a></span>(<span class="typed"><span class="type">(Int)List[A]</span><a href="#20895">drop</a></span>(<span class="typed"><span class="type">Int</span><a href="#119156">n</a></span>), <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>)
  }

  <span class="comment">/** Split the list at a given point and return the two parts thus
   *  created.
   *
   *  @param n the position at which to split
   *  @return  a pair of lists composed of the first &lt;code&gt;n&lt;/code&gt;
   *           elements, and the other elements.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int)(List[A], List[A])</span><a id="20898">splitAt</a></span>(<span class="typed"><span class="type">Int</span><a id="119163">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">(List[A], List[A])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[A]) = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119164">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="119165">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119166">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119167" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119166">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">Int</span><a href="#119165">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">Int</span><a href="#119163">n</a></span>) {
      <span class="typed"><span class="type">Int</span><a href="#119165">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119164">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119166">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119166">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119166">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">(List[A],List[A])(List[A], List[A])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119164">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119166">these</a></span>)
  }

  <span class="comment">/** Returns the longest prefix of this list whose elements satisfy
   *  the predicate &lt;code&gt;p&lt;/code&gt;.
   *
   *  @param p the test predicate.
   *  @return  the longest prefix of this list whose elements satisfy
   *           the predicate &lt;code&gt;p&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)List[A]</span><a id="20899">takeWhile</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="119194">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119195">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119196">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119197" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119196">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119196">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119195">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119196">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119196">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119196">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119195">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Returns the longest suffix of this list whose first element
   *  does not satisfy the predicate &lt;code&gt;p&lt;/code&gt;.
   *
   *  @param p the test predicate.
   *  @return  the longest suffix of the list whose first element
   *           does not satisfy the predicate &lt;code&gt;p&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)List[A]</span><a id="20900">dropWhile</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="119199">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    @<span class="typed"><span class="type">scala.annotation.tailrec</span><a href="annotation/tailrec.scala.html#12234">tailrec</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A])List[A]</span><a id="119200">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119201">xs</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] =
      <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[A]</span><a href="#119201">xs</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119201">xs</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">List[A]</span><a href="#119201">xs</a></span>
      <span class="keyword">else</span> <span class="typed"><span class="type">(List[A])List[A]</span><a href="#119200">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119201">xs</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>)
    
    <span class="typed"><span class="type">(List[A])List[A]</span><a href="#119200">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>)
  }

  <span class="comment">/** Returns the longest prefix of the list whose elements all satisfy
   *  the given predicate, and the rest of the list.
   *
   *  @param p the test predicate
   *  @return  a pair consisting of the longest prefix of the list whose
   *           elements all satisfy &lt;code&gt;p&lt;/code&gt;, and the rest of the list.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)(List[A], List[A])</span><a id="20901">span</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="119202">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">(List[A], List[A])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[A]) = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119203">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119204">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119205" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119204">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119204">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119203">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119204">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119204">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119204">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">(List[A],List[A])(List[A], List[A])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119203">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119204">these</a></span>)
  }

  <span class="comment">/** Like &lt;code&gt;span&lt;/code&gt; but with the predicate inverted.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)(List[A], List[A])</span><a id="20902">break</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="119209">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">(List[A], List[A])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[A]) = <span class="typed"><span class="type">((A) =&gt; Boolean)(List[A], List[A])</span><a href="#20901">span</a></span> { <span class="typed"><span class="type">A</span><a id="119211">x</a></span> =&gt; <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">A</span><a href="#119211">x</a></span>) }

  <span class="comment">/** Returns the &lt;code&gt;n&lt;/code&gt;-th element of this list. The first element
   *  (head of the list) is at position 0.
   *
   *  @param n index of the element to return
   *  @return  the element at position &lt;code&gt;n&lt;/code&gt; in this list.
   *  @throws Predef.NoSuchElementException if the list is too short.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int)A</span><a id="20903">apply</a></span>(<span class="typed"><span class="type">Int</span><a id="56343">n</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">A</span><a href="#16627">A</a></span> = <span class="typed"><span class="type">(Int)List[A]</span><a href="#20895">drop</a></span>(<span class="typed"><span class="type">Int</span><a href="#56343">n</a></span>).<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>

  <span class="comment">/** Returns the list resulting from applying the given function &lt;code&gt;f&lt;/code&gt; to each
   *  element of this list.
   *
   *  @param f function to apply to each element.
   *  @return &lt;code&gt;[f(a0), ..., f(an)]&lt;/code&gt; if this list is &lt;code&gt;[a0, ..., an]&lt;/code&gt;.
   */</span>
  <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B]((A) =&gt; B)List[B]</span><a id="20904">map</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20906">B</a></span>](<span class="typed"><span class="type">(A) =&gt; B</span><a id="21326">f</a></span>: A =&gt; B): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119212">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119213">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119214" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119213">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119212">b</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">(A)B</span><a href="Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119213">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[A]</span><a href="#119213">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119213">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119212">b</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Apply a function to all the elements of the list, and return the
   *  reversed list of results. This is equivalent to a call to &lt;code&gt;map&lt;/code&gt;
   *  followed by a call to &lt;code&gt;reverse&lt;/code&gt;, but more efficient.
   *
   *  @param f the function to apply to each elements.
   *  @return  the reversed list of results.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B]((A) =&gt; B)List[B]</span><a id="20907">reverseMap</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20909">B</a></span>](<span class="typed"><span class="type">(A) =&gt; B</span><a id="119216">f</a></span>: A =&gt; B): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    @<span class="typed"><span class="type">scala.annotation.tailrec</span><a href="annotation/tailrec.scala.html#12234">tailrec</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A],List[B])List[B]</span><a id="119217">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119218">l</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[B]</span><a id="119219">res</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = <span class="typed"><span class="type">List[A]</span><a href="#119218">l</a></span> <span class="typed"><span class="type">List[B]</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">List[B]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">List[B]</span><a href="#119219">res</a></span>
      <span class="typed"><span class="type">List[B]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119220">head</a></span> <a id="1">::</a> <span class="typed"><span class="type">List[A]</span><a id="119221">tail</a></span> =&gt; <span class="typed"><span class="type">(List[A],List[B])List[B]</span><a href="#119217">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119221">tail</a></span>, <span class="typed"><span class="type">(A)B</span><a href="Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">A</span><a href="#119220">head</a></span>) <span class="typed"><span class="type">(B)List[B]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[B]</span><a href="#119219">res</a></span>)
    }
    <span class="typed"><span class="type">(List[A],List[B])List[B]</span><a href="#119217">loop</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>, <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>)
  }

  <span class="comment">/** Apply the given function &lt;code&gt;f&lt;/code&gt; to each element of this list
   *  (while respecting the order of the elements).
   *
   *  @param f the treatment to apply to each element.
   */</span>
  <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a id="20910">foreach</a></span>(<span class="typed"><span class="type">(A) =&gt; Unit</span><a id="38303">f</a></span>: A =&gt; Unit) {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119225">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119226" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119225">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">(A)Unit</span><a href="Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119225">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[A]</span><a href="#119225">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119225">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
  }

  <span class="comment">/** Returns all the elements of this list that satisfy the
   *  predicate &lt;code&gt;p&lt;/code&gt;. The order of the elements is preserved.
   *  It is guarenteed that the receiver list itself is returned iff all its
   *  elements satisfy the predicate `p'. Hence the following equality is valid:
   *
   *  (xs filter p) eq xs  ==  xs forall p
   *
   *  @param p the predicate used to filter the list.
   *  @return the elements of this list satisfying &lt;code&gt;p&lt;/code&gt;.
   */</span>
  <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)List[A]</span><a id="20911">filter</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="59321">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="comment">// return same list if all elements satisfy p</span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119228">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119229" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) {
      <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">else</span> {
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119232">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119233">these1</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#119234" class="keyword">while</a></span> (<span class="typed"><span class="type">List[A]</span><a href="#119233">these1</a></span> <span class="typed"><span class="type">(AnyRef)Boolean</span><a id="5793">ne</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>) {
        <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119232">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119233">these1</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
        <span class="typed"><span class="type">List[A]</span><a href="#119233">these1</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119233">these1</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      }

      <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span> <span class="comment">// prevent the second evaluation of the predicate</span>
                         <span class="comment">// on the element on which it first failed</span>
      <span class="typed"><span class="type">Unit</span><a href="#119235" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119232">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
        <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119228">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      }
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119232">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
    }
  }

<span class="comment">//  final def filterMap[B](f: PartialFunction[A, B]): List[B] = </span>
<span class="comment">//    this filter f.isDefinedAt map f</span>

  <span class="comment">/** Removes all elements of the list which satisfy the predicate
   *  &lt;code&gt;p&lt;/code&gt;. This is like &lt;code&gt;filter&lt;/code&gt; with the
   *  predicate inversed.
   *
   *  @param p the predicate to use to test elements
   *  @return  the list without all elements which satisfy &lt;code&gt;p&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)List[A]</span><a id="20912">remove</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38268">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">((A) =&gt; Boolean)List[A]</span><a href="#20911">filter</a></span> (<span class="typed"><span class="type">A</span><a id="119238">x</a></span> =&gt; <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">A</span><a href="#119238">x</a></span>))

  <span class="comment">/** Partition the list in two sub-lists according to a predicate.
   *
   *  @param p the predicate on which to partition
   *  @return  a pair of lists: the list of all elements which satisfy
   *           &lt;code&gt;p&lt;/code&gt; and the list of all elements which do not.
   *           The relative order of the elements in the sub-lists is the
   *           same as in the original list.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)(List[A], List[A])</span><a id="20913">partition</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="119239">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">(List[A], List[A])</span><a href="Tuple2.scala.html#1376">(</a></span>List[A], List[A]) = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119240">btrue</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119241">bfalse</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119242">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119243" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119242">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      (<span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119242">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119240">btrue</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119241">bfalse</a></span>) <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119242">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119242">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119242">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">(List[A],List[A])(List[A], List[A])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119240">btrue</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>, <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119241">bfalse</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>)
  }

  <span class="comment">/** &lt;p&gt;
   *    Sort the list according to the comparison function
   *    &lt;code&gt;&amp;lt;(e1: a, e2: a) =&amp;gt; Boolean&lt;/code&gt;,
   *    which should be true iff &lt;code&gt;e1&lt;/code&gt; is smaller than
   *    &lt;code&gt;e2&lt;/code&gt;. 
   *  &lt;/p&gt;
   *
   *  @param lt the comparison function
   *  @return   a list sorted according to the comparison function
   *            &lt;code&gt;&amp;lt;(e1: a, e2: a) =&amp;gt; Boolean&lt;/code&gt;.
   *  @ex &lt;pre&gt;
   *    List(&quot;Steve&quot;, &quot;Tom&quot;, &quot;John&quot;, &quot;Bob&quot;)
   *      .sort((e1, e2) =&gt; (e1 compareTo e2) &amp;lt; 0) =
   *    List(&quot;Bob&quot;, &quot;John&quot;, &quot;Steve&quot;, &quot;Tom&quot;)&lt;/pre&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A, A) =&gt; Boolean)List[A]</span><a id="20914">sort</a></span>(<span class="typed"><span class="type">(A, A) =&gt; Boolean</span><a id="119248">lt</a></span> : (A,A) =&gt; Boolean): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="comment">/** Merge two already-sorted lists */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a id="119249">merge</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119252">l1</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A], <span class="typed"><span class="type">List[A]</span><a id="119253">l2</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119254">res</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119255">left1</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119252">l1</a></span>
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119256">left2</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119253">l2</a></span>

      <span class="typed"><span class="type">Unit</span><a href="#119257" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119255">left1</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119256">left2</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
	<span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span>(<span class="typed"><span class="type">(A,A)Boolean</span><a href="Function2.scala.html#20399">lt</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119255">left1</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119256">left2</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) {
	  <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119254">res</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119255">left1</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
	  <span class="typed"><span class="type">List[A]</span><a href="#119255">left1</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119255">left1</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
	} <span class="keyword">else</span> {
	  <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119254">res</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119256">left2</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
	  <span class="typed"><span class="type">List[A]</span><a href="#119256">left2</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119256">left2</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
	}
      }

      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119254">res</a></span> <span class="typed"><span class="type">(Iterable[A])Unit</span><a href="collection/mutable/Buffer.scala.html#19231">++=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119255">left1</a></span>
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119254">res</a></span> <span class="typed"><span class="type">(Iterable[A])Unit</span><a href="collection/mutable/Buffer.scala.html#19231">++=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119256">left2</a></span>

      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119254">res</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
    }

    <span class="comment">/** Split a list into two lists of about the same size */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A])(List[A], List[A])</span><a id="119250">split</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119264">lst</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]) = {
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119265">res1</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
      <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119266">res2</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119267">left</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119264">lst</a></span>

      <span class="typed"><span class="type">Unit</span><a href="#119268" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
	<span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119265">res1</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
	<span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
	<span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
	  <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119266">res2</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
	  <span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119267">left</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
	}
      }

      <span class="typed"><span class="type">(List[A],List[A])(List[A], List[A])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119265">res1</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>, <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119266">res2</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>)
    }


    <span class="comment">/** Merge-sort the specified list */</span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(List[A])List[A]</span><a id="119251">ms</a></span>(<span class="typed"><span class="type">List[A]</span><a id="119273">lst</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A]): <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] =
      <span class="typed"><span class="type">List[A]</span><a href="#119273">lst</a></span> <span class="typed"><span class="type">List[A]</span><span class="keyword">match</span></span> {
	<span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">List[A]</span><a href="#119273">lst</a></span>
	<span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119274">x</a></span> <a id="1">::</a> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">List[A]</span><a href="#119273">lst</a></span>
	<span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119275">x</a></span> <a id="1">::</a> <span class="typed"><span class="type">A</span><a id="119276">y</a></span> <a id="1">::</a> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt;
	  <span class="typed"><span class="type">List[A]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A,A)Boolean</span><a href="Function2.scala.html#20399">lt</a></span>(<span class="typed"><span class="type">A</span><a href="#119275">x</a></span>,<span class="typed"><span class="type">A</span><a href="#119276">y</a></span>))
	    <span class="typed"><span class="type">List[A]</span><a href="#119273">lst</a></span>
	  <span class="keyword">else</span>
	    <span class="typed"><span class="type">A</span><a href="#119276">y</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">A</span><a href="#119275">x</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>

	<span class="typed"><span class="type">List[A]</span><span class="keyword">case</span></span> <span class="typed"><span class="type">List[A]</span><a id="119282">lst</a></span> =&gt;
          <span class="keyword">val</span> <span class="typed"><span class="type">(List[A], List[A])</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">List[A]</span><span id="119288"><a href="Tuple2.scala.html#19161" id="119284">l1</a></span></span>, <span class="typed"><span class="type">List[A]</span><span id="119289"><a href="Tuple2.scala.html#19163" id="119285">l2</a></span></span>) = <span class="typed"><span class="type">(List[A])(List[A], List[A])</span><a href="#119250">split</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119282">lst</a></span>)
          <span class="keyword">val</span> <span class="typed"><span class="type">List[A]</span><a id="119286">l1s</a></span> = <span class="typed"><span class="type">(List[A])List[A]</span><a href="#119251">ms</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119284">l1</a></span>)
          <span class="keyword">val</span> <span class="typed"><span class="type">List[A]</span><a id="119287">l2s</a></span> = <span class="typed"><span class="type">(List[A])List[A]</span><a href="#119251">ms</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119285">l2</a></span>)
          <span class="typed"><span class="type">(List[A],List[A])List[A]</span><a href="#119249">merge</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119286">l1s</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119287">l2s</a></span>)
      }

    <span class="typed"><span class="type">(List[A])List[A]</span><a href="#119251">ms</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>)
  }


  <span class="comment">/** Count the number of elements in the list which satisfy a predicate.
   *
   *  @param p the predicate for which to count
   *  @return  the number of elements satisfying the predicate &lt;code&gt;p&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a id="20915">count</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="119292">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="119293">cnt</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119294">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119295" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119294">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119294">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">Int</span><a href="#119293">cnt</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119294">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119294">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Int</span><a href="#119293">cnt</a></span>
  }

  <span class="comment">/** Tests if the predicate &lt;code&gt;p&lt;/code&gt; is satisfied by all elements
   *  in this list.
   *
   *  @param p the test predicate.
   *  @return  &lt;code&gt;true&lt;/code&gt; iff all elements of this list satisfy the
   *           predicate &lt;code&gt;p&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Boolean</span><a id="20916">forall</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="54422">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119319">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119320" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119319">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119319">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span> <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119319">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119319">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
  }

  <span class="comment">/** Tests the existence in this list of an element that satisfies the
   *  predicate &lt;code&gt;p&lt;/code&gt;.
   *
   *  @param p the test predicate.
   *  @return  &lt;code&gt;true&lt;/code&gt; iff there exists an element in this list that
   *           satisfies the predicate &lt;code&gt;p&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Boolean</span><a id="20917">exists</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="86715">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119322">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119323" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119322">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119322">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span> <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119322">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119322">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
  }

  <span class="comment">/** Find and return the first element of the list satisfying a
   *  predicate, if any.
   *
   *  @param p the predicate
   *  @return the first element in the list satisfying &lt;code&gt;p&lt;/code&gt;,
   *  or &lt;code&gt;None&lt;/code&gt; if none exists.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Option[A]</span><a id="20918">find</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="54442">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Option[A]</span><a href="Option.scala.html#932">Option</a></span>[A] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119325">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119326" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119325">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A)Boolean</span><a href="Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119325">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span> <span class="typed"><span class="type">(A)Some[A]</span><a href="Option.scala.html#19455">Some</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119325">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[A]</span><a href="#119325">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119325">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">object None</span><a href="Option.scala.html#534">None</a></span>
  }

  <span class="comment">/** Combines the elements of this list together using the binary
   *  function &lt;code&gt;f&lt;/code&gt;, from left to right, and starting with
   *  the value &lt;code&gt;z&lt;/code&gt;.
   *
   *  @return &lt;code&gt;f(... (f(f(z, a&lt;sub&gt;0&lt;/sub&gt;), a&lt;sub&gt;1&lt;/sub&gt;) ...),
   *          a&lt;sub&gt;n&lt;/sub&gt;)&lt;/code&gt; if the list is
   *          &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;]&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B](B)((B, A) =&gt; B)B</span><a id="20919">foldLeft</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20921">B</a></span>](<span class="typed"><span class="type">B</span><a id="34251">z</a></span>: <span class="typed"><span class="type">B</span><a href="#20921">B</a></span>)(<span class="typed"><span class="type">(B, A) =&gt; B</span><a id="34252">f</a></span>: (B, A) =&gt; B): <span class="typed"><span class="type">B</span><a href="#20921">B</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">B</span><a id="119329">acc</a></span> = <span class="typed"><span class="type">B</span><a href="#34251">z</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119330">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119331" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119330">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">B</span><a href="#119329">acc</a></span> = <span class="typed"><span class="type">(B,A)B</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">B</span><a href="#119329">acc</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119330">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)
      <span class="typed"><span class="type">List[A]</span><a href="#119330">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119330">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">B</span><a href="#119329">acc</a></span>
  }

  <span class="comment">/** Combines the elements of this list together using the binary
   *  function &lt;code&gt;f&lt;/code&gt;, from right to left, and starting with
   *  the value &lt;code&gt;z&lt;/code&gt;.
   *
   *  @return &lt;code&gt;f(a&lt;sub&gt;0&lt;/sub&gt;, f(a&lt;sub&gt;1&lt;/sub&gt;, f(..., f(a&lt;sub&gt;n&lt;/sub&gt;, z)...)))&lt;/code&gt;
   *          if the list is &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, a1, ..., a&lt;sub&gt;n&lt;/sub&gt;]&lt;/code&gt;.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B](B)((A, B) =&gt; B)B</span><a id="20922">foldRight</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20924">B</a></span>](<span class="typed"><span class="type">B</span><a id="34280">z</a></span>: <span class="typed"><span class="type">B</span><a href="#20924">B</a></span>)(<span class="typed"><span class="type">(A, B) =&gt; B</span><a id="34281">f</a></span>: (A, B) =&gt; B): <span class="typed"><span class="type">B</span><a href="#20924">B</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span> <span class="typed"><span class="type">B</span><span class="keyword">match</span></span> {
    <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">B</span><a href="#34280">z</a></span>
    <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119333">x</a></span> <a id="1">::</a> <span class="typed"><span class="type">List[A]</span><a id="119334">xs</a></span> =&gt; <span class="typed"><span class="type">(A,B)B</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">A</span><a href="#119333">x</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119334">xs</a></span>.<span class="typed"><span class="type">(B)((A, B) =&gt; B)B</span><a href="#20922">foldRight</a></span>(<span class="typed"><span class="type">B</span><a href="#34280">z</a></span>)(<span class="typed"><span class="type">(A, B) =&gt; B</span><a href="#34281">f</a></span>))
  }

  <span class="comment">/** Combines the elements of this list together using the binary
   *  operator &lt;code&gt;op&lt;/code&gt;, from left to right
   *  @param op  The operator to apply
   *  @return &lt;code&gt;op(... op(a&lt;sub&gt;0&lt;/sub&gt;,a&lt;sub&gt;1&lt;/sub&gt;), ..., a&lt;sub&gt;n&lt;/sub&gt;)&lt;/code&gt; 
      if the list has elements
   *          &lt;code&gt;a&lt;sub&gt;0&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt;.
   *  @throws Predef.UnsupportedOperationException if the list is empty.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A]((B, A) =&gt; B)B</span><a id="20925">reduceLeft</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20927">B</a></span> &gt;: A](<span class="typed"><span class="type">(B, A) =&gt; B</span><a id="119336">f</a></span>: (B, A) =&gt; B): <span class="typed"><span class="type">B</span><a href="#20927">B</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span> <span class="typed"><span class="type">B</span><span class="keyword">match</span></span> {
    <span class="typed"><span class="type">Nothing</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.lang.UnsupportedOperationException</span><a id="30111" class="keyword">new</a></span> <span class="typed"><span class="type">java.lang.UnsupportedOperationException</span><a href="Predef.scala.html#13340">UnsupportedOperationException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Nil.reduceLeft&quot;)</span><span class="string">&quot;Nil.reduceLeft&quot;</span></span>)
    <span class="typed"><span class="type">A</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119339">x</a></span> <a id="1">::</a> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">A</span><a href="#119339">x</a></span>
    <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119340">x0</a></span> <a id="1">::</a> <span class="typed"><span class="type">A</span><a id="119341">x1</a></span> <a id="1">::</a> <span class="typed"><span class="type">List[A]</span><a id="119342">xs</a></span> =&gt; 
      <span class="keyword">var</span> <span class="typed"><span class="type">B</span><a id="119343">acc</a></span> : <span class="typed"><span class="type">B</span><a href="#20927">B</a></span> = <span class="typed"><span class="type">(B,A)B</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">A</span><a href="#119340">x0</a></span>, <span class="typed"><span class="type">A</span><a href="#119341">x1</a></span>)
      <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119344">these</a></span> : <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">List[A]</span><a href="#119342">xs</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#119345" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119344">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">B</span><a href="#119343">acc</a></span> = <span class="typed"><span class="type">(B,A)B</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">B</span><a href="#119343">acc</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119344">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)
        <span class="typed"><span class="type">List[A]</span><a href="#119344">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119344">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      }
      <span class="typed"><span class="type">B</span><a href="#119343">acc</a></span>
  }

  <span class="comment">/** Combines the elements of this list together using the binary
   *  operator &lt;code&gt;op&lt;/code&gt;, from right to left
   *  @param op  The operator to apply
   *
   *  @return &lt;code&gt;a&lt;sub&gt;0&lt;/sub&gt; op (... op (a&lt;sub&gt;n-1&lt;/sub&gt; op a&lt;sub&gt;n&lt;/sub&gt;)...)&lt;/code&gt;
   *          if the list has elements &lt;code&gt;a&lt;sub&gt;0&lt;/sub&gt;, a&lt;sub&gt;1&lt;/sub&gt;, ...,
   *          a&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt;.
   *
   *  @throws Predef.UnsupportedOperationException if the list is empty.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A]((A, B) =&gt; B)B</span><a id="20928">reduceRight</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20930">B</a></span> &gt;: A](<span class="typed"><span class="type">(A, B) =&gt; B</span><a id="66894">f</a></span>: (A, B) =&gt; B): <span class="typed"><span class="type">B</span><a href="#20930">B</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span> <span class="typed"><span class="type">B</span><span class="keyword">match</span></span> {
    <span class="typed"><span class="type">Nothing</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.lang.UnsupportedOperationException</span><a id="30111" class="keyword">new</a></span> <span class="typed"><span class="type">java.lang.UnsupportedOperationException</span><a href="Predef.scala.html#13340">UnsupportedOperationException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;Nil.reduceRight&quot;)</span><span class="string">&quot;Nil.reduceRight&quot;</span></span>)
    <span class="typed"><span class="type">A</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119349">x</a></span> <a id="1">::</a> <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span> =&gt; <span class="typed"><span class="type">A</span><a href="#119349">x</a></span>
    <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <span class="typed"><span class="type">A</span><a id="119350">x</a></span> <a id="1">::</a> <span class="typed"><span class="type">List[A]</span><a id="119351">xs</a></span> =&gt; <span class="typed"><span class="type">(A,B)B</span><a href="Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">A</span><a href="#119350">x</a></span>, <span class="typed"><span class="type">List[A]</span><a href="#119351">xs</a></span> <span class="typed"><span class="type">((A, B) =&gt; B)B</span><a href="#20928">reduceRight</a></span> <span class="typed"><span class="type">(A, B) =&gt; B</span><a href="#66894">f</a></span>)
  }

  <span class="comment">/** Applies the given function &lt;code&gt;f&lt;/code&gt; to each element of
   *  this list, then concatenates the results.
   *
   *  @param f the function to apply on each element.
   *  @return  &lt;code&gt;f(a&lt;sub&gt;0&lt;/sub&gt;) ::: ... ::: f(a&lt;sub&gt;n&lt;/sub&gt;)&lt;/code&gt; if
   *           this list is &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;]&lt;/code&gt;.
   */</span>
  <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B]((A) =&gt; Iterable[B])List[B]</span><a id="20931">flatMap</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20933">B</a></span>](<span class="typed"><span class="type">(A) =&gt; Iterable[B]</span><a id="97370">f</a></span>: A =&gt; Iterable[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119354">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119355">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119356" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119355">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="keyword">var</span> <span class="typed"><span class="type">Iterator[B]</span><a id="119358">those</a></span> = <span class="typed"><span class="type">(A)Iterable[B]</span><a href="Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119355">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>).<span class="typed"><span class="type">=&gt; Iterator[B]</span><a href="Iterable.scala.html#17309">elements</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#119359" class="keyword">while</a></span> (<span class="typed"><span class="type">Iterator[B]</span><a href="#119358">those</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Iterator.scala.html#19975">hasNext</a></span>) {
        <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119354">b</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">Iterator[B]</span><a href="#119358">those</a></span>.<span class="typed"><span class="type">()B</span><a href="Iterator.scala.html#19976">next</a></span>
      }
      <span class="typed"><span class="type">List[A]</span><a href="#119355">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119355">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119354">b</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** A list consisting of all elements of this list in reverse order.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="20934">reverse</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119360">result</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119361">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119362" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119361">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">List[A]</span><a href="#119360">result</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119361">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span> <span class="typed"><span class="type">(A)List[A]</span><a href="#20872">::</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119360">result</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119361">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119361">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">List[A]</span><a href="#119360">result</a></span>
  }

  <span class="comment">/** Returns a list formed from this list and the specified list
   *  &lt;code&gt;that&lt;/code&gt; by associating each element of the former with
   *  the element at the same position in the latter.
   *  If one of the two lists is longer than the other, its remaining elements are ignored.
   *
   *  @return     &lt;code&gt;List((a&lt;sub&gt;0&lt;/sub&gt;,b&lt;sub&gt;0&lt;/sub&gt;), ...,
   *              (a&lt;sub&gt;min(m,n)&lt;/sub&gt;,b&lt;sub&gt;min(m,n)&lt;/sub&gt;))&lt;/code&gt; when
   *              &lt;code&gt;List(a&lt;sub&gt;0&lt;/sub&gt;, ..., a&lt;sub&gt;m&lt;/sub&gt;)
   *              zip List(b&lt;sub&gt;0&lt;/sub&gt;, ..., b&lt;sub&gt;n&lt;/sub&gt;)&lt;/code&gt; is invoked.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B](List[B])List[(A, B)]</span><a id="20935">zip</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20937">B</a></span>](<span class="typed"><span class="type">List[B]</span><a id="119366">that</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[(A, B)]</span><a href="#524">List</a></span>[(A, B)] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, B)]</span><a id="119367">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, B)]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, B)]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[(A, B)]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119368">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="119369">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#119366">that</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119370" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119368">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#119369">those</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, B)]</span><a href="#119367">b</a></span> <span class="typed"><span class="type">((A, B))Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> (<span class="typed"><span class="type">(A,B)(A, B)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">List[A]</span><a href="#119368">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#119369">those</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>))
      <span class="typed"><span class="type">List[A]</span><a href="#119368">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119368">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#119369">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#119369">those</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, B)]</span><a href="#119367">b</a></span>.<span class="typed"><span class="type">=&gt; List[(A, B)]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Returns a list that pairs each element of this list
   *  with its index, counting from 0.
   *
   *  @return      the list &lt;code&gt;List((a&lt;sub&gt;0&lt;/sub&gt;,0), (a&lt;sub&gt;1&lt;/sub&gt;,1), ...)&lt;/code&gt;
   *               where &lt;code&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/code&gt; are the elements of this list.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[(A, Int)]</span><a id="20938">zipWithIndex</a></span>: <span class="typed"><span class="type">List[(A, Int)]</span><a href="#524">List</a></span>[(A, Int)] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, Int)]</span><a id="119375">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, Int)]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, Int)]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[(A, Int)]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119376">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="119377">idx</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>

    <span class="typed"><span class="type">Unit</span><a href="#119378" class="keyword">while</a></span>(<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119376">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, Int)]</span><a href="#119375">b</a></span> <span class="typed"><span class="type">((A, Int))Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> (<span class="typed"><span class="type">(A,Int)(A, Int)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">List[A]</span><a href="#119376">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">Int</span><a href="#119377">idx</a></span>))
      <span class="typed"><span class="type">List[A]</span><a href="#119376">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119376">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">Int</span><a href="#119377">idx</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    }

    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(A, Int)]</span><a href="#119375">b</a></span>.<span class="typed"><span class="type">=&gt; List[(A, Int)]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Returns a list formed from this list and the specified list
   *  &lt;code&gt;that&lt;/code&gt; by associating each element of the former with
   *  the element at the same position in the latter.
   *
   *  @param that     list &lt;code&gt;that&lt;/code&gt; may have a different length
   *                  as the self list.
   *  @param thisElem element &lt;code&gt;thisElem&lt;/code&gt; is used to fill up the
   *                  resulting list if the self list is shorter than
   *                  &lt;code&gt;that&lt;/code&gt;
   *  @param thatElem element &lt;code&gt;thatElem&lt;/code&gt; is used to fill up the
   *                  resulting list if &lt;code&gt;that&lt;/code&gt; is shorter than
   *                  the self list
   *  @return         &lt;code&gt;List((a&lt;sub&gt;0&lt;/sub&gt;,b&lt;sub&gt;0&lt;/sub&gt;), ...,
   *                  (a&lt;sub&gt;n&lt;/sub&gt;,b&lt;sub&gt;n&lt;/sub&gt;), (elem,b&lt;sub&gt;n+1&lt;/sub&gt;),
   *                  ..., {elem,b&lt;sub&gt;m&lt;/sub&gt;})&lt;/code&gt;
   *                  when &lt;code&gt;[a&lt;sub&gt;0&lt;/sub&gt;, ..., a&lt;sub&gt;n&lt;/sub&gt;] zip
   *                  [b&lt;sub&gt;0&lt;/sub&gt;, ..., b&lt;sub&gt;m&lt;/sub&gt;]&lt;/code&gt; is
   *                  invoked where &lt;code&gt;m &amp;gt; n&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B, C &gt;: A, D &gt;: B](List[B],C,D)List[(C, D)]</span><a id="20939">zipAll</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20943">B</a></span>, <span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20944">C</a></span> &gt;: A, <span class="typed"><span class="type">&gt;: B &lt;: Any</span><a id="20945">D</a></span> &gt;: B](<span class="typed"><span class="type">List[B]</span><a id="119404">that</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B], <span class="typed"><span class="type">C</span><a id="119405">thisElem</a></span>: <span class="typed"><span class="type">C</span><a href="#20944">C</a></span>, <span class="typed"><span class="type">D</span><a id="119406">thatElem</a></span>: <span class="typed"><span class="type">D</span><a href="#20945">D</a></span>): <span class="typed"><span class="type">List[(C, D)]</span><a href="#524">List</a></span>[(C, D)] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><a id="119407">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[(C, D)]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119408">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="119409">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#119404">that</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119410" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><a href="#119407">b</a></span> <span class="typed"><span class="type">((C, D))Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> (<span class="typed"><span class="type">(A,B)(A, B)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>))
      <span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
      <span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Unit</span><a href="#119411" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><a href="#119407">b</a></span> <span class="typed"><span class="type">((C, D))Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> (<span class="typed"><span class="type">(A,D)(A, D)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>, <span class="typed"><span class="type">D</span><a href="#119406">thatElem</a></span>))
      <span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119408">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">Unit</span><a href="#119412" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><a href="#119407">b</a></span> <span class="typed"><span class="type">((C, D))Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> (<span class="typed"><span class="type">(C,B)(C, B)</span><a href="Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">C</span><a href="#119405">thisElem</a></span>, <span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>))
      <span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#119409">those</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[(C, D)]</span><a href="#119407">b</a></span>.<span class="typed"><span class="type">=&gt; List[(C, D)]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** &lt;p&gt;
   *    Computes the multiset union of this list and the given list
   *    &lt;code&gt;that&lt;/code&gt;. For example:
   *  &lt;/p&gt;&lt;pre&gt;
   *    &lt;b&gt;val&lt;/b&gt; xs = List(1, 1, 2)
   *    &lt;b&gt;val&lt;/b&gt; ys = List(1, 2, 2, 3)
   *    println(xs union ys)  // prints &quot;List(1, 1, 2, 1, 2, 2, 3)&quot;
   *    println(ys union xs)  // prints &quot;List(1, 2, 2, 3, 1, 1, 2)&quot;
   *  &lt;/pre&gt;
   *
   *  @param that the list of elements to add to the list.
   *  @return     a list containing the elements of this
   *              list and those of the given list &lt;code&gt;that&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](List[B])List[B]</span><a id="20946">union</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20948">B</a></span> &gt;: A](<span class="typed"><span class="type">List[B]</span><a id="119423">that</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = <span class="typed"><span class="type">List.this.type</span><a href="#524" class="keyword">this</a></span> <span class="typed"><span class="type">(Iterable[B])List[B]</span><a href="#20881">++</a></span> <span class="typed"><span class="type">List[B]</span><a href="#119423">that</a></span>

  <span class="comment">/** &lt;p&gt;
   *    Computes the multiset intersection between this list and the
   *    given list &lt;code&gt;that&lt;/code&gt;; the intersection contains &lt;i&gt;m&lt;/i&gt;
   *    copies of an element contained in both lists, where &lt;i&gt;m&lt;/i&gt; is
   *    the smaller of the number of times the element appears in this
   *    list or in &lt;code&gt;that&lt;/code&gt;. For example:
   *  &lt;/p&gt;&lt;pre&gt;
   *    &lt;b&gt;val&lt;/b&gt; xs = List(1, 1, 2)
   *    &lt;b&gt;val&lt;/b&gt; ys = List(3, 2, 2, 1)
   *    println(xs intersect ys)  // prints &quot;List(1, 2)&quot;
   *    println(ys intersect xs)  // prints &quot;List(2, 1)&quot;
   *  &lt;/pre&gt;
   *
   *  @param that the list to intersect.
   *  @return     the list of elements contained both in this list and
   *              in the given list &lt;code&gt;that&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](List[B])List[B]</span><a id="20949">intersect</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20951">B</a></span> &gt;: A](<span class="typed"><span class="type">List[B]</span><a id="119427">that</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a id="119428">occ</a></span> = <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="collection/mutable/LinkedHashMap.scala.html#11485">LinkedHashMap</a></span>[B, Int]
    <span class="typed"><span class="type">List[B]</span><a href="#119427">that</a></span> <span class="typed"><span class="type">((B) =&gt; Unit)Unit</span><a href="#20910">foreach</a></span> (<span class="typed"><span class="type">B</span><a id="119431">e</a></span> =&gt; <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="#119428">occ</a></span> <span class="typed"><span class="type">(B)Boolean</span><a href="collection/Map.scala.html#21392">contains</a></span> <span class="typed"><span class="type">B</span><a href="#119431">e</a></span>) <span class="typed"><span class="type">(B,Int)Unit</span><a href="collection/mutable/LinkedHashMap.scala.html#105601">occ</a></span>(<span class="typed"><span class="type">B</span><a href="#119431">e</a></span>) <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span> <span class="keyword">else</span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="#119428">occ</a></span>(<span class="typed"><span class="type">B</span><a href="#119431">e</a></span>) = <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119429">buf</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><span id="119458"><a href="#20910" id="119461">e</a></span></span> &lt;- <span class="typed"><span class="type">List.this.type</span><a href="#524" class="keyword">this</a></span> <span class="keyword">if</span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="#119428">occ</a></span> <span class="typed"><span class="type">(B)Boolean</span><a href="collection/Map.scala.html#21392">contains</a></span> <span class="typed"><span class="type">A</span><a href="#119458">e</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(B)Int</span><a href="collection/Map.scala.html#21391">occ</a></span>(<span class="typed"><span class="type">A</span><a href="#119461">e</a></span>) <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) { <span class="typed"><span class="type">(B,Int)Unit</span><a href="collection/mutable/LinkedHashMap.scala.html#105601">occ</a></span>(<span class="typed"><span class="type">A</span><a href="#119461">e</a></span>) <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>; <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119429">buf</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">A</span><a href="#119461">e</a></span> }
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119429">buf</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** &lt;p&gt;
   *    Computes the multiset difference between this list and the
   *    given list &lt;code&gt;that&lt;/code&gt;. If an element appears more
   *    than once in both lists, the difference contains &lt;i&gt;m&lt;/i&gt; copies
   *    of that element, where &lt;i&gt;m&lt;/i&gt; is the difference between the
   *    number of times the element appears in this list and the number
   *    of times it appears in &lt;code&gt;that&lt;/code&gt;. For example:
   *  &lt;/p&gt;&lt;pre&gt;
   *    &lt;b&gt;val&lt;/b&gt; xs = List(1, 1, 2)
   *    &lt;b&gt;val&lt;/b&gt; ys = List(1, 2, 2, 3)
   *    println(xs diff ys)  // prints &quot;List(1)&quot;
   *    println(xs -- ys)    // prints &quot;List()&quot;
   *  &lt;/pre&gt;
   *
   *  @param that the list of elements to remove from this list.
   *  @return     the list of elements contained only in this list plus
   *              &lt;i&gt;m&lt;/i&gt; copies of each element present in both lists,
   *              where &lt;i&gt;m&lt;/i&gt; is defined as above.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](List[B])List[B]</span><a id="20952">diff</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20954">B</a></span> &gt;: A](<span class="typed"><span class="type">List[B]</span><a id="119487">that</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a id="119488">occ</a></span> = <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="collection/mutable/LinkedHashMap.scala.html#11485">LinkedHashMap</a></span>[B, Int]
    <span class="typed"><span class="type">List[B]</span><a href="#119487">that</a></span> <span class="typed"><span class="type">((B) =&gt; Unit)Unit</span><a href="#20910">foreach</a></span> (<span class="typed"><span class="type">B</span><a id="119491">e</a></span> =&gt; <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="#119488">occ</a></span> <span class="typed"><span class="type">(B)Boolean</span><a href="collection/Map.scala.html#21392">contains</a></span> <span class="typed"><span class="type">B</span><a href="#119491">e</a></span>) <span class="typed"><span class="type">(B,Int)Unit</span><a href="collection/mutable/LinkedHashMap.scala.html#105601">occ</a></span>(<span class="typed"><span class="type">B</span><a href="#119491">e</a></span>) <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span> <span class="keyword">else</span> <span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="#119488">occ</a></span>(<span class="typed"><span class="type">B</span><a href="#119491">e</a></span>) = <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119489">buf</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="#20910" id="119518">e</a></span> &lt;- <span class="typed"><span class="type">List.this.type</span><a href="#524" class="keyword">this</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">scala.collection.mutable.LinkedHashMap[B,Int]</span><a href="#119488">occ</a></span> <span class="typed"><span class="type">(B)Boolean</span><a href="collection/Map.scala.html#21392">contains</a></span> <span class="typed"><span class="type">A</span><a href="#119518">e</a></span>)
        <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(B)Int</span><a href="collection/Map.scala.html#21391">occ</a></span>(<span class="typed"><span class="type">A</span><a href="#119518">e</a></span>) <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) <span class="typed"><span class="type">(B,Int)Unit</span><a href="collection/mutable/LinkedHashMap.scala.html#105601">occ</a></span>(<span class="typed"><span class="type">A</span><a href="#119518">e</a></span>) <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
        <span class="keyword">else</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119489">buf</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">A</span><a href="#119518">e</a></span>
      <span class="keyword">else</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119489">buf</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">A</span><a href="#119518">e</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119489">buf</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Computes the difference between this list and the given list
   *  &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that the list of elements to remove from this list.
   *  @return     this list without the elements of the given list
   *              &lt;code&gt;that&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](List[B])List[B]</span><a id="20955">--</a></span> [<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20957">B</a></span> &gt;: A](<span class="typed"><span class="type">List[B]</span><a id="119544">that</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119545">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119546">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119547" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119546">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#119544">that</a></span>.<span class="typed"><span class="type">(Any)Boolean</span><a href="Seq.scala.html#17183">contains</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119546">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119545">b</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119546">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119546">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119546">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119545">b</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Computes the difference between this list and the given object
   *  &lt;code&gt;x&lt;/code&gt;.
   *
   *  @param x    the object to remove from this list.
   *  @return     this list without the elements of the given object
   *              &lt;code&gt;x&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B)List[B]</span><a id="20958">-</a></span> [<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="20960">B</a></span> &gt;: A](<span class="typed"><span class="type">B</span><a id="119549">x</a></span>: <span class="typed"><span class="type">B</span><a href="#20960">B</a></span>): <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119550">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119551">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119552" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119551">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">List[A]</span><a href="#119551">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3495">!=</a></span> <span class="typed"><span class="type">B</span><a href="#119549">x</a></span>) <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119550">b</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119551">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119551">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119551">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119550">b</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Concatenate the elements of this list. The elements of this list
   *  should be a &lt;code&gt;Iterables&lt;/code&gt;.
   *
   *  Note: The compiler might not be able to infer the type parameter,
   *        so it is recommended to provide an explicit type argument.
   *
   *  Example: 
   *    &lt;code&gt;List(List(1, 3), List(2)).flatten[Int]&lt;/code&gt;
   *    returns
   *    &lt;code&gt;List(1, 3, 2)&lt;/code&gt;
   *
   *  @param f    An implicit conversion to an &lt;code&gt;Iterable&lt;/code&gt; instance.
   *  @return     The concatenation of all elements of iterables in this list.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B](implicit (A) =&gt; Iterable[B])List[B]</span><a id="20961">flatten</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20963">B</a></span>](<span class="keyword">implicit</span> <span class="typed"><span class="type">(A) =&gt; Iterable[B]</span><a id="119554">f</a></span> : A =&gt; Iterable[B]) : <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a id="119555">buf</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[B]
    <span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="#20910">foreach</a></span>(<span class="typed"><span class="type">(A)Iterable[B]</span><a href="Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">A</span><a href="#119557">_</a></span>).<span class="typed"><span class="type">((B) =&gt; Unit)Unit</span><a href="Iterable.scala.html#17328">foreach</a></span>(<span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119555">buf</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">B</span><a href="#119559">_</a></span>))
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[B]</span><a href="#119555">buf</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }

  <span class="comment">/** Removes redundant elements from the list. Uses the method &lt;code&gt;==&lt;/code&gt;
   *  to decide if two elements are identical.
   *
   *  @return the list without doubles.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="20964">removeDuplicates</a></span>: <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a id="119561">b</a></span> = <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="collection/mutable/ListBuffer.scala.html#11170">ListBuffer</a></span>[A]
    <span class="keyword">var</span> <span class="typed"><span class="type">List[A]</span><a id="119562">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#524" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119563" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119562">these</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[A]</span><a href="#119562">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>.<span class="typed"><span class="type">(Any)Boolean</span><a href="Seq.scala.html#17183">contains</a></span>(<span class="typed"><span class="type">List[A]</span><a href="#119562">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>)) <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119561">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="collection/mutable/ListBuffer.scala.html#32066">+=</a></span> <span class="typed"><span class="type">List[A]</span><a href="#119562">these</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
      <span class="typed"><span class="type">List[A]</span><a href="#119562">these</a></span> = <span class="typed"><span class="type">List[A]</span><a href="#119562">these</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>
    }
    <span class="typed"><span class="type">scala.collection.mutable.ListBuffer[A]</span><a href="#119561">b</a></span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="collection/mutable/ListBuffer.scala.html#32069">toList</a></span>
  }
   
  <span class="keyword">override</span> <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; java.lang.String</span><a id="20965">stringPrefix</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;List&quot;)</span><span class="string">&quot;List&quot;</span></span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Stream[A]</span><a id="20966">projection</a></span> = <span class="typed"><span class="type">=&gt; Stream[A]</span><a href="#20967">toStream</a></span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Stream[A]</span><a id="20967">toStream</a></span> : <span class="typed"><span class="type">Stream[A]</span><a href="Stream.scala.html#260">Stream</a></span>[A] = <span class="typed"><span class="type">template $anon extends Stream[A] with Stream.Definite[A]</span><a id="119570" class="keyword">new</a></span> Stream.<span class="typed"><span class="type">Stream.Definite[A]</span><a href="Stream.scala.html#30139">Definite</a></span>[A] {
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[A]</span><a id="119572">force</a></span> : <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>[A] = <span class="typed"><span class="type">List[A]</span><a href="#524">List</a></span>.<span class="keyword">this</span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="119573">isEmpty</a></span> = <span class="typed"><span class="type">List.this.type</span><a href="#524">List</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; A</span><a id="119574">head</a></span> = <span class="typed"><span class="type">List.this.type</span><a href="#524">List</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">=&gt; A</span><a href="#20869">head</a></span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Stream[A]</span><a id="119575">tail</a></span> = <span class="typed"><span class="type">List.this.type</span><a href="#524">List</a></span>.<span class="keyword">this</span>.<span class="typed"><span class="type">=&gt; List[A]</span><a href="#20871">tail</a></span>.<span class="typed"><span class="type">=&gt; Stream[A]</span><a href="#20967">toStream</a></span>
    <span class="keyword">protected</span> <span class="keyword">def</span> <span class="typed"><span class="type">(StringBuilder,String)StringBuilder</span><a id="119576">addDefinedElems</a></span>(<span class="typed"><span class="type">StringBuilder</span><a id="119587">buf</a></span>: <span class="typed"><span class="type">StringBuilder</span><a href="StringBuilder.scala.html#1433">StringBuilder</a></span>, <span class="typed"><span class="type">String</span><a id="119588">prefix</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span>): <span class="typed"><span class="type">StringBuilder</span><a href="StringBuilder.scala.html#1433">StringBuilder</a></span> = <span class="typed"><span class="type">StringBuilder</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">=&gt; Boolean</span><a href="#119573">isEmpty</a></span>) {
      <span class="keyword">var</span> <span class="typed"><span class="type">String</span><a id="119589">prefix0</a></span> = <span class="typed"><span class="type">String</span><a href="#119588">prefix</a></span>
      <span class="keyword">var</span> <span class="typed"><span class="type">StringBuilder</span><a id="119590">buf1</a></span> = <span class="typed"><span class="type">StringBuilder</span><a href="#119587">buf</a></span>.<span class="typed"><span class="type">(String)StringBuilder</span><a href="StringBuilder.scala.html#19639">append</a></span>(<span class="typed"><span class="type">String</span><a href="#119589">prefix0</a></span>).<span class="typed"><span class="type">(Any)StringBuilder</span><a href="StringBuilder.scala.html#19638">append</a></span>(<span class="typed"><span class="type">=&gt; A</span><a href="#119574">head</a></span>)
      <span class="typed"><span class="type">String</span><a href="#119589">prefix0</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;, &quot;)</span><span class="string">&quot;, &quot;</span></span>
      <span class="keyword">var</span> <span class="typed"><span class="type">Stream[A]</span><a id="119591">tail0</a></span> = <span class="typed"><span class="type">=&gt; Stream[A]</span><a href="#119575">tail</a></span>
      <span class="typed"><span class="type">Unit</span><a href="#119592" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">Stream[A]</span><a href="#119591">tail0</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) {
        <span class="typed"><span class="type">StringBuilder</span><a href="#119590">buf1</a></span> = <span class="typed"><span class="type">StringBuilder</span><a href="#119587">buf</a></span>.<span class="typed"><span class="type">(String)StringBuilder</span><a href="StringBuilder.scala.html#19639">append</a></span>(<span class="typed"><span class="type">String</span><a href="#119589">prefix0</a></span>).<span class="typed"><span class="type">(Any)StringBuilder</span><a href="StringBuilder.scala.html#19638">append</a></span>(<span class="typed"><span class="type">Stream[A]</span><a href="#119591">tail0</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="Stream.scala.html#18364">head</a></span>)
        <span class="typed"><span class="type">Stream[A]</span><a href="#119591">tail0</a></span> = <span class="typed"><span class="type">Stream[A]</span><a href="#119591">tail0</a></span>.<span class="typed"><span class="type">=&gt; Stream[A]</span><a href="Stream.scala.html#18365">tail</a></span>
      }
      <span class="typed"><span class="type">StringBuilder</span><a href="#119590">buf1</a></span>
    } <span class="keyword">else</span> <span class="typed"><span class="type">StringBuilder</span><a href="#119587">buf</a></span>
  }

}

<span class="comment">/** The empty list.
 *
 *  @author  Martin Odersky
 *  @version 1.0, 15/07/2003
 */</span>
@<span class="typed"><span class="type">SerialVersionUID</span><a href="SerialVersionUID.scala.html#263">SerialVersionUID</a></span>(<span class="int">0</span> <span class="typed"><span class="type">Long(-8256821097970055419L)</span><span >-</span></span> <span class="long">8256821097970055419L</span>)
<span class="keyword">case</span> <span class="keyword">object</span> <span class="typed"><span class="type">object Nil</span><span id="19891"><span id="119611"><span id="119614"><span id="119610"><span id="119612"><span id="333"><span id="3498"><a id="119609">Nil</a></span></span></span></span></span></span></span></span> <span class="keyword">extends</span> <span class="typed"><span class="type">List[Nothing]</span><a href="#524">List</a></span>[Nothing] {
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="21213">isEmpty</a></span> = <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Nothing</span><a id="21214">head</a></span>: <span class="typed"><span class="type">Nothing</span><a id="2165">Nothing</a></span> =
    <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.util.NoSuchElementException</span><a id="25317" class="keyword">new</a></span> <span class="typed"><span class="type">java.util.NoSuchElementException</span><a href="Predef.scala.html#13342">NoSuchElementException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;head of empty list&quot;)</span><span class="string">&quot;head of empty list&quot;</span></span>)
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[Nothing]</span><a id="21215">tail</a></span>: <span class="typed"><span class="type">List[Nothing]</span><a href="#524">List</a></span>[Nothing] =
    <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.util.NoSuchElementException</span><a id="25317" class="keyword">new</a></span> <span class="typed"><span class="type">java.util.NoSuchElementException</span><a href="Predef.scala.html#13342">NoSuchElementException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;tail of empty list&quot;)</span><span class="string">&quot;tail of empty list&quot;</span></span>)
}

<span class="comment">/** A non empty list characterized by a head and a tail.
 *
 *  @author  Martin Odersky
 *  @version 1.0, 15/07/2003
 */</span>
@<span class="typed"><span class="type">SerialVersionUID</span><a href="SerialVersionUID.scala.html#263">SerialVersionUID</a></span>(<span class="long">0L</span> <span class="typed"><span class="type">Long(-8476791151983527571L)</span><span >-</span></span> <span class="long">8476791151983527571L</span>)
<span class="keyword">final</span> <span class="keyword">case</span> <span class="keyword">class</span> <span class="typed"><span class="type">class ::[B] extends List[B] with ScalaObject with Product</span><span id="119656"><span id="119649"><span id="2748"><span id="2749"><span id="119650"><span id="119655"><span id="243"><span id="5792"><span id="21249"><span id="119648"><span id="242"><span id="19891"><span id="3494"><span id="21221"><span id="119647"><span id="3507"><span id="119653"><span id="21252"><span id="119654"><span id="3499"><span id="119651"><a href="runtime/ScalaRunTime.scala.html#19785" id="3498">::</a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><span id="16628"><span id="21251"><a id="21223">B</a></span></span></span>](<span class="keyword">private</span> <span class="keyword">var</span> <span class="typed"><span class="type">B</span><span id="21236"><span id="119667"><span id="21237"><span id="21255"><span id="119645"><span id="21238"><a id="119618">hd</a></span></span></span></span></span></span></span>: <span class="typed"><span class="type">B</span><a href="#16628">B</a></span>, <span class="keyword">private</span>[scala] <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><span id="21241"><span id="21240"><span id="119668"><span id="119646"><span id="21256"><span id="21239"><a id="119619">tl</a></span></span></span></span></span></span></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B]) <span class="keyword">extends</span> <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] {
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; B</span><a id="21243">head</a></span> : <span class="typed"><span class="type">B</span><a href="#16628">B</a></span> = <span class="typed"><span class="type">=&gt; B</span><a href="#21236">hd</a></span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; List[B]</span><a id="21244">tail</a></span> : <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = <span class="typed"><span class="type">=&gt; List[B]</span><a href="#21239">tl</a></span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="21245">isEmpty</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>

  <span class="keyword">import</span> java.io._

  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">(java.io.ObjectOutputStream)Unit</span><a id="21247">writeObject</a></span>(<span class="typed"><span class="type">java.io.ObjectOutputStream</span><a id="119623">out</a></span>: <span class="typed"><span class="type">java.io.ObjectOutputStream</span><a id="3658">ObjectOutputStream</a></span>) {
    <span class="keyword">var</span> <span class="typed"><span class="type">List[B]</span><a id="119624">xs</a></span>: <span class="typed"><span class="type">List[B]</span><a href="#524">List</a></span>[B] = <span class="typed"><span class="type">::[B]</span><a href="#242" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119625" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">List[B]</span><a href="#119624">xs</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="Seq.scala.html#17149">isEmpty</a></span>) { <span class="typed"><span class="type">java.io.ObjectOutputStream</span><a href="#119623">out</a></span>.<span class="typed"><span class="type">(Any)Unit</span><a id="43365">writeObject</a></span>(<span class="typed"><span class="type">List[B]</span><a href="#119624">xs</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="#20869">head</a></span>); <span class="typed"><span class="type">List[B]</span><a href="#119624">xs</a></span> = <span class="typed"><span class="type">List[B]</span><a href="#119624">xs</a></span>.<span class="typed"><span class="type">=&gt; List[B]</span><a href="#20871">tail</a></span> }
    <span class="typed"><span class="type">java.io.ObjectOutputStream</span><a href="#119623">out</a></span>.<span class="typed"><span class="type">(Any)Unit</span><a id="43365">writeObject</a></span>(<span class="typed"><span class="type">object ListSerializeEnd</span><a href="#1101">ListSerializeEnd</a></span>)
  }

  <span class="keyword">private</span> <span class="keyword">def</span> <span class="typed"><span class="type">(java.io.ObjectInputStream)Unit</span><a id="21248">readObject</a></span>(<span class="typed"><span class="type">java.io.ObjectInputStream</span><a id="119638">in</a></span>: <span class="typed"><span class="type">java.io.ObjectInputStream</span><a id="3832">ObjectInputStream</a></span>) {
    <span class="typed"><span class="type">(B)Unit</span><a href="#21237">hd</a></span> = <span class="typed"><span class="type">java.io.ObjectInputStream</span><a href="#119638">in</a></span>.<span class="typed"><span class="type">()java.lang.Object</span><a id="43485">readObject</a></span>.<span class="typed"><span class="type">B</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">B</span><a href="#16628">B</a></span>]
    <span class="typed"><span class="type">(Boolean)Unit</span><a href="Predef.scala.html#13361">assert</a></span>(<span class="typed"><span class="type">=&gt; B</span><a href="#21236">hd</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3495">!=</a></span> <span class="typed"><span class="type">object ListSerializeEnd</span><a href="#1101">ListSerializeEnd</a></span>)
    <span class="keyword">var</span> <span class="typed"><span class="type">::[B]</span><a id="119639">current</a></span>: <span class="typed"><span class="type">::[B]</span><a href="#242">::</a></span>[B] = <span class="typed"><span class="type">::[B]</span><a href="#242" class="keyword">this</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#119641" class="keyword">while</a></span> (<span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>) <span class="typed"><span class="type">java.io.ObjectInputStream</span><a href="#119638">in</a></span>.<span class="typed"><span class="type">()java.lang.Object</span><a id="43485">readObject</a></span> <span class="typed"><span class="type">Unit</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">Nothing</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object ListSerializeEnd</span><a href="#1101">ListSerializeEnd</a></span> =&gt;
        <span class="typed"><span class="type">::[B]</span><a href="#119639">current</a></span>.<span class="typed"><span class="type">(List[B])Unit</span><a href="#21240">tl</a></span> = <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>
        <span class="typed"><span class="type">Nothing</span><span class="keyword">return</span></span>
      <span class="typed"><span class="type">Unit</span><span class="keyword">case</span></span> <span class="typed"><span class="type">java.lang.Object</span><a id="119642">a</a></span> : <span class="typed"><span class="type">Any</span><a id="49">Any</a></span> =&gt;
        <span class="keyword">val</span> <span class="typed"><span class="type">::[B]</span><a id="119643">list</a></span> : <span class="typed"><span class="type">::[B]</span><a href="#242">::</a></span>[B] = <span class="typed"><span class="type">::[B]</span><span class="keyword">new</span></span> <span class="typed"><span class="type">::[B]</span><a href="#242">::</a></span>(<span class="typed"><span class="type">java.lang.Object</span><a href="#119642">a</a></span>.<span class="typed"><span class="type">B</span><a id="3501">asInstanceOf</a></span>[<span class="typed"><span class="type">B</span><a href="#16628">B</a></span>], <span class="typed"><span class="type">object Nil</span><a href="#333">Nil</a></span>)
        <span class="typed"><span class="type">::[B]</span><a href="#119639">current</a></span>.<span class="typed"><span class="type">(List[B])Unit</span><a href="#21240">tl</a></span> = <span class="typed"><span class="type">::[B]</span><a href="#119643">list</a></span>
        <span class="typed"><span class="type">::[B]</span><a href="#119639">current</a></span> = <span class="typed"><span class="type">::[B]</span><a href="#119643">list</a></span>
    }
  }
}

<span class="comment">/** Only used for list serialization */</span>
@<span class="typed"><span class="type">SerialVersionUID</span><a href="SerialVersionUID.scala.html#263">SerialVersionUID</a></span>(<span class="long">0L</span> <span class="typed"><span class="type">Long(-8476791151975527571L)</span><span >-</span></span> <span class="long">8476791151975527571L</span>)
<span class="keyword">private</span>[scala] <span class="keyword">case</span> <span class="keyword">object</span> <span class="typed"><span class="type">object ListSerializeEnd</span><span id="119662"><span id="19891"><span id="1101"><span id="119661"><span id="119665"><span id="119660"><span id="119663"><span id="119659"><a id="3498">ListSerializeEnd</a></span></span></span></span></span></span></span></span></span>

        </pre>
    </body>
</html>