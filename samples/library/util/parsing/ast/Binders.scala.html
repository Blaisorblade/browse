<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>util/parsing/ast/Binders.scala</title>
        <script type="text/javascript" src="../../../jquery-all.js"></script>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style">
    </head>
    <body>
        <pre>
/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2006-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */

<span class="keyword">package</span> scala.util.parsing.ast

<span class="keyword">import</span> scala.collection.mutable.Map

//DISCLAIMER: this code is highly experimental!

  // TODO: avoid clashes when substituting
  // TODO: check binders in the same scope are distinct

/** &lt;p&gt;
 *    This trait provides the core Scrap-Your-Boilerplate abstractions as
 *    well as implementations for common datatypes.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    Based on Ralph Laemmel's &lt;a target=&quot;_top&quot;
 *    href=&quot;http://homepages.cwi.nl/~ralf/publications.html&quot;&gt;SYB papers&lt;/a&gt;.
 *  &lt;/p&gt;
 *
 * @author Adriaan Moors 
 */
<span class="keyword">trait</span> <a title="trait Mappable extends java.lang.Object with ScalaObject" id="14521">Mappable</a> <a href="../../../ScalaObject.scala.html#957" title="ScalaObject">{</a>
  <span class="keyword">trait</span> <a title="trait Mapper extends java.lang.Object" id="249756">Mapper</a> <span title="java.lang.Object">{</span> <span class="keyword">def</span> <a title="[T](x: T)(implicit evidence$1: (T) =&gt; Mappable.this.Mappable[T])T" id="249773">apply</a>[<a title="&gt;: Nothing &lt;: Any" id="249770">T</a> &lt;% Mappable[T]](<a title="T" id="249772">x</a>: <a href="#249770" title="T">T</a>): <a href="#249770" title="T">T</a> } /* TODO: having type `Forall T. T =&gt; T' is too strict: 
  sometimes we want to allow `Forall T &gt;: precision. T =&gt; T' for some type `precision', so that, 
  beneath a certain threshold, we have some leeway.
  concretely: to use gmap for substitution, we simply require that ast nodes are mapped to ast nodes, 
  we can't require that the type is preserved precisely: a Name may map to e.g., a MethodCall 
  */

  <span class="keyword">trait</span> <a title="trait Mappable[T] extends java.lang.Object with ScalaObject" id="249757">Mappable</a>[<a title="&gt;: Nothing &lt;: Any" id="249758">T</a>] <a href="../../../ScalaObject.scala.html#957" title="ScalaObject">{</a>
    // one-layer traversal
    <span class="keyword">def</span> <a title="(f: Mappable.this.Mapper)T" id="249777">gmap</a>(<a title="Mappable.this.Mapper" id="249781">f</a>: <a href="#249756" title="Mappable.this.Mapper">Mapper</a>): <a href="#249758" title="T">T</a>
    //  everywhere f x = f (gmapT (everywhere f) x)
    <span class="keyword">def</span> <a title="(f: Mappable.this.Mapper)(implicit c: (T) =&gt; Mappable.this.Mappable[T])T" id="249778">everywhere</a>(<a title="Mappable.this.Mapper" id="249783">f</a>: <a href="#249756" title="Mappable.this.Mapper">Mapper</a>)(<span class="keyword">implicit</span> <a title="(T) =&gt; Mappable.this.Mappable[T]" id="249784">c</a>: T =&gt; Mappable[T]): <a href="#249758" title="T">T</a> =
      <a href="#249773" title="(x: T)(implicit evidence$1: (T) =&gt; Mappable.this.Mappable[T])T">f</a><a href="#249784" title="(T) =&gt; Mappable.this.Mappable[T]">(</a><a href="#249777" title="(f: Mappable.this.Mapper)T">gmap</a>(<a href="#249790" title="java.lang.Object with Mappable.this.Mapper{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Mappable.this.Mapper" id="249790">Mapper</a> { <span class="keyword">def</span> <a title="[T](x: T)(implicit evidence$2: (T) =&gt; Mappable.this.Mappable[T])T" id="249800">apply</a>[<a title="&gt;: Nothing &lt;: Any" id="249794">T</a> &lt;% Mappable[T]](<a title="T" id="249799">x</a>: <a href="#249794" title="T">T</a>): <a href="#249794" title="T">T</a> = <a href="../../../Function1.scala.html#17119" title="(v1: T)Mappable.this.Mappable[T]">x</a>.<a href="#249778" title="(f: Mappable.this.Mapper)(implicit c: (T) =&gt; Mappable.this.Mappable[T])T">everywhere</a><a href="#249800" title="(T) =&gt; Mappable.this.Mappable[T]">(</a><a href="#249783" title="Mappable.this.Mapper">f</a>)}))
  }

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit scala.util.parsing.ast.Mappable.StringIsMappable : (s: String)Mappable.this.Mappable[String]" id="249759">StringIsMappable</a>(<a title="String" id="249833">s</a>: <span title="String">String</span>): <a href="#249757" title="Mappable.this.Mappable[String]">Mappable</a>[String] =
    <a href="#249891" title="java.lang.Object with Mappable.this.Mappable[String]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Mappable.this.Mappable[String]" id="249891">Mappable</a>[String] {
      <span class="keyword">def</span> <a title="(f: Mappable.this.Mapper)String" id="249893">gmap</a>(<a title="Mappable.this.Mapper" id="249898">f</a>: <a href="#249756" title="Mappable.this.Mapper">Mapper</a>): <span title="String">String</span> = <a href="#249773" title="(x: String)(implicit evidence$1: (String) =&gt; Mappable.this.Mappable[String])String">f</a><a href="#249759" title="implicit scala.util.parsing.ast.Mappable.StringIsMappable : (s: String)Mappable.this.Mappable[String]">(</a><a href="#249833" title="String">s</a>) 
    }

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[t](xs: List[t])(implicit evidence$3: (t) =&gt; Mappable.this.Mappable[t])Mappable.this.Mappable[List[t]]" id="249827">ListIsMappable</a>[<a title="&gt;: Nothing &lt;: Any" id="249762">t</a> &lt;% Mappable[t]](<a title="List[t]" id="249826">xs</a>: <a href="../../../collection/immutable/List.scala.html#8973" title="List[t]">List</a>[t]): <a href="#249757" title="Mappable.this.Mappable[List[t]]">Mappable</a>[List[t]] =
    <a href="#249929" title="java.lang.Object with Mappable.this.Mappable[List[t]]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Mappable.this.Mappable[List[t]]" id="249929">Mappable</a>[List[t]] {
      <span class="keyword">def</span> <a title="(f: Mappable.this.Mapper)List[t]" id="249931">gmap</a>(<a title="Mappable.this.Mapper" id="249936">f</a>: <a href="#249756" title="Mappable.this.Mapper">Mapper</a>): <a href="../../../collection/immutable/List.scala.html#8973" title="List[t]">List</a>[t] = (<span class="keyword">for</span> (<a title="t" id="249946">x</a> &lt;- <a href="../../../collection/generic/TraversableTemplate.scala.html#17161" title="(f: (t) =&gt; t)(implicit bf: scala.collection.generic.BuilderFactory[t,List[t],List[t]])List[t]">xs</a>) <span class="keyword">yield</span> <a href="#249773" title="(x: t)(implicit evidence$1: (t) =&gt; Mappable.this.Mappable[t])t">f</a><a href="#249827" title="(t) =&gt; Mappable.this.Mappable[t]">(</a><a href="#249946" title="t">x</a>)).<a href="../../../collection/immutable/List.scala.html#17655" title="=&gt; List[t]">toList</a>
    }

  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[t](xs: Option[t])(implicit evidence$4: (t) =&gt; Mappable.this.Mappable[t])Mappable.this.Mappable[Option[t]]" id="249820">OptionIsMappable</a>[<a title="&gt;: Nothing &lt;: Any" id="249765">t</a> &lt;% Mappable[t]](<a title="Option[t]" id="249819">xs</a>: <a href="../../../Option.scala.html#777" title="Option[t]">Option</a>[t]): <a href="#249757" title="Mappable.this.Mappable[Option[t]]">Mappable</a>[Option[t]] =
    <a href="#250057" title="java.lang.Object with Mappable.this.Mappable[Option[t]]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Mappable.this.Mappable[Option[t]]" id="250057">Mappable</a>[Option[t]] {
      <span class="keyword">def</span> <a title="(f: Mappable.this.Mapper)Option[t]" id="250059">gmap</a>(<a title="Mappable.this.Mapper" id="250064">f</a>: <a href="#249756" title="Mappable.this.Mapper">Mapper</a>): <a href="../../../Option.scala.html#777" title="Option[t]">Option</a>[t] = (<span class="keyword">for</span> (<a title="t" id="250070">x</a> &lt;- <a href="../../../Option.scala.html#19766" title="(f: (t) =&gt; t)Option[t]">xs</a>) <span class="keyword">yield</span> <a href="#249773" title="(x: t)(implicit evidence$1: (t) =&gt; Mappable.this.Mappable[t])t">f</a><a href="#249820" title="(t) =&gt; Mappable.this.Mappable[t]">(</a><a href="#250070" title="t">x</a>))
    }
}

/** &lt;p&gt;
 *    This component provides functionality for enforcing variable binding
 *    during parse-time.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *   When parsing simple languages, like Featherweight Scala, these parser
 *   combinators will fully enforce the binding discipline. When names are
 *   allowed to be left unqualified, these mechanisms would have to be
 *   complemented by an extra phase that resolves names that couldn't be
 *   resolved using the naive binding rules. (Maybe some machinery to
 *   model `implicit' binders (e.g., `this' and imported qualifiers) 
 *   and selection on a binder will suffice?)
 * &lt;/p&gt;
 *
 * @author Adriaan Moors 
 */
<span class="keyword">trait</span> <a title="trait Binders extends java.lang.Object with scala.util.parsing.ast.AbstractSyntax with scala.util.parsing.ast.Mappable with ScalaObject" id="14485">Binders</a> <a href="../../../ScalaObject.scala.html#957" title="ScalaObject" class="keyword">extends</a> <a href="AbstractSyntax.scala.html#14464" title="scala.util.parsing.ast.AbstractSyntax">AbstractSyntax</a> <span class="keyword">with</span> <a href="#14521" title="scala.util.parsing.ast.Mappable">Mappable</a> {
  /** A `Scope' keeps track of one or more syntactic elements that represent bound names.
   * The elements it contains share the same scope and must all be distinct (wrt. ==)
   *
   * A `NameElement' `n' in the AST that is conceptually bound by a `Scope' `s', is replaced by a 
   * `BoundElement(n, s)'. (For example, in `val x:Int=x+1', the first `x' is modelled by a
   * Scope `s' that contains `x' and the second `x' is represented by a `BoundElement(`x', s)')
   * The term (`x+1') in scope of the Scope becomes an `UnderBinder(s, `x+1').
   *
   * A `NameElement' `n' is bound by a `Scope' `s' if it is wrapped as a `BoundElement(`n', s)', and 
   * `s' has a binder element that is semantically equal (`equals' or `==') to `n'.
   *
   * A `Scope' is represented textually by its list of binder elements, followed by the scope's `id'.
   * For example: `[x, y]!1' represents the scope with `id' `1' and binder elements `x' and `y'.
   * (`id' is solely used for this textual representation.)
   */
  <span class="keyword">class</span> <a title="class Scope[binderType &lt;: Binders.this.NameElement] extends java.lang.Object with Iterable[binderType] with ScalaObject" id="250104">Scope</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250105">binderType</a> &lt;: NameElement] <a href="../../../ScalaObject.scala.html#957" title="ScalaObject" class="keyword">extends</a> <a href="../../../collection/Iterable.scala.html#4460" title="Iterable[binderType]">Iterable</a>[binderType]{
    <span class="keyword">private</span> <span class="keyword">val</span> <a title="scala.collection.mutable.Map[binderType,Binders.this.Element]" id="250153">substitution</a>: <a href="../../../collection/mutable/Map.scala.html#7590" title="scala.collection.mutable.Map[binderType,Binders.this.Element]">Map</a>[binderType, Element] = 
      <span title="scala.collection.mutable.LinkedHashMap[binderType,Binders.this.Element]" class="keyword">new</span> scala.collection.mutable.<a href="../../../collection/mutable/LinkedHashMap.scala.html#7884" title="scala.collection.mutable.LinkedHashMap[binderType,Binders.this.Element]">LinkedHashMap</a>[binderType, Element] // a LinkedHashMap is ordered by insertion order -- important!
    
    /** Returns a unique number identifying this Scope (only used for representation purposes).
     */
    <span class="keyword">val</span> <a title="Int" id="250155">id</a>: <span title="Int">Int</span> = <a href="#250148" title="object Binders.this._Binder">_Binder</a>.<a href="#250180" title="=&gt; Int">genId</a>
    
    /** Returns the binders in this scope.
     * For a typical let-binding, this is just the variable name. For an argument list to a method body,
     * there is one binder per formal argument.
     */
    <span class="keyword">def</span> <a title="=&gt; Iterator[binderType]" id="250157">iterator</a> = <a href="#250153" title="=&gt; scala.collection.mutable.Map[binderType,Binders.this.Element]">substitution</a>.<a href="../../../collection/generic/MapTemplate.scala.html#35288" title="=&gt; Iterator[binderType]">keysIterator</a>
    
    /** Return the `i'th binder in this scope.*/
    <span class="keyword">def</span> <a title="(i: Int)binderType" id="250158">apply</a>(<a title="Int" id="250259">i</a>: <span title="Int">Int</span>): <a href="#250105" title="binderType">binderType</a> = <a href="#250104" title="Scope.this.type" class="keyword">this</a>.<a href="#250157" title="=&gt; Iterator[binderType]">iterator</a>.<a href="../../../collection/generic/LinearSequenceTemplate.scala.html#19400" title="(n: Int)binderType">toList</a>(<a href="#250259" title="Int">i</a>)
    
    /** Returns true if this container has a binder equal (==) to `b'
     */
    <span class="keyword">def</span> <a title="(b: binderType)Boolean" id="250159">binds</a>(<a title="binderType" id="250271">b</a>: <a href="#250105" title="binderType">binderType</a>): <span title="Boolean">Boolean</span> = <a href="#250153" title="=&gt; scala.collection.mutable.Map[binderType,Binders.this.Element]">substitution</a>.<a href="../../../collection/generic/MapTemplate.scala.html#35284" title="(key: binderType)Boolean">contains</a>(<a href="#250271" title="binderType">b</a>)
    
    <span class="keyword">def</span> <a title="(b: binderType)Option[Int]" id="250160">indexFor</a>(<a title="binderType" id="250276">b</a>: <a href="#250105" title="binderType">binderType</a>): <a href="../../../Option.scala.html#777" title="Option[Int]">Option</a>[Int] = {
      <span class="keyword">val</span> <a title="&lt;refinement&gt; extends java.lang.Object with Iterator[(binderType, Int)]" id="250278">iter</a> = <a href="#250104" title="Scope.this.type" class="keyword">this</a>.<a href="#250157" title="=&gt; Iterator[binderType]">iterator</a>.<a href="../../../collection/Iterator.scala.html#19211" title="=&gt; &lt;refinement&gt; extends java.lang.Object with Iterator[(binderType, Int)]">zipWithIndex</a>
      <span class="keyword">for</span> ((<a title="binderType" id="250305">that</a>, <a title="Int" id="250306">count</a>) &lt;- <a href="../../../collection/Iterator.scala.html#19219" title="(f: ((binderType, Int)) =&gt; Unit)Unit">iter</a>) {
        <span title="Unit" class="keyword">if</span> (<a href="#250305" title="binderType">that</a>.<a href="AbstractSyntax.scala.html#157282" title="(x$1: AnyRef)Boolean">name</a> == <a href="#250276" title="binderType">b</a>.<a href="AbstractSyntax.scala.html#157282" title="=&gt; String">name</a>) // TODO: why do name equals and structural equals differ?
          <span title="Nothing" class="keyword">return</span> <a href="../../../Option.scala.html#19800" title="(x: Int)Some[Int]">Some</a>(<a href="#250306" title="(x$1: Int)Int">count</a> + <span title="Int(1)" class="int">1</span>)
        <span class="keyword">else</span>
          <a href="../../../Console.scala.html#388" title="object Console">Console</a>.<a href="../../../Console.scala.html#58871" title="(x: Any)Unit">println</a>(<a href="../../../runtime/StringAdd.scala.html#18936" title="(other: String)java.lang.String">that</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;!=&quot;)" class="string">&quot;!=&quot;</span>+<a href="#250276" title="binderType">b</a>)
      }
      
      <a href="../../../Option.scala.html#463" title="object None">None</a>
    }

    /** Adds a new binder.
     * (e.g. the variable name in a local variable declaration) 
     *
     * @param b a new binder that is distinct from the existing binders in this scope, 
     *           and shares their conceptual scope
     * @pre canAddBinder(b)
     * @post binds(b)
     * @post getElementFor(b) eq b
     */
    <span class="keyword">def</span> <a title="(b: binderType)Unit" id="250161">addBinder</a>(<a title="binderType" id="250378">b</a>: <a href="#250105" title="binderType">binderType</a>) { <a href="../../../collection/generic/MutableMapTemplate.scala.html#57775" title="(kv: (binderType, Binders.this.Element))Scope.this.substitution.type">substitution</a> <span title="Unit">+=</span> <a href="../../../Predef.scala.html#232109" title="(x: binderType,y: binderType)(binderType, binderType)">Pair</a>(<a href="#250378" title="binderType">b</a>, <a href="#250378" title="binderType">b</a>) }

    /** `canAddElement' indicates whether `b' may be added to this scope.
     *
     * TODO: strengthen this condition so that no binders may be added after this scope has been 
     *       linked to its `UnderBinder' (i.e., while parsing, BoundElements may be added to the Scope
     *       associated to the UnderBinder, but after that, no changes are allowed, except for substitution)?
     *
     * @returns true if `b' had not been added yet 
     */
    <span class="keyword">def</span> <a title="(b: binderType)Boolean" id="250162">canAddBinder</a>(<a title="binderType" id="250409">b</a>: <a href="#250105" title="binderType">binderType</a>): <span title="Boolean">Boolean</span> = <a title="=&gt; Boolean" id="2203">!</a><a href="#250159" title="(b: binderType)Boolean">binds</a>(<a href="#250409" title="binderType">b</a>)

    /** ``Replaces'' the bound occurrences of a contained binder by their new value.
     * The bound occurrences of `b' are not actually replaced; the scope keeps track
     * of a substitution that maps every binder to its current value. Since a `BoundElement' is
     * a proxy for the element it is bound to by its binder, `substitute' may thus be thought of
     * as replacing all the bound occurrences of the given binder `b' by their new value `value'.
     *
     * @param b    the binder whose bound occurrences should be given a new value
     * @param value the new value for the bound occurrences of `b'
     * @pre binds(b)
     * @post getElementFor(b) eq value
     */
    <span class="keyword">def</span> <a title="(b: binderType,value: Binders.this.Element)Unit" id="250163">substitute</a>(<a title="binderType" id="250413">b</a>: <a href="#250105" title="binderType">binderType</a>, <a title="Binders.this.Element" id="250414">value</a>: <a href="AbstractSyntax.scala.html#157276" title="Binders.this.Element">Element</a>): <a title="Unit" id="1948">Unit</a> = <a href="../../../collection/generic/MutableMapTemplate.scala.html#57774" title="(key: binderType,value: Binders.this.Element)Unit">substitution</a>(<a href="#250413" title="binderType">b</a>) = <a href="#250414" title="Binders.this.Element">value</a>
    
    /** Returns the current value for the bound occurrences of `b'.
     *
     * @param b the contained binder whose current value should be returned
     * @pre binds(b)
     */
    <span class="keyword">def</span> <a title="(b: binderType)Binders.this.Element" id="250164">getElementFor</a>(<a title="binderType" id="250420">b</a>: <a href="#250105" title="binderType">binderType</a>): <a href="AbstractSyntax.scala.html#157276" title="Binders.this.Element">Element</a> = <a href="../../../collection/generic/MapTemplate.scala.html#35283" title="(key: binderType)Binders.this.Element">substitution</a>(<a href="#250420" title="binderType">b</a>)    

    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="250165">toString</a>: <span title="String">String</span> =  <a href="#250104" title="Scope.this.type" class="keyword">this</a>.<a href="#250157" title="=&gt; Iterator[binderType]">iterator</a>.<a href="../../../collection/Iterator.scala.html#19281" title="=&gt; List[binderType]">toList</a>.<a href="../../../collection/generic/TraversableTemplate.scala.html#17246" title="(start: String,sep: String,end: String)String">mkString</a><span title="(x$1: Any)java.lang.String">(</span><span title="java.lang.String(&quot;[&quot;)" class="string">&quot;[&quot;</span>,<span title="java.lang.String(&quot;, &quot;)" class="string">&quot;, &quot;</span>,<span title="java.lang.String(&quot;]&quot;)" class="string">&quot;]&quot;</span>)<span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;!&quot;)" class="string">&quot;!&quot;</span>+<a href="#250155" title="=&gt; Int">id</a> // TODO show substitution?

    /** Returns a list of strings that represent the binder elements, each tagged with this scope's id.*/
    <span class="keyword">def</span> <a title="=&gt; List[String]" id="250166">bindersToString</a>: <a href="../../../collection/immutable/List.scala.html#8973" title="List[String]">List</a>[String] = (<span class="keyword">for</span>(<a title="binderType" id="250456">b</a> &lt;- <a href="#250104" title="Scope.this.type" class="keyword">this</a>.<a href="../../../collection/Iterator.scala.html#19189" title="(f: (binderType) =&gt; java.lang.String)Iterator[java.lang.String]">iterator</a>) <span class="keyword">yield</span> <a href="../../../runtime/StringAdd.scala.html#18936" title="(other: String)java.lang.String">b</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;!&quot;)" class="string">&quot;!&quot;</span>+<a href="#250155" title="=&gt; Int">id</a>).<a href="../../../collection/Iterator.scala.html#19281" title="=&gt; List[java.lang.String]">toList</a>
    
    /** Return a new inheriting scope that won't check whether binding is respected until the scope is left (so as to support forward references) **/
    <span class="keyword">def</span> <a title="=&gt; Binders.this.Scope[binderType]" id="250167">allowForwardRef</a>: <a href="#250104" title="Binders.this.Scope[binderType]">Scope</a>[binderType] = <a href="#250104" title="Binders.this.Scope[binderType]" class="keyword">this</a> // TODO

    /** Return a nested scope -- binders entered into it won't be visible in this scope, but if this scope allows forward references, 
        the binding in the returned scope also does, and thus the check that all variables are bound is deferred until this scope is left  **/
    <span class="keyword">def</span> <a title="=&gt; Binders.this.Scope[binderType]" id="250168">nested</a>: <a href="#250104" title="Binders.this.Scope[binderType]">Scope</a>[binderType] = <a href="#250104" title="Binders.this.Scope[binderType]" class="keyword">this</a> // TODO
    
    <span class="keyword">def</span> <a title="=&gt; Unit" id="250169">onEnter</a> <span title="Unit">{</span>}
    <span class="keyword">def</span> <a title="=&gt; Unit" id="250170">onLeft</a> <span title="Unit">{</span>}
  }

  
  <span class="keyword">trait</span> <a title="trait BindingSensitive extends java.lang.Object" id="250106">BindingSensitive</a> <span title="java.lang.Object">{</span>
    // would like to specify this as one method:
    // def alpha_==[t &lt;: NameElement](other: BoundElement[t]): Boolean
    // def alpha_==[bt &lt;: binderType, st &lt;: elementT](other: UnderBinder[bt, st]): Boolean 
  }

  /** A `BoundElement' is bound in a certain scope `scope', which keeps track of the actual element that 
   * `el' stands for.                                                               
   *
   * A `BoundElement' is represented textually by its bound element, followed by its scope's `id'.
   * For example: `x@1' represents the variable `x' that is bound in the scope with `id' `1'.
   *
   * @invar scope.binds(el)
   */
  case <span class="keyword">class</span> <a title="class BoundElement[boundElement &lt;: Binders.this.NameElement] extends java.lang.Object with Binders.this.NameElement with Proxy with Binders.this.BindingSensitive with ScalaObject with Product" id="250730">BoundElement</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250732">boundElement</a> &lt;: NameElement]<a href="../../../ScalaObject.scala.html#957" title="ScalaObject">(</a><a title="boundElement" id="251055">el</a>: <a href="#250732" title="boundElement">boundElement</a>, <a title="Binders.this.Scope[boundElement]" id="251056">scope</a>: <a href="#250104" title="Binders.this.Scope[boundElement]">Scope</a>[boundElement]) <span class="keyword">extends</span> <a href="AbstractSyntax.scala.html#157277" title="Binders.this.NameElement">NameElement</a> <span class="keyword">with</span> <a href="../../../Proxy.scala.html#180" title="Proxy">Proxy</a> <span class="keyword">with</span> <a href="#250106" title="Binders.this.BindingSensitive">BindingSensitive</a> { 
    /** Returns the element this `BoundElement' stands for. 
     * The `Proxy' trait ensures `equals', `hashCode' and `toString' are forwarded to 
     * the result of this method.
     */
    <span class="keyword">def</span> <a title="=&gt; Binders.this.Element" id="250501">self</a>: <a href="AbstractSyntax.scala.html#157276" title="Binders.this.Element">Element</a> = <a href="#251056" title="=&gt; Binders.this.Scope[boundElement]">scope</a>.<a href="#250164" title="(b: boundElement)Binders.this.Element">getElementFor</a>(<a href="#251055" title="=&gt; boundElement">el</a>)
    
    <span class="keyword">def</span> <a title="=&gt; String" id="250502">name</a> = <a href="#250501" title="=&gt; Binders.this.Element">self</a>.<span title="[T0]T0">asInstanceOf</span><span title="Binders.this.NameElement">[</span><a href="AbstractSyntax.scala.html#157277" title="Binders.this.NameElement">NameElement</a>].<a href="AbstractSyntax.scala.html#157282" title="=&gt; String">name</a> // TODO: this is only safe when substituted to a NameElement, which certainly isn't required -- I want dynamic inheritance! :)

    // decorate element's representation with the id of the scope it's bound in
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="250503">toString</a>: <span title="String">String</span> =  <span class="keyword">super</span>.<a href="../../../Proxy.scala.html#18026" title="(x$1: Any)java.lang.String">toString</a><span title="(x$1: Any)java.lang.String">+</span><span title="java.lang.String(&quot;@&quot;)" class="string">&quot;@&quot;</span>+<a href="#251056" title="=&gt; Binders.this.Scope[boundElement]">scope</a>.<a href="#250155" title="=&gt; Int">id</a>
    
    <span class="keyword">def</span> <a title="[t &lt;: Binders.this.NameElement](other: Binders.this.BoundElement[t])Boolean" id="250504">alpha_==</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250506">t</a> &lt;: NameElement](<a title="Binders.this.BoundElement[t]" id="250534">other</a>: <a href="#250730" title="Binders.this.BoundElement[t]">BoundElement</a>[t]): <span title="Boolean">Boolean</span> = <a href="#251056" title="=&gt; Binders.this.Scope[boundElement]">scope</a>.<a href="#250160" title="(b: boundElement)Option[Int]">indexFor</a><span title="(x$1: AnyRef)Boolean">(</span><a href="#251055" title="=&gt; boundElement">el</a>) == <a href="#250534" title="Binders.this.BoundElement[t]">other</a>.<a href="#251056" title="=&gt; Binders.this.Scope[t]">scope</a>.<a href="#250160" title="(b: t)Option[Int]">indexFor</a>(<a href="#250534" title="Binders.this.BoundElement[t]">other</a>.<a href="#251055" title="=&gt; t">el</a>)
  }  
  
  /** A variable that escaped its scope (i.e., a free variable) -- we don't deal very well with these yet
   */
  <span class="keyword">class</span> <a title="class UnboundElement[N &lt;: Binders.this.NameElement] extends java.lang.Object with Binders.this.NameElement with ScalaObject" id="250111">UnboundElement</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250112">N</a> &lt;: NameElement]<a href="../../../ScalaObject.scala.html#957" title="ScalaObject">(</a><span class="keyword">private</span> <span class="keyword">val</span> <a title="N" id="250592">el</a>: <a href="#250112" title="N">N</a>) <span class="keyword">extends</span> <a href="AbstractSyntax.scala.html#157277" title="Binders.this.NameElement">NameElement</a> {
    <span class="keyword">def</span> <a title="=&gt; java.lang.String" id="250589">name</a> = <a href="#250592" title="=&gt; N">el</a>.<a href="AbstractSyntax.scala.html#157282" title="(x$1: Any)java.lang.String">name</a>+<span title="java.lang.String(&quot;@??&quot;)" class="string">&quot;@??&quot;</span>
  }
  
  // this is useless, as Element is a supertype of BoundElement --&gt; the coercion will never be inferred
  // if we knew a more specific type for the element that the bound element represents, this could make sense
  // implicit def BoundElementProxy[t &lt;: NameElement](e: BoundElement[t]): Element = e.self
                                                                     
  /** Represents an element with variables that are bound in a certain scope. 
   */
  <span class="keyword">class</span> <a title="class UnderBinder[binderType &lt;: Binders.this.NameElement, elementT] extends java.lang.Object with Binders.this.Element with Binders.this.BindingSensitive with ScalaObject" id="250113">UnderBinder</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250114">binderType</a>  &lt;: NameElement, <a title="&gt;: Nothing &lt;: Any" id="250115">elementT</a> &lt;% Mappable[elementT]](<span class="keyword">val</span> <a title="Binders.this.Scope[binderType]" id="250604">scope</a>: <a href="#250104" title="Binders.this.Scope[binderType]">Scope</a>[binderType], <span class="keyword">private</span>[Binders] <span class="keyword">val</span> <a title="elementT" id="250605">element</a>: <a href="#250115" title="elementT">elementT</a>) <span class="keyword">extends</span> <a href="AbstractSyntax.scala.html#157276" title="Binders.this.Element">Element</a> <span class="keyword">with</span> <a href="#250106" title="Binders.this.BindingSensitive">BindingSensitive</a> {
    <span class="keyword">override</span> <span class="keyword">def</span> <a title="()String" id="250215">toString</a>: <span title="String">String</span> = <span title="(x$1: Any)java.lang.String" class="string">&quot;(&quot;</span> <span title="(x$1: Any)java.lang.String">+</span> <a href="#250604" title="=&gt; Binders.this.Scope[binderType]">scope</a>.<a href="#250165" title="()String">toString</a> <span title="(x$1: Any)java.lang.String">+</span> <span title="java.lang.String(&quot;) in { &quot;)" class="string">&quot;) in { &quot;</span><span title="(x$1: Any)java.lang.String">+</span><a href="#250605" title="=&gt; elementT">element</a>.<span title="()java.lang.String">toString</span>+<span title="java.lang.String(&quot; }&quot;)" class="string">&quot; }&quot;</span>
      
    /** Alpha-equivalence -- TODO
     * Returns true if the `element' of the `other' `UnderBinder' is equal to this `element' up to alpha-conversion.
     *
     * That is, regular equality is used for all elements but `BoundElement's: such an element is 
     * equal to a `BoundElement' in `other' if their binders are equal. Binders are equal if they
     * are at the same index in their respective scope. 
     *
     * Example: UnderBinder([x, y]!1, x@1) alpha_== UnderBinder([a, b]!2, a@2)
     *          ! (UnderBinder([x, y]!1, y@1) alpha_== UnderBinder([a, b]!2, a@2))
     */
    /*def alpha_==[bt &lt;: binderType, st &lt;: elementT](other: UnderBinder[bt, st]): Boolean = {
       var result = true
       
       // TODO: generic zip or gmap2
       element.gmap2(other.element, new Mapper2 {
         def apply[s  &lt;% Mappable[s], t  &lt;% Mappable[t]](x :{s, t}): {s, t} = x match {
           case {be1: BoundElement[_], be2: BoundElement[_]} =&gt; result == result &amp;&amp; be1.alpha_==(be2) // monadic gmap (cheating using state directly)
           case {ub1: UnderBinder[_, _], ub2: UnderBinder[_, _]} =&gt; result == result &amp;&amp; be1.alpha_==(be2)        
           case {a, b} =&gt; result == result &amp;&amp; a.equals(b)
         }; x
       })
    }*/
    
    <span class="keyword">def</span> <a title="(subst: scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement])elementT" id="250216">cloneElementWithSubst</a>(<a title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]" id="250623">subst</a>: scala.collection.immutable.<a href="../../../collection/immutable/Map.scala.html#8874" title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]">Map</a>[NameElement, NameElement]) = <a href="../../../Function1.scala.html#17119" title="(v1: elementT)Binders.this.Mappable[elementT]">element</a>.<a href="#249777" title="(f: Binders.this.Mapper)elementT">gmap</a>(<a href="#250651" title="java.lang.Object with Binders.this.Mapper{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Binders.this.Mapper" id="250651">Mapper</a> { <span class="keyword">def</span> <a title="[t](x: t)(implicit evidence$6: (t) =&gt; Binders.this.Mappable[t])t" id="250661">apply</a>[<a title="&gt;: Nothing &lt;: Any" id="250655">t</a> &lt;% Mappable[t]](<a title="t" id="250660">x</a> :<a href="#250655" title="t">t</a>): <a href="#250655" title="t">t</a> = <a href="#250660" title="t">x</a> <span title="t" class="keyword">match</span>{
      <span title="t" class="keyword">case</span> <a title="Binders.this.NameElement" id="250670">substable</a>: <a href="AbstractSyntax.scala.html#157277" title="Binders.this.NameElement">NameElement</a> <span class="keyword">if</span> <a href="#250623" title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]">subst</a>.<a href="../../../collection/generic/MapTemplate.scala.html#35284" title="(key: Binders.this.NameElement)Boolean">contains</a>(<a href="#250670" title="Binders.this.NameElement">substable</a>) =&gt; <a href="#250623" title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]">subst</a>.<a href="../../../collection/generic/MapTemplate.scala.html#35273" title="(key: Binders.this.NameElement)Option[Binders.this.NameElement]">get</a>(<a href="#250670" title="Binders.this.NameElement">substable</a>).<span title="[T0]T0">asInstanceOf</span><span title="t">[</span><a href="#250655" title="t">t</a>] // TODO: wrong... substitution is not (necessarily) the identity function	
         //Console.println(&quot;substed: &quot;+substable+&quot;-&gt; &quot;+subst.get(substable)+&quot;)&quot;);
      <span title="t" class="keyword">case</span> <a title="t" id="250677">x</a> =&gt; <a href="#250677" title="t">x</a> // Console.println(&quot;subst: &quot;+x+&quot;(keys: &quot;+subst.keys+&quot;)&quot;);x
    }})
    
    // TODO
    <span class="keyword">def</span> <a title="=&gt; elementT" id="250217">cloneElementNoBoundElements</a> = <a href="../../../Function1.scala.html#17119" title="(v1: elementT)Binders.this.Mappable[elementT]">element</a>.<a href="#249777" title="(f: Binders.this.Mapper)elementT">gmap</a>(<a href="#250710" title="java.lang.Object with Binders.this.Mapper{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Binders.this.Mapper" id="250710">Mapper</a> { <span class="keyword">def</span> <a title="[t](x: t)(implicit evidence$7: (t) =&gt; Binders.this.Mappable[t])t" id="250720">apply</a>[<a title="&gt;: Nothing &lt;: Any" id="250714">t</a> &lt;% Mappable[t]](<a title="t" id="250719">x</a> :<a href="#250714" title="t">t</a>): <a href="#250714" title="t">t</a> = <a href="#250719" title="t">x</a> <span title="t" class="keyword">match</span>{ 
      <span title="t" class="keyword">case</span> BoundElement(<a title="Binders.this.NameElement" id="250755">el</a>, _) =&gt; <span title="Binders.this.UnboundElement[Binders.this.NameElement]" class="keyword">new</span> <a href="#250111" title="Binders.this.UnboundElement[Binders.this.NameElement]">UnboundElement</a>(<a href="#250755" title="Binders.this.NameElement">el</a>).<span title="[T0]T0">asInstanceOf</span><span title="t">[</span><a href="#250714" title="t">t</a>] // TODO: precision stuff
      <span title="t" class="keyword">case</span> <a title="t" id="250763">x</a> =&gt; <a href="#250763" title="t">x</a>
    }})

    <span class="keyword">def</span> <a title="=&gt; elementT" id="250218">extract</a>: <a href="#250115" title="elementT">elementT</a> = <a href="#250217" title="=&gt; elementT">cloneElementNoBoundElements</a>
    <span class="keyword">def</span> <a title="(subst: scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement])elementT" id="250219">extract</a>(<a title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]" id="250770">subst</a>: scala.collection.immutable.<a href="../../../collection/immutable/Map.scala.html#8874" title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]">Map</a>[NameElement, NameElement]): <a href="#250115" title="elementT">elementT</a> = <a href="#250216" title="(subst: scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement])elementT">cloneElementWithSubst</a>(<a href="#250770" title="scala.collection.immutable.Map[Binders.this.NameElement,Binders.this.NameElement]">subst</a>)
    
    /** Get a string representation of element, normally we don't allow direct access to element, but just getting a string representation is ok*/
    <span class="keyword">def</span> <a title="=&gt; String" id="250220">elementToString</a>: <span title="String">String</span> = <a href="#250605" title="=&gt; elementT">element</a>.<span title="()java.lang.String">toString</span>
  }
  
  //SYB type class instances
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[bt &lt;: Binders.this.NameElement, st](ub: Binders.this.UnderBinder[bt,st])(implicit evidence$8: (bt) =&gt; Binders.this.Mappable[bt],implicit evidence$9: (st) =&gt; Binders.this.Mappable[st])Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]" id="250201">UnderBinderIsMappable</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250119">bt</a> &lt;: NameElement &lt;% Mappable[bt], <a title="&gt;: Nothing &lt;: Any" id="250120">st</a> &lt;% Mappable[st]](<a title="Binders.this.UnderBinder[bt,st]" id="250199">ub</a>: <a href="#250113" title="Binders.this.UnderBinder[bt,st]">UnderBinder</a>[bt, st]): <a href="#249757" title="Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]">Mappable</a>[UnderBinder[bt, st]] = 
    <a href="#250778" title="java.lang.Object with Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Binders.this.Mappable[Binders.this.UnderBinder[bt,st]]" id="250778">Mappable</a>[UnderBinder[bt, st]] {
      <span class="keyword">def</span> <a title="(f: Binders.this.Mapper)Binders.this.UnderBinder[bt,st]" id="250780">gmap</a>(<a title="Binders.this.Mapper" id="250785">f</a>: <a href="#249756" title="Binders.this.Mapper">Mapper</a>): <a href="#250113" title="Binders.this.UnderBinder[bt,st]">UnderBinder</a>[bt, st] = <a href="#250801" title="(scope: Binders.this.Scope[bt],element: st)(implicit evidence$11: (st) =&gt; Binders.this.Mappable[st])Binders.this.UnderBinder[bt,st]">UnderBinder</a><a href="#250201" title="(st) =&gt; Binders.this.Mappable[st]">(</a><a href="#249773" title="(x: Binders.this.Scope[bt])(implicit evidence$1: (Binders.this.Scope[bt]) =&gt; Binders.this.Mappable[Binders.this.Scope[bt]])Binders.this.Scope[bt]">f</a><a href="#250222" title="(scope: Binders.this.Scope[bt])(implicit evidence$10: (bt) =&gt; Binders.this.Mappable[bt])Binders.this.Mappable[Binders.this.Scope[bt]]">(</a><a href="#250199" title="Binders.this.UnderBinder[bt,st]">ub</a>.<a href="#250604" title="=&gt; Binders.this.Scope[bt]">scope</a>), <a href="#249773" title="(x: st)(implicit evidence$1: (st) =&gt; Binders.this.Mappable[st])st">f</a><a href="#250201" title="(st) =&gt; Binders.this.Mappable[st]">(</a><a href="#250199" title="Binders.this.UnderBinder[bt,st]">ub</a>.<a href="#250605" title="=&gt; st">element</a>))
    }  
  
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="[bt &lt;: Binders.this.NameElement](scope: Binders.this.Scope[bt])(implicit evidence$10: (bt) =&gt; Binders.this.Mappable[bt])Binders.this.Mappable[Binders.this.Scope[bt]]" id="250222">ScopeIsMappable</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250123">bt</a> &lt;: NameElement &lt;% Mappable[bt]](<a title="Binders.this.Scope[bt]" id="250221">scope</a>: <a href="#250104" title="Binders.this.Scope[bt]">Scope</a>[bt]): <a href="#249757" title="Binders.this.Mappable[Binders.this.Scope[bt]]">Mappable</a>[Scope[bt]] = 
    <a href="#250974" title="java.lang.Object with Binders.this.Mappable[Binders.this.Scope[bt]]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Binders.this.Mappable[Binders.this.Scope[bt]]" id="250974">Mappable</a>[Scope[bt]] {
      <span class="keyword">def</span> <a title="(f: Binders.this.Mapper)Binders.this.Scope[bt]" id="250976">gmap</a>(<a title="Binders.this.Mapper" id="250981">f</a>: <a href="#249756" title="Binders.this.Mapper">Mapper</a>): <a href="#250104" title="Binders.this.Scope[bt]">Scope</a>[bt] = { <span class="keyword">val</span> <a title="Binders.this.Scope[bt]" id="250984">newScope</a> = <span title="Binders.this.Scope[bt]" class="keyword">new</span> <a href="#250104" title="Binders.this.Scope[bt]">Scope</a>[bt]()
        <span class="keyword">for</span>(<a title="bt" id="250997">b</a> &lt;- <a href="../../../collection/generic/IterableTemplate.scala.html#17287" title="(f: (bt) =&gt; Unit)Unit">scope</a>) <a href="#250984" title="Binders.this.Scope[bt]">newScope</a>.<a href="#250161" title="(b: bt)Unit">addBinder</a>(<a href="#249773" title="(x: bt)(implicit evidence$1: (bt) =&gt; Binders.this.Mappable[bt])bt">f</a><a href="#250222" title="(bt) =&gt; Binders.this.Mappable[bt]">(</a><a href="#250997" title="bt">b</a>))
        <a href="#250984" title="Binders.this.Scope[bt]">newScope</a>
      }
    }  
  
  <span class="keyword">implicit</span> <span class="keyword">def</span> <a title="implicit scala.util.parsing.ast.Binders.NameElementIsMappable : (self: Binders.this.NameElement)Binders.this.Mappable[Binders.this.NameElement]" id="250124">NameElementIsMappable</a>(<a title="Binders.this.NameElement" id="250226">self</a>: <a href="AbstractSyntax.scala.html#157277" title="Binders.this.NameElement">NameElement</a>): <a href="#249757" title="Binders.this.Mappable[Binders.this.NameElement]">Mappable</a>[NameElement] = <a href="#251039" title="java.lang.Object with Binders.this.Mappable[Binders.this.NameElement]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Binders.this.Mappable[Binders.this.NameElement]" id="251039">Mappable</a>[NameElement] {
    <span class="keyword">def</span> <a title="(f: Binders.this.Mapper)Binders.this.NameElement" id="251041">gmap</a>(<a title="Binders.this.Mapper" id="251046">f</a>: <a href="#249756" title="Binders.this.Mapper">Mapper</a>): <a href="AbstractSyntax.scala.html#157277" title="Binders.this.NameElement">NameElement</a> = <a href="#250226" title="Binders.this.NameElement">self</a> <span title="Binders.this.NameElement" class="keyword">match</span> {
      <span title="Binders.this.BoundElement[Binders.this.NameElement]" class="keyword">case</span> BoundElement(<a title="Binders.this.NameElement" id="251051">el</a>, <a title="Binders.this.Scope[Binders.this.NameElement]" id="251052">scope</a>) =&gt; <a href="#250730" title="(el: Binders.this.NameElement,scope: Binders.this.Scope[Binders.this.NameElement])Binders.this.BoundElement[Binders.this.NameElement]">BoundElement</a>(<a href="#249773" title="(x: Binders.this.NameElement)(implicit evidence$1: (Binders.this.NameElement) =&gt; Binders.this.Mappable[Binders.this.NameElement])Binders.this.NameElement">f</a><a href="#250124" title="implicit scala.util.parsing.ast.Binders.NameElementIsMappable : (self: Binders.this.NameElement)Binders.this.Mappable[Binders.this.NameElement]">(</a><a href="#251051" title="Binders.this.NameElement">el</a>), <a href="#249773" title="(x: Binders.this.Scope[Binders.this.NameElement])(implicit evidence$1: (Binders.this.Scope[Binders.this.NameElement]) =&gt; Binders.this.Mappable[Binders.this.Scope[Binders.this.NameElement]])Binders.this.Scope[Binders.this.NameElement]">f</a><a href="#250222" title="(scope: Binders.this.Scope[Binders.this.NameElement])(implicit evidence$10: (Binders.this.NameElement) =&gt; Binders.this.Mappable[Binders.this.NameElement])Binders.this.Mappable[Binders.this.Scope[Binders.this.NameElement]]">(</a><a href="#251052" title="Binders.this.Scope[Binders.this.NameElement]">scope</a>))
      <span title="Binders.this.NameElement" class="keyword">case</span> _ =&gt; <a href="#250125" title="(self: Binders.this.NameElement)Binders.this.Mappable[Binders.this.NameElement]">UserNameElementIsMappable</a>(<a href="#250226" title="Binders.this.NameElement">self</a>).<a href="#249777" title="(f: Binders.this.Mapper)Binders.this.NameElement">gmap</a>(<a href="#251046" title="Binders.this.Mapper">f</a>)
    }
  }
  
  <span class="keyword">def</span> <a title="[t &lt;: Binders.this.NameElement](self: t)Binders.this.Mappable[t]" id="250125">UserNameElementIsMappable</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250127">t</a> &lt;: NameElement](<a title="t" id="251152">self</a>: <a href="#250127" title="t">t</a>): <a href="#249757" title="Binders.this.Mappable[t]">Mappable</a>[t]  

  <span class="keyword">object</span> <a title="object Binders.this.UnderBinder" id="250128">UnderBinder</a> <a href="../../../ScalaObject.scala.html#957" title="ScalaObject">{</a>
    <span class="keyword">def</span> <a title="[binderType &lt;: Binders.this.NameElement, elementT](scope: Binders.this.Scope[binderType],element: elementT)(implicit evidence$11: (elementT) =&gt; Binders.this.Mappable[elementT])Binders.this.UnderBinder[binderType,elementT]" id="250801">apply</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250792">binderType</a> &lt;: NameElement, <a title="&gt;: Nothing &lt;: Any" id="250793">elementT</a> &lt;% Mappable[elementT]](<a title="Binders.this.Scope[binderType]" id="250799">scope</a>: <a href="#250104" title="Binders.this.Scope[binderType]">Scope</a>[binderType], <a title="elementT" id="250800">element</a>: <a href="#250793" title="elementT">elementT</a>) = <a href="#250801" title="Binders.this.UnderBinder[binderType,elementT]" class="keyword">new</a> <a href="#250113" title="Binders.this.UnderBinder[binderType,elementT]">UnderBinder</a>(<a href="#250799" title="Binders.this.Scope[binderType]">scope</a>, <a href="#250800" title="elementT">element</a>) 
    <span class="keyword">def</span> <a title="[bt &lt;: Binders.this.NameElement, elementT](x: elementT)(implicit evidence$12: (elementT) =&gt; Binders.this.Mappable[elementT])Binders.this.UnderBinder[bt,elementT]" id="251169">unit</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250797">bt</a> &lt;: NameElement, <a title="&gt;: Nothing &lt;: Any" id="250798">elementT</a> &lt;% Mappable[elementT]](<a title="elementT" id="251168">x</a>: <a href="#250798" title="elementT">elementT</a>) = <a href="#250801" title="(scope: Binders.this.Scope[bt],element: elementT)(implicit evidence$11: (elementT) =&gt; Binders.this.Mappable[elementT])Binders.this.UnderBinder[bt,elementT]">UnderBinder</a><a href="#251169" title="(elementT) =&gt; Binders.this.Mappable[elementT]">(</a><span title="Binders.this.Scope[bt]" class="keyword">new</span> <a href="#250104" title="Binders.this.Scope[bt]">Scope</a>[bt](), <a href="#251168" title="elementT">x</a>)
  }
  
  /** If a list of `UnderBinder's all have the same scope, they can be turned in to an UnderBinder 
   * containing a list of the elements in the original `UnderBinder'.
   *
   * The name `sequence' comes from the fact that this method's type is equal to the type of monadic sequence.
   *
   * @pre !orig.isEmpty implies orig.forall(ub =&gt; ub.scope eq orig(0).scope)
   * 
   */
  <span class="keyword">def</span> <a title="[bt &lt;: Binders.this.NameElement, st](orig: List[Binders.this.UnderBinder[bt,st]])(implicit evidence$13: (st) =&gt; Binders.this.Mappable[st])Binders.this.UnderBinder[bt,List[st]]" id="251212">sequence</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250133">bt</a> &lt;: NameElement, <a title="&gt;: Nothing &lt;: Any" id="250134">st</a> &lt;% Mappable[st]](<a title="List[Binders.this.UnderBinder[bt,st]]" id="251211">orig</a>: <a href="../../../collection/immutable/List.scala.html#8973" title="List[Binders.this.UnderBinder[bt,st]]">List</a>[UnderBinder[bt, st]]): <a href="#250113" title="Binders.this.UnderBinder[bt,List[st]]">UnderBinder</a>[bt, List[st]] = 
    <span title="Binders.this.UnderBinder[bt,List[st]]" class="keyword">if</span>(<a href="#251211" title="List[Binders.this.UnderBinder[bt,st]]">orig</a>.<a href="../../../collection/generic/IterableTemplate.scala.html#17290" title="=&gt; Boolean">isEmpty</a>) <a href="#250128" title="object Binders.this.UnderBinder">UnderBinder</a>.<a href="#251169" title="(x: List[st])(implicit evidence$12: (List[st]) =&gt; Binders.this.Mappable[List[st]])Binders.this.UnderBinder[bt,List[st]]">unit</a><a href="#249827" title="(xs: List[st])(implicit evidence$3: (st) =&gt; Binders.this.Mappable[st])Binders.this.Mappable[List[st]]">(</a><a href="../../../collection/immutable/List.scala.html#9259" title="object Nil">Nil</a>) 
    <span class="keyword">else</span> <a href="#250801" title="(scope: Binders.this.Scope[bt],element: List[st])(implicit evidence$11: (List[st]) =&gt; Binders.this.Mappable[List[st]])Binders.this.UnderBinder[bt,List[st]]">UnderBinder</a><a href="#249827" title="(xs: List[st])(implicit evidence$3: (st) =&gt; Binders.this.Mappable[st])Binders.this.Mappable[List[st]]">(</a><a href="../../../collection/generic/LinearSequenceTemplate.scala.html#19400" title="(n: Int)Binders.this.UnderBinder[bt,st]">orig</a>(<span title="Int(0)" class="int">0</span>).<a href="#250604" title="=&gt; Binders.this.Scope[bt]">scope</a>, <a href="#251211" title="List[Binders.this.UnderBinder[bt,st]]">orig</a>.<a href="../../../collection/generic/TraversableTemplate.scala.html#17161" title="(f: (Binders.this.UnderBinder[bt,st]) =&gt; st)(implicit bf: scala.collection.generic.BuilderFactory[st,List[st],List[Binders.this.UnderBinder[bt,st]]])List[st]">map</a><a href="../../../collection/immutable/List.scala.html#17526" title="scala.collection.generic.BuilderFactory[st,List[st],List#Coll]">(</a><a href="#251308" title="Binders.this.UnderBinder[bt,st]">_</a>.<a href="#250605" title="=&gt; st">element</a>))

  // couldn't come up with a better name...
  <span class="keyword">def</span> <a title="[bt &lt;: Binders.this.NameElement, st](orig: Binders.this.UnderBinder[bt,List[st]])(implicit evidence$14: (st) =&gt; Binders.this.Mappable[st])List[Binders.this.UnderBinder[bt,st]]" id="251395">unsequence</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="250138">bt</a> &lt;: NameElement, <a title="&gt;: Nothing &lt;: Any" id="250139">st</a> &lt;% Mappable[st]](<a title="Binders.this.UnderBinder[bt,List[st]]" id="251394">orig</a>: <a href="#250113" title="Binders.this.UnderBinder[bt,List[st]]">UnderBinder</a>[bt, List[st]]): <a href="../../../collection/immutable/List.scala.html#8973" title="List[Binders.this.UnderBinder[bt,st]]">List</a>[UnderBinder[bt, st]] = 
    <a href="#251394" title="Binders.this.UnderBinder[bt,List[st]]">orig</a>.<a href="#250605" title="=&gt; List[st]">element</a>.<a href="../../../collection/generic/TraversableTemplate.scala.html#17161" title="(f: (st) =&gt; Binders.this.UnderBinder[bt,st])(implicit bf: scala.collection.generic.BuilderFactory[Binders.this.UnderBinder[bt,st],List[Binders.this.UnderBinder[bt,st]],List[st]])List[Binders.this.UnderBinder[bt,st]]">map</a><a href="../../../collection/immutable/List.scala.html#17526" title="scala.collection.generic.BuilderFactory[Binders.this.UnderBinder[bt,st],List[Binders.this.UnderBinder[bt,st]],List#Coll]">(</a><a title="st" id="251412">sc</a> =&gt; <a href="#250801" title="(scope: Binders.this.Scope[bt],element: st)(implicit evidence$11: (st) =&gt; Binders.this.Mappable[st])Binders.this.UnderBinder[bt,st]">UnderBinder</a><a href="#251395" title="(st) =&gt; Binders.this.Mappable[st]">(</a><a href="#251394" title="Binders.this.UnderBinder[bt,List[st]]">orig</a>.<a href="#250604" title="=&gt; Binders.this.Scope[bt]">scope</a>, <a href="#251412" title="st">sc</a>))

  /** An environment that maps a `NameElement' to the scope in which it is bound.
   * This can be used to model scoping during parsing.
   *
   * (This class is similar to Burak's ECOOP paper on pattern matching, except that we use `=='
   *  instead of `eq', thus types can't be unified in general)
   *
   * TODO: more documentation
   */
  <span class="keyword">abstract</span> <span class="keyword">class</span> <a title="class BinderEnv extends java.lang.Object with ScalaObject" id="250140">BinderEnv</a> <a href="../../../ScalaObject.scala.html#957" title="ScalaObject">{</a>
    <span class="keyword">def</span> <a title="[A &lt;: Binders.this.NameElement](v: A)Option[Binders.this.Scope[A]]" id="251474">apply</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="251476">A</a> &lt;: NameElement](<a title="A" id="251483">v</a>: <a href="#251476" title="A">A</a>): <a href="../../../Option.scala.html#777" title="Option[Binders.this.Scope[A]]">Option</a>[Scope[A]]
    <span class="keyword">def</span> <a title="[a &lt;: Binders.this.NameElement](v: a,x: Binders.this.Scope[a])Binders.this.BinderEnv" id="251477">extend</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="251479">a</a> &lt;: NameElement](<a title="a" id="251486">v</a> : <a href="#251479" title="a">a</a>, <a title="Binders.this.Scope[a]" id="251487">x</a> : <a href="#250104" title="Binders.this.Scope[a]">Scope</a>[a]) = <a href="#251490" title="Binders.this.BinderEnv{ ... }" class="keyword">new</a> <a href="#250140" title="anonymous class $anon extends Binders.this.BinderEnv" id="251490">BinderEnv</a> { 
      <span class="keyword">def</span> <a title="[b &lt;: Binders.this.NameElement](w: b)Option[Binders.this.Scope[b]]" id="251492">apply</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="251494">b</a> &lt;: NameElement](<a title="b" id="251498">w</a> : <a href="#251494" title="b">b</a>): <a href="../../../Option.scala.html#777" title="Option[Binders.this.Scope[b]]">Option</a>[Scope[b]] =  
        <span title="Option[Binders.this.Scope[b]]" class="keyword">if</span>(<a href="#251498" title="(x$1: AnyRef)Boolean">w</a> == <a href="#251486" title="a">v</a>) <a href="../../../Option.scala.html#19800" title="(x: Binders.this.Scope[b])Some[Binders.this.Scope[b]]">Some</a>(<a href="#251487" title="Binders.this.Scope[a]">x</a>.<span title="[T0]T0">asInstanceOf</span><span title="Binders.this.Scope[b]">[</span><a href="#250104" title="Binders.this.Scope[b]">Scope</a>[b]]) 
        <span class="keyword">else</span> <a href="#250140" title="BinderEnv.this.type">BinderEnv</a>.<span class="keyword">this</span>.<a href="#251474" title="(v: b)Option[Binders.this.Scope[b]]">apply</a>(<a href="#251498" title="b">w</a>) 
    }
  }

  <span class="keyword">object</span> <a title="object Binders.this.EmptyBinderEnv" id="250141">EmptyBinderEnv</a> <a href="../../../ScalaObject.scala.html#957" title="ScalaObject" class="keyword">extends</a> <a href="#250140" title="Binders.this.BinderEnv">BinderEnv</a> {
    <span class="keyword">def</span> <a title="[A &lt;: Binders.this.NameElement](v: A)Option[Binders.this.Scope[A]]" id="251536">apply</a>[<a title="&gt;: Nothing &lt;: Binders.this.NameElement" id="251538">A</a> &lt;: NameElement](<a title="A" id="251542">v</a>: <a href="#251538" title="A">A</a>): <a href="../../../Option.scala.html#777" title="Option[Binders.this.Scope[A]]">Option</a>[Scope[A]] = <a href="../../../Option.scala.html#463" title="object None">None</a>
  }

  /** Returns a given result, but executes the supplied closure before returning.
   * (The effect of this closure does not influence the returned value.)
   *
   * TODO: move this to some utility object higher in the scala hierarchy?
   *
   * @param result the result to be returned
   * @param block  code to be executed, purely for its side-effects
   */
  <span class="keyword">trait</span> <a title="trait ReturnAndDo[T] extends java.lang.Object" id="250143">ReturnAndDo</a>[<a title="&gt;: Nothing &lt;: Any" id="250144">T</a>]<span title="java.lang.Object">{</span>
    <span class="keyword">def</span> <a title="(block: =&gt; Unit)T" id="250192">andDo</a>(<a title="=&gt; Unit" id="250193">block</a>: =&gt; Unit): <a href="#250144" title="T">T</a>
  } // gotta love Smalltalk syntax :-)

  <span class="keyword">def</span> <a title="[T](result: T)Binders.this.ReturnAndDo[T]" id="250145">return_</a>[<a title="&gt;: Nothing &lt;: Any" id="250147">T</a>](<a title="T" id="250184">result</a>: <a href="#250147" title="T">T</a>): <a href="#250143" title="Binders.this.ReturnAndDo[T]">ReturnAndDo</a>[T] =
    <a href="#251548" title="java.lang.Object with Binders.this.ReturnAndDo[T]{ ... }" class="keyword">new</a> <a title="anonymous class $anon extends java.lang.Object with Binders.this.ReturnAndDo[T]" id="251548">ReturnAndDo</a>[T] {
      <span class="keyword">val</span> <a title="T" id="251550">r</a> = <a href="#250184" title="T">result</a>
      <span class="keyword">def</span> <a title="(block: =&gt; Unit)T" id="251552">andDo</a>(<a title="=&gt; Unit" id="251557">block</a>: =&gt; Unit): <a href="#250147" title="T">T</a> = {<a href="#251557" title="=&gt; Unit">block</a>; <a href="#251550" title="=&gt; T">r</a>}
    }

  <span class="keyword">private</span> <span class="keyword">object</span> <a title="object Binders.this._Binder" id="250148">_Binder</a> <a href="../../../ScalaObject.scala.html#957" title="ScalaObject">{</a>
    <span class="keyword">private</span> <span class="keyword">var</span> <a title="Int" id="250178">currentId</a> = <span title="Int(0)" class="int">0</span>
    <span class="keyword">private</span>[Binders] <span class="keyword">def</span> <a title="=&gt; Int" id="250180">genId</a> = <a href="#250145" title="(result: Int)Binders.this.ReturnAndDo[Int]">return_</a><a href="#250192" title="(block: =&gt; Unit)Int">(</a><a href="#250178" title="=&gt; Int">currentId</a>) andDo {<a href="#250178" title="(x$1: Int)Unit">currentId</a>=<a href="#250178" title="(x$1: Int)Int">currentId</a>+<span title="Int(1)" class="int">1</span>}
  }
}

        </pre>
    </body>
</html>