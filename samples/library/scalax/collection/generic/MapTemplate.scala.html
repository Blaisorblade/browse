<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scalax/collection/generic/MapTemplate.scala</title>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: Map.scala 16884 2009-01-09 16:52:09Z cunei $</span>


<span class="keyword">package</span> scalax.collection.generic

<span class="keyword">import</span> collection.immutable.Set
<span class="keyword">import</span> collection.mutable.ArrayBuffer
<span class="keyword">import</span> annotation.unchecked.uncheckedVariance

<span class="comment">/** &lt;p&gt;
*     A map is a collection that maps each key to one or zero values.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    This trait provides a limited interface, only allowing reading of elements.
 *    There are two extensions of this trait, in packages
 *    &lt;code&gt;&lt;a href=&quot;mutable$content.html&quot; target=&quot;contentFrame&quot;&gt;
 *    scala.collection.mutable&lt;/a&gt;&lt;/code&gt;
 *    and &lt;code&gt;&lt;a href=&quot;immutable$content.html&quot; target=&quot;contentFrame&quot;&gt;
 *    scala.collection.immutable&lt;/a&gt;&lt;/code&gt;, which provide functionality for
 *    adding new key/value mappings to a map. The trait in the first package is
 *    for maps that are modified destructively, whereas the trait in
 *    the second package is for immutable maps which create a new map
 *    when something is added or removed from them.
 *  &lt;/p&gt;
 *
 *  @author  Matthias Zenger
 *  @author  Martin Odersky
 *  @version 1.2, 31/12/2006
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait MapTemplate[A, B, +CC[A1,B1] &lt;: scalax.collection.Map[A1,B1] with scalax.collection.generic.MapTemplate[A1,B1,CC]] extends java.lang.Object with PartialFunction[A,B] with scalax.collection.SizedIterable[(A, B)] with scalax.collection.generic.Addable[CC[A,B],(A, B)] with scalax.collection.generic.Subtractable[CC[A,B],A] with ScalaObject</span><a id="10383">MapTemplate</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="15084">A</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="15085">B</a></span>, +<span class="typed"><span class="type">[A1, B1]&gt;: Nothing &lt;: scalax.collection.Map[A1,B1] with scalax.collection.generic.MapTemplate[A1,B1,CC]</span><a id="15086">CC</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20127">A1</a></span>, <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20128">B1</a></span>] &lt;: Map[A1, B1] <span class="keyword">with</span> MapTemplate[A1, B1, CC]]
  <span class="keyword">extends</span> <span class="typed"><span class="type">PartialFunction[A,B]</span><a href="../../../scala/PartialFunction.scala.html#1295">PartialFunction</a></span>[A, B] 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.SizedIterable[(A, B)]</span><a href="../SizedIterable.scala.html#6380">SizedIterable</a></span>[(A, B)] 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.generic.Addable[CC[A,B],(A, B)]</span><a href="Addable.scala.html#10569">Addable</a></span>[CC[A, B], (A, B)] 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.generic.Subtractable[CC[A,B],A]</span><a href="Subtractable.scala.html#10494">Subtractable</a></span>[CC[A, B], A] { 
self: CC[A, B] =&gt;

  <span class="keyword">def</span> <span class="typed"><span class="type">[B]scalax.collection.generic.Builder[scalax.collection.SizedIterable,B]</span><a id="20093">newBuilder</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20095">B</a></span>]: <span class="typed"><span class="type">scalax.collection.generic.Builder[scalax.collection.SizedIterable,B]</span><a href="Builder.scala.html#10377">Builder</a></span>[SizedIterable, B] = <span class="typed"><span class="type">()scalax.collection.mutable.ArrayBuffer[B]</span><a href="../mutable/ArrayBuffer.scala.html#17878" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.mutable.ArrayBuffer[B]</span><a href="../mutable/ArrayBuffer.scala.html#6506">ArrayBuffer</a></span>[B]

  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; CC[A,B]</span><a id="20096">thisCC</a></span>: <span class="typed"><span class="type">CC[A,B]</span><a href="#15086">CC</a></span>[A, B] = <span class="typed"><span class="type">CC[A,B]</span><a href="#10383" class="keyword">this</a></span>

  <span class="comment">/** This method returns a new map instance of the same class
   *  mapping keys of the same type to values of type &lt;code&gt;C&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[C]CC[A,C]</span><a id="20097">empty</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20099">C</a></span>]: <span class="typed"><span class="type">CC[A,C]</span><a href="#15086">CC</a></span>[A, C]

  <span class="comment">/** Compute the number of key-to-value mappings.
   *
   *  @return the number of mappings
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="20100">size</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>

  <span class="comment">/** Check if this map maps &lt;code&gt;key&lt;/code&gt; to a value and return the
   *  value if it exists.
   *
   *  @param  key the key of the mapping of interest
   *  @return     the value of the mapping, if it exists
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)Option[B]</span><a id="20101">get</a></span>(<span class="typed"><span class="type">A</span><a id="20203">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">Option[B]</span><a href="../../../scala/Option.scala.html#932">Option</a></span>[B]
    
  <span class="comment">/** Check if this map maps &lt;code&gt;key&lt;/code&gt; to a value.
    *  Return that value if it exists, otherwise return &lt;code&gt;default&lt;/code&gt;.
    */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B2 &gt;: B](A,=&gt; B2)B2</span><a id="20102">getOrElse</a></span>[<span class="typed"><span class="type">&gt;: B &lt;: Any</span><a id="20104">B2</a></span> &gt;: B](<span class="typed"><span class="type">A</span><a id="80049">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>, <span class="typed"><span class="type">=&gt; B2</span><a id="80050">default</a></span>: =&gt; B2): <span class="typed"><span class="type">B2</span><a href="#20104">B2</a></span> =
    <span class="typed"><span class="type">(A)Option[B]</span><a href="#20101">get</a></span>(<span class="typed"><span class="type">A</span><a href="#80049">key</a></span>) <span class="typed"><span class="type">B2</span><span class="keyword">match</span></span> {
      <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <a id="1">Some</a>(<span class="typed"><span class="type">B</span><a id="80063">v</a></span>) =&gt; <span class="typed"><span class="type">B</span><a href="#80063">v</a></span>
      <span class="typed"><span class="type">B2</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object None</span><a href="../../../scala/Option.scala.html#534">None</a></span> =&gt; <span class="typed"><span class="type">=&gt; B2</span><a href="#80050">default</a></span> 
    }

  <span class="comment">/** Is this an empty map?
   *
   *  @return &lt;code&gt;true&lt;/code&gt; iff the map is empty.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="20105">isEmpty</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">=&gt; Int</span><a href="#20100">size</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>

  <span class="comment">/** Retrieve the value which is associated with the given key. This
   *  method throws an exception if there is no mapping from the given
   *  key to a value.
   *
   *  @param  key the key
   *  @return     the value associated with the given key.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)B</span><a id="20106">apply</a></span>(<span class="typed"><span class="type">A</span><a id="76629">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">B</span><a href="#15085">B</a></span> = <span class="typed"><span class="type">(A)Option[B]</span><a href="#20101">get</a></span>(<span class="typed"><span class="type">A</span><a href="#76629">key</a></span>) <span class="typed"><span class="type">B</span><span class="keyword">match</span></span> {
    <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object None</span><a href="../../../scala/Option.scala.html#534">None</a></span> =&gt; <span class="typed"><span class="type">(A)B</span><a href="#20113">default</a></span>(<span class="typed"><span class="type">A</span><a href="#76629">key</a></span>)
    <span class="typed"><span class="type">B</span><span class="keyword">case</span></span> <a id="1">Some</a>(<span class="typed"><span class="type">B</span><a id="80088">value</a></span>) =&gt; <span class="typed"><span class="type">B</span><a href="#80088">value</a></span>
  }

  <span class="comment">/** Is the given key mapped to a value by this map?
   *
   *  @param key the key
   *  @return    &lt;code&gt;true&lt;/code&gt; iff there is a mapping for key in this map
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="20107">contains</a></span>(<span class="typed"><span class="type">A</span><a id="76620">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">(A)Option[B]</span><a href="#20101">get</a></span>(<span class="typed"><span class="type">A</span><a href="#76620">key</a></span>) <span class="typed"><span class="type">Boolean</span><span class="keyword">match</span></span> {
    <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">case</span></span> <span class="typed"><span class="type">object None</span><a href="../../../scala/Option.scala.html#534">None</a></span> =&gt; <span class="typed"><span class="type">Boolean(false)</span><span class="keyword">false</span></span>
    <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">case</span></span> <a id="1">Some</a>(_) =&gt; <span class="typed"><span class="type">Boolean(true)</span><span class="keyword">true</span></span>
  }

  <span class="comment">/** Does this map contain a mapping from the given key to a value?
   *
   *  @param key the key
   *  @return    &lt;code&gt;true&lt;/code&gt; iff there is a mapping for key in this map
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="20108">isDefinedAt</a></span>(<span class="typed"><span class="type">A</span><a id="76611">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>) = <span class="typed"><span class="type">(A)Boolean</span><a href="#20107">contains</a></span>(<span class="typed"><span class="type">A</span><a href="#76611">key</a></span>)

  <span class="comment">/** Creates an iterator for all keys.
   *
   *  @return an iterator over all keys.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a id="20109">keys</a></span>: <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="../Iterator.scala.html#6386">Iterator</a></span>[A] = <span class="typed"><span class="type">template $anon extends java.lang.Object with scalax.collection.Iterator[A]</span><a id="80102" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="../Iterator.scala.html#6386">Iterator</a></span>[A] {
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[(A, B)]</span><span id="80107"><a id="80106">iter</a></span></span> = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="IterableTemplate.scala.html#17388">elements</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="80108">hasNext</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="#80106">iter</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../Iterator.scala.html#20216">hasNext</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">()A</span><a id="80109">next</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="#80106">iter</a></span>.<span class="typed"><span class="type">()(A, B)</span><a href="../Iterator.scala.html#20217">next</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="../../../scala/Tuple2.scala.html#19161">_1</a></span>
  }
     
  <span class="comment">/** @return the keys of this map as a set. 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.immutable.Set[A]</span><a id="20110">keySet</a></span>: <span class="typed"><span class="type">scalax.collection.immutable.Set[A]</span><a href="../immutable/Set.scala.html#7493">Set</a></span>[A] = <span class="typed"><span class="type">template $anon extends java.lang.Object with scalax.collection.immutable.Set[A]</span><a id="80135" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.immutable.Set[A]</span><a href="../immutable/Set.scala.html#7493">Set</a></span>[A] {
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="80139">size</a></span> = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="#20100">size</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="80140">contains</a></span>(<span class="typed"><span class="type">A</span><a id="80171">key</a></span> : <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>) = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">(A)Boolean</span><a href="#20107">contains</a></span>(<span class="typed"><span class="type">A</span><a href="#80171">key</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a id="80141">elements</a></span> = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="IterableTemplate.scala.html#17388">elements</a></span>.<span class="typed"><span class="type">(((A, B)) =&gt; A)scalax.collection.Iterator[A]</span><a href="../Iterator.scala.html#20221">map</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#80185">_</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="../../../scala/Tuple2.scala.html#19161">_1</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">(A)scalax.collection.immutable.Set[A]</span><a id="80142">+</a></span> (<span class="typed"><span class="type">A</span><a id="80186">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">scalax.collection.immutable.Set[A]</span><a href="../immutable/Set.scala.html#7493">Set</a></span>[A] = immutable.<span class="typed"><span class="type">(A*)scalax.collection.immutable.Set[A]</span><a href="SetFactory.scala.html#23812">Set</a></span>[<span class="typed"><span class="type">A</span><a href="#15084">A</a></span>]() <span class="typed"><span class="type">(scalax.collection.Iterable[A])scalax.collection.immutable.Set[A]</span><a href="Addable.scala.html#17901">++</a></span> <span class="typed"><span class="type">java.lang.Object with scalax.collection.immutable.Set[A]{ ... }</span><a href="#80135" class="keyword">this</a></span> <span class="typed"><span class="type">(A)scalax.collection.immutable.Set[A]</span><a href="SetTemplate.scala.html#23831">+</a></span> <span class="typed"><span class="type">A</span><a href="#80186">elem</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(A)scalax.collection.immutable.Set[A]</span><a id="80143">-</a></span> (<span class="typed"><span class="type">A</span><a id="80224">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">scalax.collection.immutable.Set[A]</span><a href="../immutable/Set.scala.html#7493">Set</a></span>[A] = immutable.<span class="typed"><span class="type">(A*)scalax.collection.immutable.Set[A]</span><a href="SetFactory.scala.html#23812">Set</a></span>[<span class="typed"><span class="type">A</span><a href="#15084">A</a></span>]() <span class="typed"><span class="type">(scalax.collection.Iterable[A])scalax.collection.immutable.Set[A]</span><a href="Addable.scala.html#17901">++</a></span> <span class="typed"><span class="type">java.lang.Object with scalax.collection.immutable.Set[A]{ ... }</span><a href="#80135" class="keyword">this</a></span> <span class="typed"><span class="type">(A)scalax.collection.immutable.Set[A]</span><a href="SetTemplate.scala.html#23832">-</a></span> <span class="typed"><span class="type">A</span><a href="#80224">elem</a></span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">[B]scalax.collection.generic.Builder[scalax.collection.immutable.Set,B]</span><a id="80144">newBuilder</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="80146">B</a></span>]: <span class="typed"><span class="type">scalax.collection.generic.Builder[scalax.collection.immutable.Set,B]</span><a href="Builder.scala.html#10377">Builder</a></span>[Set, B] = <span class="typed"><span class="type">object scalax.collection.immutable.Set</span><a href="../immutable/Set.scala.html#7494">Set</a></span>.<span class="typed"><span class="type">scalax.collection.generic.Builder[scalax.collection.immutable.Set,B]</span><a href="SetFactory.scala.html#23815">newBuilder</a></span>[<span class="typed"><span class="type">B</span><a href="#80146">B</a></span>]
  }

  <span class="comment">/** Creates an iterator for a contained values.
   *
   *  @return an iterator over all values.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[B]</span><a id="20111">values</a></span>: <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="../Iterator.scala.html#6386">Iterator</a></span>[B] = <span class="typed"><span class="type">template $anon extends java.lang.Object with scalax.collection.Iterator[B]</span><a id="80268" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="../Iterator.scala.html#6386">Iterator</a></span>[B] {
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[(A, B)]</span><span id="80273"><a id="80272">iter</a></span></span> = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="IterableTemplate.scala.html#17388">elements</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="80274">hasNext</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="#80272">iter</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../Iterator.scala.html#20216">hasNext</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">()B</span><a id="80275">next</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="#80272">iter</a></span>.<span class="typed"><span class="type">()(A, B)</span><a href="../Iterator.scala.html#20217">next</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="../../../scala/Tuple2.scala.html#19163">_2</a></span>
  }

  <span class="comment">/** Creates a string representation for this map.
   *
   *  @return    a string showing all mappings
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()String</span><a id="20112">toString</a></span>() =
    <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="IterableTemplate.scala.html#17388">elements</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.immutable.List[(A, B)]</span><a href="../Iterator.scala.html#20304">toList</a></span>.<span class="typed"><span class="type">(((A, B)) =&gt; java.lang.String)scalax.collection.immutable.List[java.lang.String]</span><a href="../immutable/List.scala.html#38974">map</a></span>(<span class="typed"><span class="type">(A, B)</span><a id="76523">kv</a></span> =&gt; <span class="typed"><span class="type">(A, B)</span><a href="#76523">kv</a></span>.<span class="typed"><span class="type">implicit scala.Predef.any2stringadd : (Any)scala.runtime.StringAdd</span><a href="../../../scala/Predef.scala.html#13520">_1</a></span> <span class="typed"><span class="type">(String)java.lang.String</span><a href="../../../scala/runtime/StringAdd.scala.html#19198">+</a></span> <span class="typed"><span class="type">java.lang.String(&quot; -&gt; &quot;)</span><span class="string">&quot; -&gt; &quot;</span></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">(A, B)</span><a href="#76523">kv</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="../../../scala/Tuple2.scala.html#19163">_2</a></span>).<span class="typed"><span class="type">(String,String,String)String</span><a href="IterableTemplate.scala.html#17462">mkString</a></span>(<span class="typed"><span class="type">=&gt; String</span><a href="#20118">stringPrefix</a></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">java.lang.String(&quot;(&quot;)</span><span class="string">&quot;(&quot;</span></span>, <span class="typed"><span class="type">java.lang.String(&quot;, &quot;)</span><span class="string">&quot;, &quot;</span></span>, <span class="typed"><span class="type">java.lang.String(&quot;)&quot;)</span><span class="string">&quot;)&quot;</span></span>)
    
  <span class="comment">/** The default value for the map, returned when a key is not found
   *  The method implemented here yields an error,
   *  but it might be overridden in subclasses.
   *
   *  @param key the given key value
   *  @throws Predef.NoSuchElementException
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)B</span><a id="20113">default</a></span>(<span class="typed"><span class="type">A</span><a id="80080">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">B</span><a href="#15085">B</a></span> =
    <span class="typed"><span class="type">Nothing</span><span class="keyword">throw</span></span> <span class="typed"><span class="type">(java.lang.String)java.util.NoSuchElementException</span><a id="25317" class="keyword">new</a></span> <span class="typed"><span class="type">java.util.NoSuchElementException</span><a href="../../../scala/Predef.scala.html#13342">NoSuchElementException</a></span>(<span class="typed"><span class="type">java.lang.String(&quot;key not found: &quot;)</span><span class="string">&quot;key not found: &quot;</span></span> <span class="typed"><span class="type">(Any)java.lang.String</span><a id="5800">+</a></span> <span class="typed"><span class="type">A</span><a href="#80080">key</a></span>)
    
<span class="comment">/*
  override def view: Map.View[A,B] = new Map.View[A, B] {
    override def elements = self.elements
    override def size = self.size
    override def get(key: A): Option[B] = self.get(key)
  }
*/</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)java.lang.Object with scalax.collection.generic.MapView[CC,A,B]{def origin: CC[A,B]}</span><a id="20114">filterKeys</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="80289">p</a></span>: A =&gt; Boolean) = <span class="typed"><span class="type">template $anon extends java.lang.Object with scalax.collection.generic.MapView[CC,A,B]</span><a id="80291" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.generic.MapView[CC,A,B]</span><a href="MapView.scala.html#10593">MapView</a></span>[CC, A, B] {
    <span class="keyword">val</span> <span class="typed"><span class="type">CC[A,B]</span><span id="80302"><a id="80301">origin</a></span></span> = <span class="typed"><span class="type">CC[A,B]</span><a href="#10383">self</a></span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a id="80303">foreach</a></span>(<span class="typed"><span class="type">((A, B)) =&gt; Unit</span><a id="80317">f</a></span>: ((A, B)) =&gt; Unit): <span class="typed"><span class="type">Unit</span><a id="2167">Unit</a></span> = <span class="keyword">for</span> (<span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#17412" id="80340">kv</a></span> &lt;- <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>) <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">(A)Boolean</span><a href="../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#80340">kv</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="../../../scala/Tuple2.scala.html#19161">_1</a></span>)) <span class="typed"><span class="type">((A, B))Unit</span><a href="../../../scala/Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#80340">kv</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a id="80304">elements</a></span> = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="IterableTemplate.scala.html#17388">elements</a></span>.<span class="typed"><span class="type">(((A, B)) =&gt; Boolean)scalax.collection.Iterator[(A, B)]</span><a href="../Iterator.scala.html#20233">filter</a></span>(<span class="typed"><span class="type">(A, B)</span><a id="80354">kv</a></span> =&gt; <span class="typed"><span class="type">(A)Boolean</span><a href="../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#80354">kv</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="../../../scala/Tuple2.scala.html#19161">_1</a></span>))
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="80305">size</a></span> = { <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="80357">sz</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>; <span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a href="#80303">foreach</a></span>(<span class="typed"><span class="type">(A, B)</span><a id="80359">_</a></span> =&gt; <span class="typed"><span class="type">Int</span><a href="#80357">sz</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>); <span class="typed"><span class="type">Int</span><a href="#80357">sz</a></span> }
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="80306">contains</a></span>(<span class="typed"><span class="type">A</span><a id="80382">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>) = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">(A)Boolean</span><a href="#20107">contains</a></span>(<span class="typed"><span class="type">A</span><a href="#80382">key</a></span>) <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">(A)Boolean</span><a href="../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">A</span><a href="#80382">key</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">(A)Option[B]</span><a id="80307">get</a></span>(<span class="typed"><span class="type">A</span><a id="80391">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>) = <span class="typed"><span class="type">Option[B]</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">A</span><a href="#80391">key</a></span>)) <span class="typed"><span class="type">object None</span><a href="../../../scala/Option.scala.html#534">None</a></span> <span class="keyword">else</span> <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">(A)Option[B]</span><a href="#20101">get</a></span>(<span class="typed"><span class="type">A</span><a href="#80391">key</a></span>)
  }    
       
  <span class="keyword">def</span> <span class="typed"><span class="type">[C]((B) =&gt; C)java.lang.Object with scalax.collection.generic.MapView[CC,A,C]{def origin: CC[A,B]}</span><a id="20115">mapElements</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20117">C</a></span>](<span class="typed"><span class="type">(B) =&gt; C</span><a id="80432">f</a></span>: B =&gt; C) = <span class="typed"><span class="type">template $anon extends java.lang.Object with scalax.collection.generic.MapView[CC,A,C]</span><a id="80434" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.generic.MapView[CC,A,C]</span><a href="MapView.scala.html#10593">MapView</a></span>[CC, A,C] {
    <span class="keyword">val</span> <span class="typed"><span class="type">CC[A,B]</span><span id="80445"><a id="80444">origin</a></span></span> = <span class="typed"><span class="type">CC[A,B]</span><a href="#10383">self</a></span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(((A, C)) =&gt; Unit)Unit</span><a id="80446">foreach</a></span>(<span class="typed"><span class="type">((A, C)) =&gt; Unit</span><a id="80460">g</a></span>: ((A, C)) =&gt; Unit): <span class="typed"><span class="type">Unit</span><a id="2167">Unit</a></span> = <span class="keyword">for</span> (<span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#17412">(</a></span><span class="typed"><span class="type">A</span><span id="80499"><a id="80508">k</a></span></span>, <span class="typed"><span class="type">B</span><span id="80500"><a id="80509">v</a></span></span>) &lt;- <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>) <span class="typed"><span class="type">((A, C))Unit</span><a href="../../../scala/Function1.scala.html#17300">g</a></span>(<span class="typed"><span class="type">(A,C)(A, C)</span><a href="../../../scala/Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">A</span><a href="#80508">k</a></span>, <span class="typed"><span class="type">(B)C</span><a href="../../../scala/Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">B</span><a href="#80509">v</a></span>)))
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, C)]</span><a id="80447">elements</a></span> = <span class="keyword">for</span> (<span class="typed"><span class="type">(((A, B)) =&gt; (A, C))scalax.collection.Iterator[(A, C)]</span><a href="../Iterator.scala.html#20221">(</a></span><span class="typed"><span class="type">A</span><span id="80524"><a id="80529">k</a></span></span>, <span class="typed"><span class="type">B</span><span id="80525"><a id="80530">v</a></span></span>) &lt;- <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[(A, B)]</span><a href="IterableTemplate.scala.html#17388">elements</a></span>) <span class="keyword">yield</span> <span class="typed"><span class="type">(A,C)(A, C)</span><a href="../../../scala/Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">A</span><a href="#80529">k</a></span>, <span class="typed"><span class="type">(B)C</span><a href="../../../scala/Function1.scala.html#17300">f</a></span>(<span class="typed"><span class="type">B</span><a href="#80530">v</a></span>))
    <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="80448">size</a></span> = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="#20100">size</a></span>
    <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="80449">contains</a></span>(<span class="typed"><span class="type">A</span><a id="80542">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>) = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">(A)Boolean</span><a href="#20107">contains</a></span>(<span class="typed"><span class="type">A</span><a href="#80542">key</a></span>)
    <span class="keyword">def</span> <span class="typed"><span class="type">(A)Option[C]</span><a id="80450">get</a></span>(<span class="typed"><span class="type">A</span><a id="80551">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>) = <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383">self</a></span>.<span class="typed"><span class="type">(A)Option[B]</span><a href="#20101">get</a></span>(<span class="typed"><span class="type">A</span><a href="#80551">key</a></span>).<span class="typed"><span class="type">((B) =&gt; C)Option[C]</span><a href="../../../scala/Option.scala.html#18277">map</a></span>(<span class="typed"><span class="type">(B) =&gt; C</span><a href="#80432">f</a></span>)
  }

  <span class="comment">/** Defines the prefix of this object's &lt;code&gt;toString&lt;/code&gt; representation.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="20118">stringPrefix</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;Map&quot;)</span><span class="string">&quot;Map&quot;</span></span>

  <span class="comment">/** Add a key/value pair to this map. 
   *  @param    key the key
   *  @param    value the value
   *  @return   A new map with the new binding added to this map
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A,B)CC[A,B]</span><a id="20119">update</a></span> (<span class="typed"><span class="type">A</span><a id="20325">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>, <span class="typed"><span class="type">B</span><a id="20326">value</a></span>: <span class="typed"><span class="type">B</span><a href="#15085">B</a></span>): <span class="typed"><span class="type">CC[A,B]</span><a href="#15086">CC</a></span>[A, B]

  <span class="comment">/** Add a key/value pair to this map. 
   *  @param    kv the key/value pair.
   *  @return   A new map with the new binding added to this map
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A, B))CC[A,B]</span><a id="20120">+</a></span> (<span class="typed"><span class="type">(A, B)</span><a id="76495">kv</a></span>: <span class="typed"><span class="type">(A, B)</span><a href="../../../scala/Tuple2.scala.html#1376">(</a></span>A, B)): <span class="typed"><span class="type">CC[A,B]</span><a href="#15086">CC</a></span>[A, B] = <span class="typed"><span class="type">(A,B)CC[A,B]</span><a href="#20119">update</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#76495">kv</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="../../../scala/Tuple2.scala.html#19161">_1</a></span>, <span class="typed"><span class="type">(A, B)</span><a href="#76495">kv</a></span>.<span class="typed"><span class="type">=&gt; B</span><a href="../../../scala/Tuple2.scala.html#19163">_2</a></span>)

  <span class="comment">/** Remove a key from this map
   *  @param    key the key to be removed
   *  @return   If the map does not contain a binding for &lt;code&gt;key&lt;/code&gt;
   *            it is returned unchanged. Otherwise, return a new map 
   *            without a binding for &lt;code&gt;key&lt;/code&gt;
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)CC[A,B]</span><a id="20121">-</a></span> (<span class="typed"><span class="type">A</span><a id="20341">key</a></span>: <span class="typed"><span class="type">A</span><a href="#15084">A</a></span>): <span class="typed"><span class="type">CC[A,B]</span><a href="#15086">CC</a></span>[A, B]

  <span class="comment">/** This function transforms all the values of mappings contained
   *  in this map with function &lt;code&gt;f&lt;/code&gt;.
   *
   *  @param f A function over keys and values
   *  @return  the updated map
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[C]((A, B) =&gt; C)CC[A,C]</span><a id="20122">transform</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="20124">C</a></span>](<span class="typed"><span class="type">(A, B) =&gt; C</span><a id="80603">f</a></span>: (A, B) =&gt; C): <span class="typed"><span class="type">CC[A,C]</span><a href="#15086">CC</a></span>[A, C] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">CC[A,C]</span><a id="80615">res</a></span> = <span class="typed"><span class="type">CC[A,C]</span><a href="#20097">empty</a></span>[<span class="typed"><span class="type">C</span><a href="#20124">C</a></span>]
    <span class="keyword">for</span> (<span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#17412">(</a></span><span class="typed"><span class="type">A</span><span id="80648"><a id="80657">key</a></span></span>, <span class="typed"><span class="type">B</span><span id="80649"><a id="80658">value</a></span></span>) &lt;- <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383" class="keyword">this</a></span>) <span class="typed"><span class="type">CC[A,C]</span><a href="#80615">res</a></span> <span class="typed"><span class="type">((A, C))CC[A,C]</span><a href="#20120">+=</a></span> (<span class="typed"><span class="type">(A,C)(A, C)</span><a href="../../../scala/Tuple2.scala.html#20366">(</a></span><span class="typed"><span class="type">A</span><a href="#80657">key</a></span>, <span class="typed"><span class="type">(A,B)C</span><a href="../../../scala/Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">A</span><a href="#80657">key</a></span>, <span class="typed"><span class="type">B</span><a href="#80658">value</a></span>)))
    <span class="typed"><span class="type">CC[A,C]</span><a href="#80615">res</a></span>
  }

  <span class="comment">/** Builds a new map with all key/value pairs of this map
   *  for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.
   *
   *  @param p A predicate over key-value pairs
   *  @return  the updated map
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(((A, B)) =&gt; Boolean)CC[A,B]</span><a id="20125">filter</a></span>(<span class="typed"><span class="type">((A, B)) =&gt; Boolean</span><a id="76554">p</a></span>: ((A, B)) =&gt; Boolean): <span class="typed"><span class="type">CC[A,B]</span><a href="#15086">CC</a></span>[A, B] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">CC[A,B]</span><a id="80889">res</a></span> = <span class="typed"><span class="type">CC[A,B]</span><a href="#20097">empty</a></span>[<span class="typed"><span class="type">B</span><a href="#15085">B</a></span>]
    <span class="keyword">for</span> (<span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#17412" id="80905">kv</a></span> &lt;- <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383" class="keyword">this</a></span>)
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">((A, B))Boolean</span><a href="../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#80905">kv</a></span>)) <span class="typed"><span class="type">CC[A,B]</span><a href="#80889">res</a></span> <span class="typed"><span class="type">((A, B))CC[A,B]</span><a href="#20120">+=</a></span> <span class="typed"><span class="type">(A, B)</span><a href="#80905">kv</a></span>
    <span class="typed"><span class="type">CC[A,B]</span><a href="#80889">res</a></span>
  }

  <span class="comment">/** Removes all the mappings for which the predicate
   *  &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
   *
   *  @param p A predicate over key-value pairs
   *  @return  the updated map
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(((A, B)) =&gt; Boolean)CC[A,B]</span><a id="20126">remove</a></span>(<span class="typed"><span class="type">((A, B)) =&gt; Boolean</span><a id="76541">p</a></span>: ((A, B)) =&gt; Boolean): <span class="typed"><span class="type">CC[A,B]</span><a href="#15086">CC</a></span>[A, B] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">CC[A,B]</span><a id="81131">res</a></span> = <span class="typed"><span class="type">CC[A,B]</span><a href="#10383" class="keyword">this</a></span>
    <span class="keyword">for</span> (<span class="typed"><span class="type">(((A, B)) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#17412" id="81139">kv</a></span> &lt;- <span class="typed"><span class="type">MapTemplate.this.type</span><a href="#10383" class="keyword">this</a></span>)
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">((A, B))Boolean</span><a href="../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">(A, B)</span><a href="#81139">kv</a></span>)) <span class="typed"><span class="type">CC[A,B]</span><a href="#81131">res</a></span> <span class="typed"><span class="type">(A)CC[A,B]</span><a href="#20121">-=</a></span> <span class="typed"><span class="type">(A, B)</span><a href="#81139">kv</a></span>.<span class="typed"><span class="type">=&gt; A</span><a href="../../../scala/Tuple2.scala.html#19161">_1</a></span>
    <span class="typed"><span class="type">CC[A,B]</span><a href="#81131">res</a></span>
  }
}

        </pre>
    </body>
</html>