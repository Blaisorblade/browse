<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scalax/collection/generic/covartest/SequenceTemplate.scala</title>
        <script type="text/javascript" src="../../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: Sequence.scala 16092 2008-09-12 10:37:06Z nielsen $</span>


<span class="keyword">package</span> scalax.collection.generic.covartest

<span class="keyword">import</span> util.control.Breaks._
<span class="keyword">import</span> scalax.collection.immutable.{List, Nil, ::}

<span class="keyword">import</span> Sequence._

<span class="keyword">trait</span> <span class="typed"><span class="type">trait SequenceTemplate[+CC[+B] &lt;: scalax.collection.generic.covartest.SequenceTemplate[CC,B] with scalax.collection.Sequence[B], +A] extends java.lang.Object with PartialFunction[Int,A] with scalax.collection.generic.covartest.OrderedIterableTemplate[CC,A] with ScalaObject</span><a id="11000">SequenceTemplate</a></span>[+<span class="typed"><span class="type">[+B]&gt;: Nothing &lt;: scalax.collection.generic.covartest.SequenceTemplate[CC,B] with scalax.collection.Sequence[B]</span><a id="12332">CC</a></span>[+<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="38463">B</a></span>] &lt;: SequenceTemplate[CC, B] <span class="keyword">with</span> Sequence[B], +<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="12333">A</a></span>] <span class="keyword">extends</span> <span class="typed"><span class="type">PartialFunction[Int,A]</span><a href="../../../../scala/PartialFunction.scala.html#1295">PartialFunction</a></span>[Int, A] <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.generic.covartest.OrderedIterableTemplate[CC,A]</span><a href="OrderedIterableTemplate.scala.html#10982">OrderedIterableTemplate</a></span>[CC, A] { 
self <span class="comment">/*: CC[A]*/</span> =&gt;

  <span class="comment">/** Returns the length of the sequence.
   *
   *  @return the sequence length.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="38400">length</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>

  <span class="comment">/** Result of comparing &lt;code&gt;length&lt;/code&gt; with operand &lt;code&gt;len&lt;/code&gt;.
   *  returns &lt;code&gt;x&lt;/code&gt; where
   *  &lt;code&gt;x &amp;lt; 0&lt;/code&gt;    iff    &lt;code&gt;this.length &amp;lt; len&lt;/code&gt;
   *  &lt;code&gt;x == 0&lt;/code&gt;   iff    &lt;code&gt;this.length == len&lt;/code&gt;
   *  &lt;code&gt;x &amp;gt; 0&lt;/code&gt;    iff    &lt;code&gt;this.length &amp;gt; len&lt;/code&gt;.
   *
   *  The method as implemented here does not call length directly; its running time
   *  is O(length min len) instead of O(length). The method should be overwritten
   *  if computing length is cheap.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int)Int</span><a id="38401">lengthCompare</a></span>(<span class="typed"><span class="type">Int</span><a id="38582">len</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> =  {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38583">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="typed"><span class="type">(=&gt; Unit)Unit</span><a href="../../../util/control/Breaks.scala.html#17489">breakable</a></span> {
      <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#38492" id="38587">_</a></span> &lt;- <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>) {
        <span class="typed"><span class="type">Int</span><a href="#38583">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
        <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#38583">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int</span><a href="#38582">len</a></span>) <span class="typed"><span class="type">=&gt; Unit</span><a href="../../../util/control/Breaks.scala.html#17490">break</a></span>
      }
    }
    <span class="typed"><span class="type">Int</span><a href="#38583">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int</span><a href="#38582">len</a></span>
  }

  <span class="comment">/** Should always be &lt;code&gt;length&lt;/code&gt; */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="38402">size</a></span> = <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span>

  <span class="comment">/** Is this partial function defined for the index &lt;code&gt;x&lt;/code&gt;?
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Int)Boolean</span><a id="38403">isDefinedAt</a></span>(<span class="typed"><span class="type">Int</span><a id="38629">x</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = (<span class="typed"><span class="type">Int</span><a href="#38629">x</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3144">&gt;=</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> (<span class="typed"><span class="type">Int</span><a href="#38629">x</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3141">&lt;</a></span> <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span>)

  <span class="comment">/** Returns index of the first element satisying a predicate, or -1, if none exists.
   *
   *  @note may not terminate for infinite-sized collections.
   *  @param  p the predicate
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a id="38404">indexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38632">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a href="#38407">indexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a href="#38632">p</a></span>, <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)

  <span class="comment">/** Returns length of longest segment starting from a start index `from`
   *  such that every element of the segment satisfies predicate `p`.
   *  @note may not terminate for infinite-sized collections.
   *  @param  p the predicate
   *  @param  from  the start index
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a id="38405">segmentLength</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38642">p</a></span>: A =&gt; Boolean, <span class="typed"><span class="type">Int</span><a id="38643">from</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38644">result</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38645">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#38643">from</a></span>
    <span class="typed"><span class="type">(=&gt; Unit)Unit</span><a href="../../../util/control/Breaks.scala.html#17489">breakable</a></span> {
      <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#38492" id="38647">x</a></span> &lt;- <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>) {
        <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#38645">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3144">&gt;=</a></span> <span class="typed"><span class="type">Int</span><a href="#38643">from</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="../../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">A</span><a href="#38647">x</a></span>)) { <span class="typed"><span class="type">Int</span><a href="#38644">result</a></span> = <span class="typed"><span class="type">Int</span><a href="#38645">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int</span><a href="#38643">from</a></span>; <span class="typed"><span class="type">=&gt; Unit</span><a href="../../../util/control/Breaks.scala.html#17490">break</a></span> }
        <span class="keyword">else</span> <span class="typed"><span class="type">Int</span><a href="#38645">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      }
    }
    <span class="typed"><span class="type">Int</span><a href="#38644">result</a></span>
  }

  <span class="comment">/** Returns length of longest prefix of this seqence
   *  such that every element of the prefix satisfies predicate `p`.
   *  @note may not terminate for infinite-sized collections.
   *  @param  p the predicate
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a id="38406">prefixLength</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38685">p</a></span>: A =&gt; Boolean) = <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a href="#38405">segmentLength</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a href="#38685">p</a></span>, <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)

  <span class="comment">/** Returns index of the first element starting from a start index
   *  satisying a predicate, or -1, if none exists.
   *
   *  @note may not terminate for infinite-sized collections.
   *  @param  p the predicate
   *  @param  from  the start index
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a id="38407">indexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38634">p</a></span>: A =&gt; Boolean, <span class="typed"><span class="type">Int</span><a id="38635">from</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38687">result</a></span> = -<span class="typed"><span class="type">Int(-1)</span><span class="int">1</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38688">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#38635">from</a></span>
    <span class="typed"><span class="type">(=&gt; Unit)Unit</span><a href="../../../util/control/Breaks.scala.html#17489">breakable</a></span> {
      <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#38492" id="38690">x</a></span> &lt;- <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>) {
        <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">Int</span><a href="#38688">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3144">&gt;=</a></span> <span class="typed"><span class="type">Int</span><a href="#38635">from</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">(A)Boolean</span><a href="../../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">A</span><a href="#38690">x</a></span>)) { <span class="typed"><span class="type">Int</span><a href="#38687">result</a></span> = <span class="typed"><span class="type">Int</span><a href="#38688">i</a></span>; <span class="typed"><span class="type">=&gt; Unit</span><a href="../../../util/control/Breaks.scala.html#17490">break</a></span> }
        <span class="keyword">else</span> <span class="typed"><span class="type">Int</span><a href="#38688">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      }
    }
    <span class="typed"><span class="type">Int</span><a href="#38687">result</a></span>
  }

  <span class="comment">/** Returns index of the first element satisying a predicate, or -1.
   *
   *  @deprecated  Use `indexWhere` instead
   */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="../../../../scala/deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a id="38408">findIndexOf</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38714">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a href="#38404">indexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a href="#38714">p</a></span>)

  <span class="comment">/** Returns the index of the first occurence of the specified
   *  object in this iterable object.
   *
   *  @note may not terminate for infinite-sized collections.
   *  @param  elem  element to search for.
   *  @return the index in this sequence of the first occurence of the
   *          specified element, or -1 if the sequence does not contain
   *          this element.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B)Int</span><a id="38409">indexOf</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38411">B</a></span> &gt;: A](<span class="typed"><span class="type">B</span><a id="38716">elem</a></span>: <span class="typed"><span class="type">B</span><a href="#38411">B</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">(B,Int)Int</span><a href="#38412">indexOf</a></span>(<span class="typed"><span class="type">B</span><a href="#38716">elem</a></span>, <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)

  <span class="comment">/** Returns the index of the first occurence of the specified
   *  object in this iterable object,  starting from a start index, or
   *  -1, if none exists.
   *
   *  @note may not terminate for infinite-sized collections.
   *  @param  elem  element to search for.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B,Int)Int</span><a id="38412">indexOf</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38414">B</a></span> &gt;: A](<span class="typed"><span class="type">B</span><a id="38731">elem</a></span>: <span class="typed"><span class="type">B</span><a href="#38414">B</a></span>, <span class="typed"><span class="type">Int</span><a id="38732">from</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a href="#38407">indexWhere</a></span>(<span class="typed"><span class="type">B</span><a href="#38731">elem</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a href="#38749" id="3494">==</a></span>, <span class="typed"><span class="type">Int</span><a href="#38732">from</a></span>)

 <span class="comment">/** Returns the index of the last occurence of the specified element
   *  in this sequence, or -1 if the sequence does not contain this element.
   *
   *  @param  elem   element to search for.
   *  @return the index in this sequence of the last occurence of the
   *          specified element, or -1 if the sequence does not contain
   *          this element.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B)Int</span><a id="38415">lastIndexOf</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38417">B</a></span> &gt;: A](<span class="typed"><span class="type">B</span><a id="38750">elem</a></span>: <span class="typed"><span class="type">B</span><a href="#38417">B</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">(B,Int)Int</span><a href="#38418">lastIndexOf</a></span>(<span class="typed"><span class="type">B</span><a href="#38750">elem</a></span>, <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)

  <span class="comment">/** Returns the index of the last
    *  occurence of the specified element in this sequence
    *  before or at a given end index,
    *  or -1 if the sequence does not contain this element.
    *
    *  @param  elem   element to search for.
    *  @param  end    the end index
    */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](B,Int)Int</span><a id="38418">lastIndexOf</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38420">B</a></span> &gt;: A](<span class="typed"><span class="type">B</span><a id="38752">elem</a></span>: <span class="typed"><span class="type">B</span><a href="#38420">B</a></span>, <span class="typed"><span class="type">Int</span><a id="38753">end</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38775">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#38753">end</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a id="38776">it</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="#38424">reversedElements</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#38777" class="keyword">while</a></span> (<span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#38776">it</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#38776">it</a></span>.<span class="typed"><span class="type">()A</span><a href="../../Iterator.scala.html#20217">next</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3495">!=</a></span> <span class="typed"><span class="type">B</span><a href="#38752">elem</a></span>) <span class="typed"><span class="type">Int</span><a href="#38775">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    <span class="typed"><span class="type">Int</span><a href="#38775">i</a></span>
  }

  <span class="comment">/** Returns index of the last element satisying a predicate, or -1, if none exists.
   *
   *  @param  p the predicate
   *  @return   the index of the last element satisfying &lt;code&gt;p&lt;/code&gt;,
   *            or -1 if such an element does not exist
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a id="38421">lastIndexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38797">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a href="#38422">lastIndexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a href="#38797">p</a></span>, <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>)

  <span class="comment">/** Returns index of the last element not exceeding a given end index
   *  and satisying a predicate, or -1 if none exists.
   *
   *  @param  end the end index
   *  @param  p the predicate
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean,Int)Int</span><a id="38422">lastIndexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="38799">p</a></span>: A =&gt; Boolean, <span class="typed"><span class="type">Int</span><a id="38800">end</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="38821">i</a></span> = <span class="typed"><span class="type">Int</span><a href="#38800">end</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a id="38822">it</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="#38424">reversedElements</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#38823" class="keyword">while</a></span> (<span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#38822">it</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> (<span class="typed"><span class="type">Int</span><a href="#38821">i</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int</span><a href="#38800">end</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">(A)Boolean</span><a href="../../../../scala/Function1.scala.html#17300">p</a></span>(<span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#38822">it</a></span>.<span class="typed"><span class="type">()A</span><a href="../../Iterator.scala.html#20217">next</a></span>))) <span class="typed"><span class="type">Int</span><a href="#38821">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    <span class="typed"><span class="type">Int</span><a href="#38821">i</a></span>
  }

  <span class="comment">/** A sequence of type &lt;code&gt;C&lt;/code&gt; consisting of all elements of 
   *  this sequence in reverse order.
   *  @note  the operation is implemented by building a new sequence
   *         from &lt;code&gt;this(length - 1), ..., this(0)&lt;/code&gt;
   *  If random access is inefficient for the given sequence implementation, 
   *  this operation should be overridden.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; CC[A]</span><a id="38423">reverse</a></span>: <span class="typed"><span class="type">CC[A]</span><a href="#12332">CC</a></span>[A] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">scalax.collection.immutable.List[A]</span><a id="38845">xs</a></span>: <span class="typed"><span class="type">scalax.collection.immutable.List[A]</span><a href="../../immutable/List.scala.html#7583">List</a></span>[A] = <span class="typed"><span class="type">(Nothing*)scalax.collection.immutable.List[Nothing]</span><a href="../../immutable/List.scala.html#39003">List</a></span>()
    <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#38492" id="39090">x</a></span> &lt;- <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>) 
      <span class="typed"><span class="type">scalax.collection.immutable.List[A]</span><a href="#38845">xs</a></span> = <span class="typed"><span class="type">A</span><a href="#39090">x</a></span> <span class="typed"><span class="type">(A)scalax.collection.immutable.List[A]</span><a href="../../immutable/List.scala.html#38947">::</a></span> <span class="typed"><span class="type">scalax.collection.immutable.List[A]</span><a href="#38845">xs</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a id="38846">b</a></span> = <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a href="IterableTemplate.scala.html#38469">newBuilder</a></span>[<span class="typed"><span class="type">A</span><a href="#12333">A</a></span>]
    <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="../../immutable/Stream.scala.html#38909" id="39128">x</a></span> &lt;- <span class="typed"><span class="type">scalax.collection.immutable.List[A]</span><a href="#38845">xs</a></span>)
      <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a href="#38846">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="../Builder.scala.html#17933">+=</a></span> <span class="typed"><span class="type">A</span><a href="#39128">x</a></span>
    <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a href="#38846">b</a></span>.<span class="typed"><span class="type">=&gt; CC[A]</span><a href="../Builder.scala.html#17935">result</a></span>
  }

  <span class="comment">/** The elements of this sequence in reversed order
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a id="38424">reversedElements</a></span>: <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="../../Iterator.scala.html#6386">Iterator</a></span>[A] = <span class="typed"><span class="type">=&gt; CC[A]</span><a href="#38423">reverse</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="../IterableTemplate.scala.html#17388">elements</a></span>

  <span class="comment">/**
   * Checks whether the argument sequence is contained at the 
   * specified index within the receiver object. 
   * 
   * If the both the receiver object, &lt;code&gt;this&lt;/code&gt; and 
   * the argument, &lt;code&gt;that&lt;/code&gt; are infinite sequences 
   * this method may not terminate.
   *
   * @return true if &lt;code&gt;that&lt;/code&gt; is contained in 
   * &lt;code&gt;this&lt;/code&gt;, at the specified index, otherwise false 
   *
   * @see String.startsWith
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B](scalax.collection.Sequence[B],Int)Boolean</span><a id="38425">startsWith</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="38427">B</a></span>](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39137">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B], <span class="typed"><span class="type">Int</span><a id="39138">offset</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {  
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a id="39139">i</a></span> = <span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="IterableTemplate.scala.html#38468">elements</a></span>.<span class="typed"><span class="type">(Int)scalax.collection.Iterator[A]</span><a href="../../Iterator.scala.html#20219">drop</a></span>(<span class="typed"><span class="type">Int</span><a href="#39138">offset</a></span>)
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a id="39140">j</a></span> = <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39137">that</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[B]</span><a href="../IterableTemplate.scala.html#17388">elements</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#39141" class="keyword">while</a></span> (<span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39140">j</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39139">i</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39139">i</a></span>.<span class="typed"><span class="type">()A</span><a href="../../Iterator.scala.html#20217">next</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39140">j</a></span>.<span class="typed"><span class="type">()B</span><a href="../../Iterator.scala.html#20217">next</a></span>) <span class="typed"><span class="type">Unit</span><span >{</span></span>}
    <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39140">j</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span>
  }

  <span class="comment">/**
   * Check whether the receiver object starts with the argument sequence.
   *
   * @return true if &lt;code&gt;that&lt;/code&gt; is a prefix of &lt;code&gt;this&lt;/code&gt;,
   * otherwise false 
   *
   * @see Sequence.startsWith
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B](scalax.collection.Sequence[B])Boolean</span><a id="38428">startsWith</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="38430">B</a></span>](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39142">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">(scalax.collection.Sequence[B],Int)Boolean</span><a href="#38425">startsWith</a></span>(<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39142">that</a></span>, <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>)

  <span class="comment">/** @return true if this sequence end with that sequence 
   *  @see String.endsWith 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B](scalax.collection.Sequence[B])Boolean</span><a id="38431">endsWith</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="38433">B</a></span>](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39157">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a id="39158">i</a></span> = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="IterableTemplate.scala.html#38468">elements</a></span>.<span class="typed"><span class="type">(Int)scalax.collection.Iterator[A]</span><a href="../../Iterator.scala.html#20219">drop</a></span>(<span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39157">that</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="../SequenceTemplate.scala.html#17647">length</a></span>)
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a id="39159">j</a></span> = <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39157">that</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[B]</span><a href="../IterableTemplate.scala.html#17388">elements</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#39160" class="keyword">while</a></span> (<span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39158">i</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39159">j</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39158">i</a></span>.<span class="typed"><span class="type">()A</span><a href="../../Iterator.scala.html#20217">next</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39159">j</a></span>.<span class="typed"><span class="type">()B</span><a href="../../Iterator.scala.html#20217">next</a></span>) <span class="typed"><span class="type">Unit</span><span >(</span></span>)
    <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39159">j</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span>
  }

  <span class="comment">/** @return -1 if &lt;code&gt;that&lt;/code&gt; not contained in this, otherwise the
   *  index where &lt;code&gt;that&lt;/code&gt; is contained
   *  @see String.indexOf
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](scalax.collection.Sequence[B])Int</span><a id="38434">indexOf</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38436">B</a></span> &gt;: A](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="38718">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="39175">i</a></span> = <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>
    <span class="keyword">var</span> <span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a id="39176">s</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[A] = <span class="typed"><span class="type">=&gt; CC[A]</span><a href="IterableTemplate.scala.html#38467">thisCC</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#39177" class="keyword">while</a></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="#39176">s</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../IterableTemplate.scala.html#17395">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span>(<span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="#39176">s</a></span> <span class="typed"><span class="type">(scalax.collection.Sequence[B])Boolean</span><a href="../SequenceTemplate.scala.html#17675">startsWith</a></span> <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#38718">that</a></span>)) {
      <span class="typed"><span class="type">Int</span><a href="#39175">i</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3145">+=</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
      <span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="#39176">s</a></span> = <span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="#39176">s</a></span> <span class="typed"><span class="type">(Int)scalax.collection.Sequence[A]</span><a href="../IterableTemplate.scala.html#17477">drop</a></span> <span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span>
    } 
    <span class="typed"><span class="type">Int</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="#39176">s</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../IterableTemplate.scala.html#17395">isEmpty</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2748">||</a></span> <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#38718">that</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../IterableTemplate.scala.html#17395">isEmpty</a></span>) <span class="typed"><span class="type">Int</span><a href="#39175">i</a></span> <span class="keyword">else</span> -<span class="typed"><span class="type">Int(-1)</span><span class="int">1</span></span>
  }

  <span class="comment">/** Tests if the given value &lt;code&gt;elem&lt;/code&gt; is a member of this 
   *  sequence.
   *
   *  @param elem element whose membership has to be tested.
   *  @return     &lt;code&gt;true&lt;/code&gt; iff there is an element of this sequence
   *              which is equal (w.r.t. &lt;code&gt;==&lt;/code&gt;) to &lt;code&gt;elem&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(Any)Boolean</span><a id="38437">contains</a></span>(<span class="typed"><span class="type">Any</span><a id="39211">elem</a></span>: <span class="typed"><span class="type">Any</span><a id="49">Any</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean)Boolean</span><a href="IterableTemplate.scala.html#38494">exists</a></span> (<span class="typed"><span class="type">A</span><a href="#39214">_</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a id="3494">==</a></span> <span class="typed"><span class="type">Any</span><a href="#39211">elem</a></span>)

  <span class="comment">/** Computes the union of this sequence and the given sequence
   *  &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that the sequence of elements to add to the sequence.
   *  @return     an sequence containing the elements of this
   *              sequence and those of the given sequence &lt;code&gt;that&lt;/code&gt;
   *              which are not contained in this sequence.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](scalax.collection.Sequence[B])CC[B]</span><a id="38438">union</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38440">B</a></span> &gt;: A](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39215">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">CC[B]</span><a href="#12332">CC</a></span>[B] = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span> <span class="typed"><span class="type">(scalax.collection.Iterable[B])CC[B]</span><a href="IterableTemplate.scala.html#38477">++</a></span> (<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39215">that</a></span> <span class="typed"><span class="type">(scalax.collection.Sequence[B])scalax.collection.Sequence[B]</span><a href="../SequenceTemplate.scala.html#17688">diff</a></span> <span class="typed"><span class="type">=&gt; CC[A]</span><a href="IterableTemplate.scala.html#38467">thisCC</a></span>)

  <span class="comment">/** Computes the difference between this sequence and the given sequence
   *  &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that the sequence of elements to remove from this sequence.
   *  @return     this sequence without the elements of the given sequence
   *              &lt;code&gt;that&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](scalax.collection.Sequence[B])CC[A]</span><a id="38441">diff</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38443">B</a></span> &gt;: A](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39240">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">CC[A]</span><a href="#12332">CC</a></span>[A] = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span> <span class="typed"><span class="type">((A) =&gt; Boolean)CC[A]</span><a href="IterableTemplate.scala.html#38490">remove</a></span> (<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39240">that</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a href="../SequenceTemplate.scala.html#17684">contains</a></span> <span class="typed"><span class="type">A</span><a href="#39244">_</a></span>)

  <span class="comment">/** Computes the intersection between this sequence and the given sequence
   *  &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that the sequence to intersect.
   *  @return     the sequence of elements contained both in this sequence and
   *              in the given sequence &lt;code&gt;that&lt;/code&gt;.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](scalax.collection.Sequence[B])CC[A]</span><a id="38444">intersect</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38446">B</a></span> &gt;: A](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39246">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">CC[A]</span><a href="#12332">CC</a></span>[A] = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span> <span class="typed"><span class="type">((A) =&gt; Boolean)CC[A]</span><a href="IterableTemplate.scala.html#38489">filter</a></span>(<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39246">that</a></span> <span class="typed"><span class="type">(Any)Boolean</span><a href="../SequenceTemplate.scala.html#17684">contains</a></span> <span class="typed"><span class="type">A</span><a href="#39250">_</a></span>)

  <span class="comment">/** Builds a new sequence from this sequence in which any duplicates (wrt to ==) removed.
   *  Among duplicate elements, only the first one is retained in the result sequence
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; CC[A]</span><a id="38447">removeDuplicates</a></span>: <span class="typed"><span class="type">CC[A]</span><a href="#12332">CC</a></span>[A] = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a id="39253">b</a></span> = <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a href="IterableTemplate.scala.html#38469">newBuilder</a></span>[<span class="typed"><span class="type">A</span><a href="#12333">A</a></span>]
    <span class="keyword">var</span> <span class="typed"><span class="type">scalax.collection.Set[A]</span><a id="39254">seen</a></span> = <span class="typed"><span class="type">(A*)scalax.collection.Set[A]</span><a href="../../Set.scala.html#39257">Set</a></span>[<span class="typed"><span class="type">A</span><a href="#12333">A</a></span>]()
    <span class="keyword">for</span> (<span class="typed"><span class="type">((A) =&gt; Unit)Unit</span><a href="IterableTemplate.scala.html#38492" id="39262">x</a></span> &lt;- <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>) {
      <span class="typed"><span class="type">Unit</span><span class="keyword">if</span></span> (<span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span>(<span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="#39254">seen</a></span> <span class="typed"><span class="type">(A)Boolean</span><a href="../SetTemplate.scala.html#23830">contains</a></span> <span class="typed"><span class="type">A</span><a href="#39262">x</a></span>)) {
        <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a href="#39253">b</a></span> <span class="typed"><span class="type">(A)Unit</span><a href="../Builder.scala.html#17933">+=</a></span> <span class="typed"><span class="type">A</span><a href="#39262">x</a></span>
        <span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="#39254">seen</a></span> <span class="typed"><span class="type">(A)scalax.collection.Set[A]</span><a href="../SetTemplate.scala.html#23831">+=</a></span> <span class="typed"><span class="type">A</span><a href="#39262">x</a></span>
      }
    }
    <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,A]</span><a href="#39253">b</a></span>.<span class="typed"><span class="type">=&gt; CC[A]</span><a href="../Builder.scala.html#17935">result</a></span>
  }

  <span class="comment">/** Returns a sequence of given length containing the elements of this sequence followed by zero
   *  or more occurrences of given elements. If this sequence is already at least as long as given
   *  length, it is returned directly. Otherwise, a new sequence is created consisting of the elements
   *  of this sequence followed by enough occurrences of the given elements to reach the given length. 
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B &gt;: A](Int,B)CC[B]</span><a id="38448">padTo</a></span>[<span class="typed"><span class="type">&gt;: A &lt;: Any</span><a id="38450">B</a></span> &gt;: A](<span class="typed"><span class="type">Int</span><a id="39272">len</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">B</span><a id="39273">elem</a></span>: <span class="typed"><span class="type">B</span><a href="#38450">B</a></span>): <span class="typed"><span class="type">CC[B]</span><a href="#12332">CC</a></span>[B] = {
    <span class="keyword">var</span> <span class="typed"><span class="type">Int</span><a id="39275">diff</a></span> = <span class="typed"><span class="type">Int</span><a href="#39272">len</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-</a></span> <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,B]</span><a id="39276">b</a></span> = <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,B]</span><a href="IterableTemplate.scala.html#38469">newBuilder</a></span>[<span class="typed"><span class="type">B</span><a href="#38450">B</a></span>] <span class="comment">//!!! drop [B] and get surprising results!</span>
    <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,B]</span><a href="#39276">b</a></span> <span class="typed"><span class="type">(scalax.collection.Iterable[B])Unit</span><a href="../Growable.scala.html#17913">++=</a></span> <span class="typed"><span class="type">=&gt; CC[A]</span><a href="IterableTemplate.scala.html#38467">thisCC</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#39277" class="keyword">while</a></span> (<span class="typed"><span class="type">Int</span><a href="#39275">diff</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3143">&gt;</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>) {
      <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,B]</span><a href="#39276">b</a></span> <span class="typed"><span class="type">(B)Unit</span><a href="../Builder.scala.html#17933">+=</a></span> <span class="typed"><span class="type">B</span><a href="#39273">elem</a></span>
      <span class="typed"><span class="type">Int</span><a href="#39275">diff</a></span> <span class="typed"><span class="type">(Int)Int</span><a id="3146">-=</a></span><span class="typed"><span class="type">Int(1)</span><span class="int">1</span></span> 
    }
    <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,B]</span><a href="#39276">b</a></span>.<span class="typed"><span class="type">=&gt; CC[B]</span><a href="../Builder.scala.html#17935">result</a></span>
  }

  <span class="comment">/**
   *  Overridden for efficiency.
   *
   *  @return  the sequence itself
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.Sequence[A]</span><a id="38451">toSequence</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[A] = <span class="typed"><span class="type">=&gt; CC[A]</span><a href="IterableTemplate.scala.html#38467">thisCC</a></span> 

  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Range</span><a id="38452">indices</a></span>: <span class="typed"><span class="type">Range</span><a href="../../../../scala/Range.scala.html#1535">Range</a></span> = <span class="typed"><span class="type">implicit scala.Predef.intWrapper : (Int)scala.runtime.RichInt</span><a href="../../../../scala/Predef.scala.html#13511" class="int">0</a></span> <span class="typed"><span class="type">(Int)Range</span><a href="../../../../scala/runtime/RichInt.scala.html#19402">until</a></span> <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span>

  <span class="comment">/** Creates a view of this iterable @see OrderedIterable.View
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; scalax.collection.generic.covartest.SequenceView[CC,A]</span><a id="38453">view</a></span>: <span class="typed"><span class="type">scalax.collection.generic.covartest.SequenceView[CC,A]</span><a href="SequenceView.scala.html#11018">SequenceView</a></span>[CC, A] = <span class="typed"><span class="type">template $anon extends java.lang.Object with scalax.collection.generic.covartest.SequenceView[CC,A]</span><a id="39414" class="keyword">new</a></span> <span class="typed"><span class="type">scalax.collection.generic.covartest.SequenceView[CC,A]</span><a href="SequenceView.scala.html#11018">SequenceView</a></span>[CC, A] { <span class="comment">// !!! Martin: We should maybe infer the type parameters here?</span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Sequence[_]</span><span id="39417"><a id="39416">origin</a></span></span>: <span class="typed"><span class="type">scalax.collection.Sequence[_]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[_] = <span class="typed"><span class="type">=&gt; scalax.collection.Sequence[A]</span><a href="../IterableTemplate.scala.html#17387">thisCC</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><span id="39419"><a id="39418">elements</a></span></span>: <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="../../Iterator.scala.html#6386">Iterator</a></span>[A] = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000">self</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="IterableTemplate.scala.html#38468">elements</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">Int</span><span id="39421"><a id="39420">length</a></span></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000">self</a></span>.<span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span>
    <span class="keyword">def</span> <span class="typed"><span class="type">(Int)A</span><a id="39422">apply</a></span>(<span class="typed"><span class="type">Int</span><a id="39434">idx</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">A</span><a href="#12333">A</a></span> = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000">self</a></span>.<span class="typed"><span class="type">(Int)A</span><a href="../../../../scala/Function1.scala.html#17300">apply</a></span>(<span class="typed"><span class="type">Int</span><a href="#39434">idx</a></span>)
  }

  <span class="comment">/** A sub-sequence view  starting at index `from`
   *  and extending up to (but not including) index `until`.
   *
   *  @param from   The index of the first element of the slice
   *  @param until  The index of the element following the slice
   *  @note  The difference between `view` and `slice` is that `view` produces
   *         a view of the current sequence, whereas `slice` produces a new sequence.
   *
   *  @note view(from, to)  is equivalent to view.slice(from, to)
   */</span> 
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">(Int,Int)scalax.collection.generic.covartest.SequenceView[CC,A]</span><a id="38454">view</a></span>(<span class="typed"><span class="type">Int</span><a id="39435">from</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>, <span class="typed"><span class="type">Int</span><a id="39436">until</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">scalax.collection.generic.covartest.SequenceView[CC,A]</span><a href="SequenceView.scala.html#11018">SequenceView</a></span>[CC, A] = <span class="typed"><span class="type">=&gt; scalax.collection.generic.covartest.SequenceView[CC,A]</span><a href="#38453">view</a></span>.<span class="typed"><span class="type">(Int,Int)scalax.collection.generic.covartest.SequenceView[CC,A]</span><a href="SequenceView.scala.html#39409">slice</a></span>(<span class="typed"><span class="type">Int</span><a href="#39435">from</a></span>, <span class="typed"><span class="type">Int</span><a href="#39436">until</a></span>)

  <span class="comment">/** Returns index of the last element satisying a predicate, or -1.
   *  @deprecated use `lastIndexWhere` instead
   */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="../../../../scala/deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a id="38455">findLastIndexOf</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a id="39451">p</a></span>: A =&gt; Boolean): <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean)Int</span><a href="#38421">lastIndexWhere</a></span>(<span class="typed"><span class="type">(A) =&gt; Boolean</span><a href="#39451">p</a></span>)

  <span class="comment">/** A sub-sequence starting at index &lt;code&gt;from&lt;/code&gt; 
    *  and extending up to the length of the current sequence
    *
    *  @param from   The index of the first element of the slice
    *  @throws IndexOutOfBoundsException if &lt;code&gt;from &amp;lt; 0&lt;/code&gt;
    *  @deprecated   use &lt;code&gt;drop&lt;/code&gt; instead
    */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="../../../../scala/deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">(Int)scalax.collection.Sequence[A]</span><a id="38456">slice</a></span>(<span class="typed"><span class="type">Int</span><a id="39453">from</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>): <span class="typed"><span class="type">scalax.collection.Sequence[A]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[A] = <span class="typed"><span class="type">(Int,Int)CC[A]</span><a href="IterableTemplate.scala.html#38558">slice</a></span>(<span class="typed"><span class="type">Int</span><a href="#39453">from</a></span>, <span class="typed"><span class="type">=&gt; Int</span><a href="#38400">length</a></span>)

  <span class="comment">/** @deprecated Should be replaced by 
   *
   *   &lt;code&gt;(s1, s2) forall { case (x, y) =&gt; f(x, y) }&lt;/code&gt;
   */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="../../../../scala/deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">[B](scalax.collection.Sequence[B])((A, B) =&gt; Boolean)Boolean</span><a id="38457">equalsWith</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="38459">B</a></span>](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39467">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B])(<span class="typed"><span class="type">(A, B) =&gt; Boolean</span><a id="39468">f</a></span>: (A,B) =&gt; Boolean): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = {
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a id="39469">i</a></span> = <span class="typed"><span class="type">SequenceTemplate.this.type</span><a href="#11000" class="keyword">this</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[A]</span><a href="IterableTemplate.scala.html#38468">elements</a></span>
    <span class="keyword">val</span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a id="39470">j</a></span> = <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39467">that</a></span>.<span class="typed"><span class="type">=&gt; scalax.collection.Iterator[B]</span><a href="../IterableTemplate.scala.html#17388">elements</a></span>
    <span class="typed"><span class="type">Unit</span><a href="#39471" class="keyword">while</a></span> (<span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39469">i</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39470">j</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">(A,B)Boolean</span><a href="../../../../scala/Function2.scala.html#20399">f</a></span>(<span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39469">i</a></span>.<span class="typed"><span class="type">()A</span><a href="../../Iterator.scala.html#20217">next</a></span>, <span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39470">j</a></span>.<span class="typed"><span class="type">()B</span><a href="../../Iterator.scala.html#20217">next</a></span>)) <span class="typed"><span class="type">Unit</span><span >(</span></span>)
    <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scalax.collection.Iterator[A]</span><a href="#39469">i</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span> <span class="typed"><span class="type">(Boolean)Boolean</span><a id="2749">&amp;&amp;</a></span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="2745">!</a></span><span class="typed"><span class="type">scalax.collection.Iterator[B]</span><a href="#39470">j</a></span>.<span class="typed"><span class="type">=&gt; Boolean</span><a href="../../Iterator.scala.html#20216">hasNext</a></span>
  }

  <span class="comment">/** Is &lt;code&gt;that&lt;/code&gt; a slice in this? 
   *  @deprecated  Should be repaced by &lt;code&gt;indexOf(that) != -1&lt;/code&gt;
   */</span>
  @<span class="typed"><span class="type">deprecated</span><a href="../../../../scala/deprecated.scala.html#215">deprecated</a></span> <span class="keyword">def</span> <span class="typed"><span class="type">[B](scalax.collection.Sequence[B])Boolean</span><a id="38460">containsSlice</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="38462">B</a></span>](<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a id="39472">that</a></span>: <span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="../../Sequence.scala.html#6296">Sequence</a></span>[B]): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">(scalax.collection.Sequence[Any])Int</span><a href="#38434">indexOf</a></span>(<span class="typed"><span class="type">scalax.collection.Sequence[B]</span><a href="#39472">that</a></span>) <span class="typed"><span class="type">(Int)Boolean</span><a id="3140">!=</a></span> -<span class="typed"><span class="type">Int(-1)</span><span class="int">1</span></span> 

}

        </pre>
    </body>
</html>