<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>scalax/collection/generic/SetTemplate.scala</title>
        <script type="text/javascript" src="../../../linked.js"></script>
        <link rel="stylesheet" type="text/css" href="../../../style.css" title="Style">
    </head>
    <body onload="initializeLinked()">
        <pre>
<span class="comment">/*                     __                                               *\
**     ________ ___   / /  ___     Scala API                            **
**    / __/ __// _ | / /  / _ |    (c) 2003-2009, LAMP/EPFL             **
**  __\ \/ /__/ __ |/ /__/ __ |    http://scala-lang.org/               **
** /____/\___/_/ |_/____/_/ | |                                         **
**                          |/                                          **
\*                                                                      */</span>

<span class="comment">// $Id: Set.scala 16893 2009-01-13 13:09:22Z cunei $</span>


<span class="keyword">package</span> scalax.collection.generic


<span class="comment">/** &lt;p&gt;
 *    A set is a collection that includes at most one of any object.
 *  &lt;/p&gt;
 *  &lt;p&gt;
 *    This trait provides a limited interface, only allowing reading of elements.
 *    There are two extensions of this trait, in packages
 *    &lt;code&gt;&lt;a href=&quot;mutable$content.html&quot; target=&quot;contentFrame&quot;&gt;
 *    scala.collection.mutable&lt;/a&gt;&lt;/code&gt;
 *    and &lt;code&gt;&lt;a href=&quot;immutable$content.html&quot; target=&quot;contentFrame&quot;&gt;
 *    scala.collection.immutable&lt;/a&gt;&lt;/code&gt;, which provide functionality for
 *    adding and removing objects from the set. The trait in the first package is
 *    for sets that are modified destructively, whereas the trait in
 *    the second package is for immutable sets which create a new set
 *    when something is added or removed to them.
 *
 *  @author  Matthias Zenger
 *  @author  Martin Odersky
 *  @version 2.8
 */</span>
<span class="keyword">trait</span> <span class="typed"><span class="type">trait SetTemplate[+CC[B] &lt;: scalax.collection.generic.SetTemplate[CC,B] with scalax.collection.Set[B], A] extends java.lang.Object with (A) =&gt; Boolean with scalax.collection.SizedIterable[A] with scalax.collection.generic.IterableTemplate[CC,A] with scalax.collection.generic.Addable[CC[A],A] with scalax.collection.generic.Subtractable[CC[A],A] with ScalaObject</span><a id="10485">SetTemplate</a></span>[+<span class="typed"><span class="type">[B]&gt;: Nothing &lt;: scalax.collection.generic.SetTemplate[CC,B] with scalax.collection.Set[B]</span><a id="15048">CC</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="23840">B</a></span>] &lt;: SetTemplate[CC, B] <span class="keyword">with</span> Set[B], <span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="15049">A</a></span>] 
  <span class="keyword">extends</span> (A =&gt; Boolean) 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.SizedIterable[A]</span><a href="../SizedIterable.scala.html#6380">SizedIterable</a></span>[A] 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.generic.IterableTemplate[CC,A]</span><a href="IterableTemplate.scala.html#10662">IterableTemplate</a></span>[CC, A] 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.generic.Addable[CC[A],A]</span><a href="Addable.scala.html#10569">Addable</a></span>[CC[A], A] 
     <span class="keyword">with</span> <span class="typed"><span class="type">scalax.collection.generic.Subtractable[CC[A],A]</span><a href="Subtractable.scala.html#10494">Subtractable</a></span>[CC[A], A] { 

  <span class="comment">/** Returns the number of elements in this set. 
   *
   *  @return number of set elements.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Int</span><a id="23826">size</a></span>: <span class="typed"><span class="type">Int</span><a id="2392">Int</a></span>

  <span class="comment">/** Creates a new set of this kind with given elements */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">[B]scalax.collection.generic.Builder[CC,B]</span><a id="23827">newBuilder</a></span>[<span class="typed"><span class="type">&gt;: Nothing &lt;: Any</span><a id="23829">B</a></span>]: <span class="typed"><span class="type">scalax.collection.generic.Builder[CC,B]</span><a href="Builder.scala.html#10377">Builder</a></span>[CC, B]

  <span class="comment">/** Checks if this set contains element &lt;code&gt;elem&lt;/code&gt;.
   *
   *  @param elem the element to check for membership.
   *  @return     &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;elem&lt;/code&gt; is contained in
   *              this set.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="23830">contains</a></span>(<span class="typed"><span class="type">A</span><a id="23938">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#15049">A</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span>

  <span class="comment">/** Create a new set with an additional element.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)CC[A]</span><a id="23831">+</a></span> (<span class="typed"><span class="type">A</span><a id="23989">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#15049">A</a></span>): <span class="typed"><span class="type">CC[A]</span><a href="#15048">CC</a></span>[A]

  <span class="comment">/** Remove a single element from a set.
   *  @param elem the element to be removed
   *  @return a new set with the element removed.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)CC[A]</span><a id="23832">-</a></span> (<span class="typed"><span class="type">A</span><a id="23995">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#15049">A</a></span>): <span class="typed"><span class="type">CC[A]</span><a href="#15048">CC</a></span>[A]

  <span class="comment">/** Checks if this set is empty.
   *
   *  @return &lt;code&gt;true&lt;/code&gt; iff there is no element in the set.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; Boolean</span><a id="23833">isEmpty</a></span>: <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">=&gt; Int</span><a href="#23826">size</a></span> <span class="typed"><span class="type">(Int)Boolean</span><a id="3139">==</a></span> <span class="typed"><span class="type">Int(0)</span><span class="int">0</span></span>

  <span class="comment">/** This method allows sets to be interpreted as predicates.
   *  It returns &lt;code&gt;true&lt;/code&gt;, iff this set contains element
   *  &lt;code&gt;elem&lt;/code&gt;.
   *
   *  @param elem the element to check for membership.
   *  @return     &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;elem&lt;/code&gt; is contained in
   *              this set.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(A)Boolean</span><a id="23834">apply</a></span>(<span class="typed"><span class="type">A</span><a id="78981">elem</a></span>: <span class="typed"><span class="type">A</span><a href="#15049">A</a></span>): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">(A)Boolean</span><a href="#23830">contains</a></span>(<span class="typed"><span class="type">A</span><a href="#78981">elem</a></span>)

  <span class="comment">/** This method computes an intersection with set &lt;code&gt;that&lt;/code&gt;.
   *  It removes all the elements that are not present in &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that the set to intersect with.
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(scalax.collection.Set[A])CC[A]</span><a id="23835">intersect</a></span>(<span class="typed"><span class="type">scalax.collection.Set[A]</span><a id="78982">that</a></span>: <span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="../Set.scala.html#6308">Set</a></span>[A]): <span class="typed"><span class="type">CC[A]</span><a href="#15048">CC</a></span>[A] = <span class="typed"><span class="type">((A) =&gt; Boolean)CC[A]</span><a href="IterableTemplate.scala.html#17409">filter</a></span>(<span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="#78982">that</a></span>.<span class="typed"><span class="type">(A)Boolean</span><a href="#23830">contains</a></span>)

  <span class="comment">/** This method is an alias for &lt;code&gt;intersect&lt;/code&gt;. 
   *  It computes an intersection with set &lt;code&gt;that&lt;/code&gt;.
   *  It removes all the elements that are not present in &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that the set to intersect with
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(scalax.collection.Set[A])CC[A]</span><a id="23836">**</a></span> (<span class="typed"><span class="type">scalax.collection.Set[A]</span><a id="78986">that</a></span>: collection.<span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="../Set.scala.html#6308">Set</a></span>[A]): <span class="typed"><span class="type">CC[A]</span><a href="#15048">CC</a></span>[A] = <span class="typed"><span class="type">(scalax.collection.Set[A])CC[A]</span><a href="#23835">intersect</a></span>(<span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="#78986">that</a></span>)

  <span class="comment">/** Checks if this set is a subset of set &lt;code&gt;that&lt;/code&gt;.
   *
   *  @param that another set.
   *  @return     &lt;code&gt;true&lt;/code&gt; iff the other set is a superset of
   *              this set.
   *  todo: rename to isSubsetOf  
   */</span>
  <span class="keyword">def</span> <span class="typed"><span class="type">(scalax.collection.Set[A])Boolean</span><a id="23837">subsetOf</a></span>(<span class="typed"><span class="type">scalax.collection.Set[A]</span><a id="78988">that</a></span>: <span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="../Set.scala.html#6308">Set</a></span>[A]): <span class="typed"><span class="type">Boolean</span><a id="2168">Boolean</a></span> = <span class="typed"><span class="type">((A) =&gt; Boolean)Boolean</span><a href="IterableTemplate.scala.html#17413">forall</a></span>(<span class="typed"><span class="type">scalax.collection.Set[A]</span><a href="#78988">that</a></span>.<span class="typed"><span class="type">(A)Boolean</span><a href="#23830">contains</a></span>)

<span class="comment">/* What a mess! We need to remove these methods, but can't without breaking
 * existing code. What to do?

  /** Compares this set with another object and returns true, iff the
   *  other object is also a set which contains the same elements as
   *  this set.
   *
   *  @param that the other object
   *  @note not necessarily run-time type safe.
   *  @return     &lt;code&gt;true&lt;/code&gt; iff this set and the other set
   *              contain the same elements.
   *  @deprecated equals is not stable for mutable sets.
   *              If you wish object identity, use eq or cast this set of AnyRef and then use
   *              equals. If you wish element comparisons, use `sameElements` instead.
   */
  @deprecated override def equals(that: Any): Boolean = that match {
    case other: Set[_] =&gt;
      this.size == other.size &amp;&amp; subsetOf(other.asInstanceOf[Set[A]])
    case _ =&gt;
      false
  }

  /*  @deprecated Since the previous hashCode is not stable for mutable sets,
   *              the implementation of this method has been changed to
   *              standard address-based hashCode from java.lang.Object.
   *              If you relied on the old behavior, y
   *              IT has been 
   *  if you intend to have object identity hashCode and wish the deprecated warning
   *              to go away, cast this set to AnyRef before calling hashCode.
   */
  @deprecated override def hashCode() =
    (0 /: this)((hash, e) =&gt; hash + e.hashCode())
*/</span>
  <span class="comment">/** Defines the prefix of this object's &lt;code&gt;toString&lt;/code&gt; representation.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">=&gt; String</span><a id="23838">stringPrefix</a></span>: <span class="typed"><span class="type">String</span><a id="1859">String</a></span> = <span class="typed"><span class="type">java.lang.String(&quot;Set&quot;)</span><span class="string">&quot;Set&quot;</span></span>

  <span class="comment">/** Need to override string, so that it's not the Function1's string that gets mixed in.
   */</span>
  <span class="keyword">override</span> <span class="keyword">def</span> <span class="typed"><span class="type">()String</span><a id="23839">toString</a></span> = <span class="keyword">super</span>[IterableTemplate].<span class="typed"><span class="type">()String</span><a href="IterableTemplate.scala.html#17468">toString</a></span>
}

        </pre>
    </body>
</html>